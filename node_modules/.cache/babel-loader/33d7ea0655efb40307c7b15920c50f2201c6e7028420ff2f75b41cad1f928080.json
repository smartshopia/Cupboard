{"ast":null,"code":"\"use strict\";\n\nmodule.exports = MapField;\n\n// extends Field\nvar Field = require(\"./field\");\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\nvar types = require(\"./types\"),\n  util = require(\"./util\");\n\n/**\r\n * Constructs a new map field instance.\r\n * @classdesc Reflected map field.\r\n * @extends FieldBase\r\n * @constructor\r\n * @param {string} name Unique name within its namespace\r\n * @param {number} id Unique id within its namespace\r\n * @param {string} keyType Key type\r\n * @param {string} type Value type\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @param {string} [comment] Comment associated with this field\r\n */\nfunction MapField(name, id, keyType, type, options, comment) {\n  Field.call(this, name, id, type, undefined, undefined, options, comment);\n\n  /* istanbul ignore if */\n  if (!util.isString(keyType)) throw TypeError(\"keyType must be a string\");\n\n  /**\r\n   * Key type.\r\n   * @type {string}\r\n   */\n  this.keyType = keyType; // toJSON, marker\n\n  /**\r\n   * Resolved key type if not a basic type.\r\n   * @type {ReflectionObject|null}\r\n   */\n  this.resolvedKeyType = null;\n\n  // Overrides Field#map\n  this.map = true;\n}\n\n/**\r\n * Map field descriptor.\r\n * @interface IMapField\r\n * @extends {IField}\r\n * @property {string} keyType Key type\r\n */\n\n/**\r\n * Extension map field descriptor.\r\n * @interface IExtensionMapField\r\n * @extends IMapField\r\n * @property {string} extend Extended type\r\n */\n\n/**\r\n * Constructs a map field from a map field descriptor.\r\n * @param {string} name Field name\r\n * @param {IMapField} json Map field descriptor\r\n * @returns {MapField} Created map field\r\n * @throws {TypeError} If arguments are invalid\r\n */\nMapField.fromJSON = function fromJSON(name, json) {\n  return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n\n/**\r\n * Converts this map field to a map field descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IMapField} Map field descriptor\r\n */\nMapField.prototype.toJSON = function toJSON(toJSONOptions) {\n  var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n  return util.toObject([\"keyType\", this.keyType, \"type\", this.type, \"id\", this.id, \"extend\", this.extend, \"options\", this.options, \"comment\", keepComments ? this.comment : undefined]);\n};\n\n/**\r\n * @override\r\n */\nMapField.prototype.resolve = function resolve() {\n  if (this.resolved) return this;\n\n  // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n  if (types.mapKey[this.keyType] === undefined) throw Error(\"invalid key type: \" + this.keyType);\n  return Field.prototype.resolve.call(this);\n};\n\n/**\r\n * Map field decorator (TypeScript).\r\n * @name MapField.d\r\n * @function\r\n * @param {number} fieldId Field id\r\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\r\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\r\n * @returns {FieldDecorator} Decorator function\r\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\r\n */\nMapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n  // submessage value: decorate the submessage and use its name as the type\n  if (typeof fieldValueType === \"function\") fieldValueType = util.decorateType(fieldValueType).name;\n\n  // enum reference value: create a reflected copy of the enum and keep reuseing it\n  else if (fieldValueType && typeof fieldValueType === \"object\") fieldValueType = util.decorateEnum(fieldValueType).name;\n  return function mapFieldDecorator(prototype, fieldName) {\n    util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n  };\n};","map":{"version":3,"names":["module","exports","MapField","Field","require","prototype","Object","create","constructor","className","types","util","name","id","keyType","type","options","comment","call","undefined","isString","TypeError","resolvedKeyType","map","fromJSON","json","toJSON","toJSONOptions","keepComments","Boolean","toObject","extend","resolve","resolved","mapKey","Error","d","decorateMapField","fieldId","fieldKeyType","fieldValueType","decorateType","decorateEnum","mapFieldDecorator","fieldName","add"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/protobufjs/src/mapfield.js"],"sourcesContent":["\"use strict\";\r\nmodule.exports = MapField;\r\n\r\n// extends Field\r\nvar Field = require(\"./field\");\r\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\r\n\r\nvar types   = require(\"./types\"),\r\n    util    = require(\"./util\");\r\n\r\n/**\r\n * Constructs a new map field instance.\r\n * @classdesc Reflected map field.\r\n * @extends FieldBase\r\n * @constructor\r\n * @param {string} name Unique name within its namespace\r\n * @param {number} id Unique id within its namespace\r\n * @param {string} keyType Key type\r\n * @param {string} type Value type\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @param {string} [comment] Comment associated with this field\r\n */\r\nfunction MapField(name, id, keyType, type, options, comment) {\r\n    Field.call(this, name, id, type, undefined, undefined, options, comment);\r\n\r\n    /* istanbul ignore if */\r\n    if (!util.isString(keyType))\r\n        throw TypeError(\"keyType must be a string\");\r\n\r\n    /**\r\n     * Key type.\r\n     * @type {string}\r\n     */\r\n    this.keyType = keyType; // toJSON, marker\r\n\r\n    /**\r\n     * Resolved key type if not a basic type.\r\n     * @type {ReflectionObject|null}\r\n     */\r\n    this.resolvedKeyType = null;\r\n\r\n    // Overrides Field#map\r\n    this.map = true;\r\n}\r\n\r\n/**\r\n * Map field descriptor.\r\n * @interface IMapField\r\n * @extends {IField}\r\n * @property {string} keyType Key type\r\n */\r\n\r\n/**\r\n * Extension map field descriptor.\r\n * @interface IExtensionMapField\r\n * @extends IMapField\r\n * @property {string} extend Extended type\r\n */\r\n\r\n/**\r\n * Constructs a map field from a map field descriptor.\r\n * @param {string} name Field name\r\n * @param {IMapField} json Map field descriptor\r\n * @returns {MapField} Created map field\r\n * @throws {TypeError} If arguments are invalid\r\n */\r\nMapField.fromJSON = function fromJSON(name, json) {\r\n    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\r\n};\r\n\r\n/**\r\n * Converts this map field to a map field descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IMapField} Map field descriptor\r\n */\r\nMapField.prototype.toJSON = function toJSON(toJSONOptions) {\r\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\r\n    return util.toObject([\r\n        \"keyType\" , this.keyType,\r\n        \"type\"    , this.type,\r\n        \"id\"      , this.id,\r\n        \"extend\"  , this.extend,\r\n        \"options\" , this.options,\r\n        \"comment\" , keepComments ? this.comment : undefined\r\n    ]);\r\n};\r\n\r\n/**\r\n * @override\r\n */\r\nMapField.prototype.resolve = function resolve() {\r\n    if (this.resolved)\r\n        return this;\r\n\r\n    // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\r\n    if (types.mapKey[this.keyType] === undefined)\r\n        throw Error(\"invalid key type: \" + this.keyType);\r\n\r\n    return Field.prototype.resolve.call(this);\r\n};\r\n\r\n/**\r\n * Map field decorator (TypeScript).\r\n * @name MapField.d\r\n * @function\r\n * @param {number} fieldId Field id\r\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\r\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\r\n * @returns {FieldDecorator} Decorator function\r\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\r\n */\r\nMapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\r\n\r\n    // submessage value: decorate the submessage and use its name as the type\r\n    if (typeof fieldValueType === \"function\")\r\n        fieldValueType = util.decorateType(fieldValueType).name;\r\n\r\n    // enum reference value: create a reflected copy of the enum and keep reuseing it\r\n    else if (fieldValueType && typeof fieldValueType === \"object\")\r\n        fieldValueType = util.decorateEnum(fieldValueType).name;\r\n\r\n    return function mapFieldDecorator(prototype, fieldName) {\r\n        util.decorateType(prototype.constructor)\r\n            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\r\n    };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}