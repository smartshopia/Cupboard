{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QuerySnapshot = void 0;\nconst validate_1 = require(\"../validate\");\nconst util_1 = require(\"../util\");\n/**\n * A QuerySnapshot contains zero or more\n * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} objects\n * representing the results of a query. The documents can be accessed as an\n * array via the [documents]{@link QuerySnapshot#documents} property\n * or enumerated using the [forEach]{@link QuerySnapshot#forEach}\n * method. The number of documents can be determined via the\n * [empty]{@link QuerySnapshot#empty} and\n * [size]{@link QuerySnapshot#size} properties.\n *\n * @class QuerySnapshot\n */\nclass QuerySnapshot {\n  /**\n   * @private\n   *\n   * @param _query The originating query.\n   * @param _readTime The time when this query snapshot was obtained.\n   * @param _size The number of documents in the result set.\n   * @param docs A callback returning a sorted array of documents matching\n   * this query\n   * @param changes A callback returning a sorted array of document change\n   * events for this snapshot.\n   */\n  constructor(_query, _readTime, _size, docs, changes) {\n    this._query = _query;\n    this._readTime = _readTime;\n    this._size = _size;\n    this._materializedDocs = null;\n    this._materializedChanges = null;\n    this._docs = null;\n    this._changes = null;\n    this._docs = docs;\n    this._changes = changes;\n  }\n  /**\n   * The query on which you called get() or onSnapshot() in order to get this\n   * QuerySnapshot.\n   *\n   * @type {Query}\n   * @name QuerySnapshot#query\n   * @readonly\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.limit(10).get().then(querySnapshot => {\n   *   console.log(`Returned first batch of results`);\n   *   let query = querySnapshot.query;\n   *   return query.offset(10).get();\n   * }).then(() => {\n   *   console.log(`Returned second batch of results`);\n   * });\n   * ```\n   */\n  get query() {\n    return this._query;\n  }\n  /**\n   * An array of all the documents in this QuerySnapshot.\n   *\n   * @type {Array.<QueryDocumentSnapshot>}\n   * @name QuerySnapshot#docs\n   * @readonly\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   let docs = querySnapshot.docs;\n   *   for (let doc of docs) {\n   *     console.log(`Document found at path: ${doc.ref.path}`);\n   *   }\n   * });\n   * ```\n   */\n  get docs() {\n    if (this._materializedDocs) {\n      return this._materializedDocs;\n    }\n    this._materializedDocs = this._docs();\n    this._docs = null;\n    return this._materializedDocs;\n  }\n  /**\n   * True if there are no documents in the QuerySnapshot.\n   *\n   * @type {boolean}\n   * @name QuerySnapshot#empty\n   * @readonly\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   if (querySnapshot.empty) {\n   *     console.log('No documents found.');\n   *   }\n   * });\n   * ```\n   */\n  get empty() {\n    return this._size === 0;\n  }\n  /**\n   * The number of documents in the QuerySnapshot.\n   *\n   * @type {number}\n   * @name QuerySnapshot#size\n   * @readonly\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   console.log(`Found ${querySnapshot.size} documents.`);\n   * });\n   * ```\n   */\n  get size() {\n    return this._size;\n  }\n  /**\n   * The time this query snapshot was obtained.\n   *\n   * @type {Timestamp}\n   * @name QuerySnapshot#readTime\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then((querySnapshot) => {\n   *   let readTime = querySnapshot.readTime;\n   *   console.log(`Query results returned at '${readTime.toDate()}'`);\n   * });\n   * ```\n   */\n  get readTime() {\n    return this._readTime;\n  }\n  /**\n   * Returns an array of the documents changes since the last snapshot. If\n   * this is the first snapshot, all documents will be in the list as added\n   * changes.\n   *\n   * @return {Array.<DocumentChange>}\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.onSnapshot(querySnapshot => {\n   *   let changes = querySnapshot.docChanges();\n   *   for (let change of changes) {\n   *     console.log(`A document was ${change.type}.`);\n   *   }\n   * });\n   * ```\n   */\n  docChanges() {\n    if (this._materializedChanges) {\n      return this._materializedChanges;\n    }\n    this._materializedChanges = this._changes();\n    this._changes = null;\n    return this._materializedChanges;\n  }\n  /**\n   * Enumerates all of the documents in the QuerySnapshot. This is a convenience\n   * method for running the same callback on each {@link QueryDocumentSnapshot}\n   * that is returned.\n   *\n   * @param {function} callback A callback to be called with a\n   * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} for each document in\n   * the snapshot.\n   * @param {*=} thisArg The `this` binding for the callback..\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Document found at path: ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  forEach(callback, thisArg) {\n    (0, validate_1.validateFunction)('callback', callback);\n    for (const doc of this.docs) {\n      callback.call(thisArg, doc);\n    }\n  }\n  /**\n   * Returns true if the document data in this `QuerySnapshot` is equal to the\n   * provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `QuerySnapshot` is equal to the provided\n   * value.\n   */\n  isEqual(other) {\n    // Since the read time is different on every query read, we explicitly\n    // ignore all metadata in this comparison.\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof QuerySnapshot)) {\n      return false;\n    }\n    if (this._size !== other._size) {\n      return false;\n    }\n    if (!this._query.isEqual(other._query)) {\n      return false;\n    }\n    if (this._materializedDocs && !this._materializedChanges) {\n      // If we have only materialized the documents, we compare them first.\n      return (0, util_1.isArrayEqual)(this.docs, other.docs) && (0, util_1.isArrayEqual)(this.docChanges(), other.docChanges());\n    }\n    // Otherwise, we compare the changes first as we expect there to be fewer.\n    return (0, util_1.isArrayEqual)(this.docChanges(), other.docChanges()) && (0, util_1.isArrayEqual)(this.docs, other.docs);\n  }\n}\nexports.QuerySnapshot = QuerySnapshot;","map":{"version":3,"names":["Object","defineProperty","exports","value","QuerySnapshot","validate_1","require","util_1","constructor","_query","_readTime","_size","docs","changes","_materializedDocs","_materializedChanges","_docs","_changes","query","empty","size","readTime","docChanges","forEach","callback","thisArg","validateFunction","doc","call","isEqual","other","isArrayEqual"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@google-cloud/firestore/build/src/reference/query-snapshot.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QuerySnapshot = void 0;\nconst validate_1 = require(\"../validate\");\nconst util_1 = require(\"../util\");\n/**\n * A QuerySnapshot contains zero or more\n * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} objects\n * representing the results of a query. The documents can be accessed as an\n * array via the [documents]{@link QuerySnapshot#documents} property\n * or enumerated using the [forEach]{@link QuerySnapshot#forEach}\n * method. The number of documents can be determined via the\n * [empty]{@link QuerySnapshot#empty} and\n * [size]{@link QuerySnapshot#size} properties.\n *\n * @class QuerySnapshot\n */\nclass QuerySnapshot {\n    /**\n     * @private\n     *\n     * @param _query The originating query.\n     * @param _readTime The time when this query snapshot was obtained.\n     * @param _size The number of documents in the result set.\n     * @param docs A callback returning a sorted array of documents matching\n     * this query\n     * @param changes A callback returning a sorted array of document change\n     * events for this snapshot.\n     */\n    constructor(_query, _readTime, _size, docs, changes) {\n        this._query = _query;\n        this._readTime = _readTime;\n        this._size = _size;\n        this._materializedDocs = null;\n        this._materializedChanges = null;\n        this._docs = null;\n        this._changes = null;\n        this._docs = docs;\n        this._changes = changes;\n    }\n    /**\n     * The query on which you called get() or onSnapshot() in order to get this\n     * QuerySnapshot.\n     *\n     * @type {Query}\n     * @name QuerySnapshot#query\n     * @readonly\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.limit(10).get().then(querySnapshot => {\n     *   console.log(`Returned first batch of results`);\n     *   let query = querySnapshot.query;\n     *   return query.offset(10).get();\n     * }).then(() => {\n     *   console.log(`Returned second batch of results`);\n     * });\n     * ```\n     */\n    get query() {\n        return this._query;\n    }\n    /**\n     * An array of all the documents in this QuerySnapshot.\n     *\n     * @type {Array.<QueryDocumentSnapshot>}\n     * @name QuerySnapshot#docs\n     * @readonly\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   let docs = querySnapshot.docs;\n     *   for (let doc of docs) {\n     *     console.log(`Document found at path: ${doc.ref.path}`);\n     *   }\n     * });\n     * ```\n     */\n    get docs() {\n        if (this._materializedDocs) {\n            return this._materializedDocs;\n        }\n        this._materializedDocs = this._docs();\n        this._docs = null;\n        return this._materializedDocs;\n    }\n    /**\n     * True if there are no documents in the QuerySnapshot.\n     *\n     * @type {boolean}\n     * @name QuerySnapshot#empty\n     * @readonly\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   if (querySnapshot.empty) {\n     *     console.log('No documents found.');\n     *   }\n     * });\n     * ```\n     */\n    get empty() {\n        return this._size === 0;\n    }\n    /**\n     * The number of documents in the QuerySnapshot.\n     *\n     * @type {number}\n     * @name QuerySnapshot#size\n     * @readonly\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   console.log(`Found ${querySnapshot.size} documents.`);\n     * });\n     * ```\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * The time this query snapshot was obtained.\n     *\n     * @type {Timestamp}\n     * @name QuerySnapshot#readTime\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then((querySnapshot) => {\n     *   let readTime = querySnapshot.readTime;\n     *   console.log(`Query results returned at '${readTime.toDate()}'`);\n     * });\n     * ```\n     */\n    get readTime() {\n        return this._readTime;\n    }\n    /**\n     * Returns an array of the documents changes since the last snapshot. If\n     * this is the first snapshot, all documents will be in the list as added\n     * changes.\n     *\n     * @return {Array.<DocumentChange>}\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.onSnapshot(querySnapshot => {\n     *   let changes = querySnapshot.docChanges();\n     *   for (let change of changes) {\n     *     console.log(`A document was ${change.type}.`);\n     *   }\n     * });\n     * ```\n     */\n    docChanges() {\n        if (this._materializedChanges) {\n            return this._materializedChanges;\n        }\n        this._materializedChanges = this._changes();\n        this._changes = null;\n        return this._materializedChanges;\n    }\n    /**\n     * Enumerates all of the documents in the QuerySnapshot. This is a convenience\n     * method for running the same callback on each {@link QueryDocumentSnapshot}\n     * that is returned.\n     *\n     * @param {function} callback A callback to be called with a\n     * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} for each document in\n     * the snapshot.\n     * @param {*=} thisArg The `this` binding for the callback..\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Document found at path: ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    forEach(callback, thisArg) {\n        (0, validate_1.validateFunction)('callback', callback);\n        for (const doc of this.docs) {\n            callback.call(thisArg, doc);\n        }\n    }\n    /**\n     * Returns true if the document data in this `QuerySnapshot` is equal to the\n     * provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `QuerySnapshot` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        // Since the read time is different on every query read, we explicitly\n        // ignore all metadata in this comparison.\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof QuerySnapshot)) {\n            return false;\n        }\n        if (this._size !== other._size) {\n            return false;\n        }\n        if (!this._query.isEqual(other._query)) {\n            return false;\n        }\n        if (this._materializedDocs && !this._materializedChanges) {\n            // If we have only materialized the documents, we compare them first.\n            return ((0, util_1.isArrayEqual)(this.docs, other.docs) &&\n                (0, util_1.isArrayEqual)(this.docChanges(), other.docChanges()));\n        }\n        // Otherwise, we compare the changes first as we expect there to be fewer.\n        return ((0, util_1.isArrayEqual)(this.docChanges(), other.docChanges()) &&\n            (0, util_1.isArrayEqual)(this.docs, other.docs));\n    }\n}\nexports.QuerySnapshot = QuerySnapshot;\n//# sourceMappingURL=query-snapshot.js.map"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,aAAa,GAAG,KAAK,CAAC;AAC9B,MAAMC,UAAU,GAAGC,OAAO,CAAC,aAAa,CAAC;AACzC,MAAMC,MAAM,GAAGD,OAAO,CAAC,SAAS,CAAC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMF,aAAa,CAAC;EAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,WAAWA,CAACC,MAAM,EAAEC,SAAS,EAAEC,KAAK,EAAEC,IAAI,EAAEC,OAAO,EAAE;IACjD,IAAI,CAACJ,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACG,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACC,oBAAoB,GAAG,IAAI;IAChC,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACD,KAAK,GAAGJ,IAAI;IACjB,IAAI,CAACK,QAAQ,GAAGJ,OAAO;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIK,KAAKA,CAAA,EAAG;IACR,OAAO,IAAI,CAACT,MAAM;EACtB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIG,IAAIA,CAAA,EAAG;IACP,IAAI,IAAI,CAACE,iBAAiB,EAAE;MACxB,OAAO,IAAI,CAACA,iBAAiB;IACjC;IACA,IAAI,CAACA,iBAAiB,GAAG,IAAI,CAACE,KAAK,CAAC,CAAC;IACrC,IAAI,CAACA,KAAK,GAAG,IAAI;IACjB,OAAO,IAAI,CAACF,iBAAiB;EACjC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIK,KAAKA,CAAA,EAAG;IACR,OAAO,IAAI,CAACR,KAAK,KAAK,CAAC;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIS,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACT,KAAK;EACrB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIU,QAAQA,CAAA,EAAG;IACX,OAAO,IAAI,CAACX,SAAS;EACzB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIY,UAAUA,CAAA,EAAG;IACT,IAAI,IAAI,CAACP,oBAAoB,EAAE;MAC3B,OAAO,IAAI,CAACA,oBAAoB;IACpC;IACA,IAAI,CAACA,oBAAoB,GAAG,IAAI,CAACE,QAAQ,CAAC,CAAC;IAC3C,IAAI,CAACA,QAAQ,GAAG,IAAI;IACpB,OAAO,IAAI,CAACF,oBAAoB;EACpC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIQ,OAAOA,CAACC,QAAQ,EAAEC,OAAO,EAAE;IACvB,CAAC,CAAC,EAAEpB,UAAU,CAACqB,gBAAgB,EAAE,UAAU,EAAEF,QAAQ,CAAC;IACtD,KAAK,MAAMG,GAAG,IAAI,IAAI,CAACf,IAAI,EAAE;MACzBY,QAAQ,CAACI,IAAI,CAACH,OAAO,EAAEE,GAAG,CAAC;IAC/B;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,OAAOA,CAACC,KAAK,EAAE;IACX;IACA;IACA,IAAI,IAAI,KAAKA,KAAK,EAAE;MAChB,OAAO,IAAI;IACf;IACA,IAAI,EAAEA,KAAK,YAAY1B,aAAa,CAAC,EAAE;MACnC,OAAO,KAAK;IAChB;IACA,IAAI,IAAI,CAACO,KAAK,KAAKmB,KAAK,CAACnB,KAAK,EAAE;MAC5B,OAAO,KAAK;IAChB;IACA,IAAI,CAAC,IAAI,CAACF,MAAM,CAACoB,OAAO,CAACC,KAAK,CAACrB,MAAM,CAAC,EAAE;MACpC,OAAO,KAAK;IAChB;IACA,IAAI,IAAI,CAACK,iBAAiB,IAAI,CAAC,IAAI,CAACC,oBAAoB,EAAE;MACtD;MACA,OAAQ,CAAC,CAAC,EAAER,MAAM,CAACwB,YAAY,EAAE,IAAI,CAACnB,IAAI,EAAEkB,KAAK,CAAClB,IAAI,CAAC,IACnD,CAAC,CAAC,EAAEL,MAAM,CAACwB,YAAY,EAAE,IAAI,CAACT,UAAU,CAAC,CAAC,EAAEQ,KAAK,CAACR,UAAU,CAAC,CAAC,CAAC;IACvE;IACA;IACA,OAAQ,CAAC,CAAC,EAAEf,MAAM,CAACwB,YAAY,EAAE,IAAI,CAACT,UAAU,CAAC,CAAC,EAAEQ,KAAK,CAACR,UAAU,CAAC,CAAC,CAAC,IACnE,CAAC,CAAC,EAAEf,MAAM,CAACwB,YAAY,EAAE,IAAI,CAACnB,IAAI,EAAEkB,KAAK,CAAClB,IAAI,CAAC;EACvD;AACJ;AACAV,OAAO,CAACE,aAAa,GAAGA,aAAa","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}