{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathTemplate = void 0;\nclass PathTemplate {\n  /**\n   * @param {String} data the of the template\n   *\n   * @constructor\n   */\n  constructor(data) {\n    this.bindings = {};\n    this.data = data;\n    this.segments = this.parsePathTemplate(data);\n    this.size = this.segments.length;\n  }\n  /**\n   * Matches a fully-qualified path template string.\n   *\n   * @param {String} path a fully-qualified path template string\n   * @return {Object} contains const names matched to binding values\n   * @throws {TypeError} if path can't be matched to this template\n   */\n  match(path) {\n    let pathSegments = path.split('/');\n    const bindings = {};\n    if (pathSegments.length !== this.segments.length) {\n      // if the path contains a wildcard, then the length may differ by 1.\n      if (!this.data.includes('**')) {\n        throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same.`);\n      } else if (pathSegments.length !== this.segments.length + 1) {\n        throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same with one wildcard.`);\n      }\n    }\n    for (let index = 0; index < this.segments.length && pathSegments.length > 0; index++) {\n      if (this.segments[index] !== pathSegments[0]) {\n        if (!this.segments[index].includes('*')) {\n          throw new TypeError(`segment does not match, ${this.segments[index]} and  ${pathSegments[index]}.`);\n        } else {\n          let segment = this.segments[index];\n          const matches = segment.match(/\\{[$0-9a-zA-Z_]+=.*?\\}/g);\n          if (!matches) {\n            throw new Error(`Error processing path template segment ${segment}`);\n          }\n          const variables = matches.map(str => str.replace(/^\\{/, '').replace(/=.*/, ''));\n          if (segment.includes('**')) {\n            bindings[variables[0]] = pathSegments[0] + '/' + pathSegments[1];\n            pathSegments = pathSegments.slice(2);\n          } else {\n            // atomic resource\n            if (variables.length === 1) {\n              bindings[variables[0]] = pathSegments[0];\n            } else {\n              // non-slash resource\n              // segment: {blurb_id=*}.{legacy_user=*} to match pathSegments: ['bar.user2']\n              // split the match pathSegments[0] -> value: ['bar', 'user2']\n              // compare the length of two arrays, and compare array items\n              const value = pathSegments[0].split(/[-_.~]/);\n              if (value.length !== variables.length) {\n                throw new Error(`segment ${segment} does not match ${pathSegments[0]}`);\n              }\n              for (const v of variables) {\n                bindings[v] = value[0];\n                segment = segment.replace(`{${v}=*}`, `${value[0]}`);\n                value.shift();\n              }\n              // segment: {blurb_id=*}.{legacy_user=*} matching pathSegments: ['bar~user2'] should fail\n              if (segment !== pathSegments[0]) {\n                throw new TypeError(`non slash resource pattern ${this.segments[index]} and ${pathSegments[0]} should have same separator`);\n              }\n            }\n            pathSegments.shift();\n          }\n        }\n      } else {\n        pathSegments.shift();\n      }\n    }\n    return bindings;\n  }\n  /**\n   * Renders a path template using the provided bindings.\n   *\n   * @param {Object} bindings a mapping of const names to binding strings\n   * @return {String} a rendered representation of the path template\n   * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n   *   parsed\n   */\n  render(bindings) {\n    if (Object.keys(bindings).length !== Object.keys(this.bindings).length) {\n      throw new TypeError(`The number of variables ${Object.keys(bindings).length} does not match the number of needed variables ${Object.keys(this.bindings).length}`);\n    }\n    let path = this.inspect();\n    for (const key of Object.keys(bindings)) {\n      const b = bindings[key].toString();\n      if (!this.bindings[key]) {\n        throw new TypeError(`render fails for not matching ${bindings[key]}`);\n      }\n      const variable = this.bindings[key];\n      if (variable === '*') {\n        if (!b.match(/[^/{}]+/)) {\n          throw new TypeError(`render fails for not matching ${b}`);\n        }\n        path = path.replace(`{${key}=*}`, `${b}`);\n      } else if (variable === '**') {\n        if (!b.match(/[^{}]+/)) {\n          throw new TypeError(`render fails for not matching ${b}`);\n        }\n        path = path.replace(`{${key}=**}`, `${b}`);\n      }\n    }\n    return path;\n  }\n  /**\n   * Renders the path template.\n   *\n   * @return {string} contains const names matched to binding values\n   */\n  inspect() {\n    return this.segments.join('/');\n  }\n  /**\n   * Parse the path template.\n   *\n   * @return {string[]} return segments of the input path.\n   * For example: 'buckets/{hello}'' will give back ['buckets', {hello=*}]\n   */\n  parsePathTemplate(data) {\n    const pathSegments = splitPathTemplate(data);\n    let index = 0;\n    let wildCardCount = 0;\n    const segments = [];\n    let matches;\n    pathSegments.forEach(segment => {\n      // * or ** -> segments.push('{$0=*}');\n      //         -> bindings['$0'] = '*'\n      if (segment === '*' || segment === '**') {\n        this.bindings[`$${index}`] = segment;\n        segments.push(`{$${index}=${segment}}`);\n        index = index + 1;\n        if (segment === '**') {\n          ++wildCardCount;\n        }\n      } else if (matches = segment.match(/\\{[0-9a-zA-Z-.~_]+(?:=.*?)?\\}/g)) {\n        for (const subsegment of matches) {\n          const pairMatch = subsegment.match(/^\\{([0-9a-zA-Z-.~_]+)(?:=(.*?))?\\}$/);\n          if (!pairMatch) {\n            throw new Error(`Cannot process path template segment ${subsegment}`);\n          }\n          const key = pairMatch[1];\n          let value = pairMatch[2];\n          if (!value) {\n            value = '*';\n            segment = segment.replace(key, key + '=*');\n            this.bindings[key] = value;\n          } else if (value === '*') {\n            this.bindings[key] = value;\n          } else if (value === '**') {\n            ++wildCardCount;\n            this.bindings[key] = value;\n          }\n        }\n        segments.push(segment);\n      } else if (segment.match(/[0-9a-zA-Z-.~_]+/)) {\n        segments.push(segment);\n      }\n    });\n    if (wildCardCount > 1) {\n      throw new TypeError('Can not have more than one wildcard.');\n    }\n    return segments;\n  }\n}\nexports.PathTemplate = PathTemplate;\n/**\n * Split the path template by `/`.\n * It can not be simply splitted by `/` because there might be `/` in the segments.\n * For example: 'a/b/{a=hello/world}' we do not want to break the brackets pair\n * so above path will be splitted as ['a', 'b', '{a=hello/world}']\n */\nfunction splitPathTemplate(data) {\n  let left = 0;\n  let right = 0;\n  let bracketCount = 0;\n  const segments = [];\n  while (right >= left && right < data.length) {\n    if (data.charAt(right) === '{') {\n      bracketCount = bracketCount + 1;\n    } else if (data.charAt(right) === '}') {\n      bracketCount = bracketCount - 1;\n    } else if (data.charAt(right) === '/') {\n      if (right === data.length - 1) {\n        throw new TypeError('Invalid path, it can not be ended by /');\n      }\n      if (bracketCount === 0) {\n        // complete bracket, to avoid the case a/b/**/*/{a=hello/world}\n        segments.push(data.substring(left, right));\n        left = right + 1;\n      }\n    }\n    if (right === data.length - 1) {\n      if (bracketCount !== 0) {\n        throw new TypeError('Brackets are invalid.');\n      }\n      segments.push(data.substring(left));\n    }\n    right = right + 1;\n  }\n  return segments;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","PathTemplate","constructor","data","bindings","segments","parsePathTemplate","size","length","match","path","pathSegments","split","includes","TypeError","index","segment","matches","Error","variables","map","str","replace","slice","v","shift","render","keys","inspect","key","b","toString","variable","join","splitPathTemplate","wildCardCount","forEach","push","subsegment","pairMatch","left","right","bracketCount","charAt","substring"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/google-gax/build/src/pathTemplate.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathTemplate = void 0;\nclass PathTemplate {\n    /**\n     * @param {String} data the of the template\n     *\n     * @constructor\n     */\n    constructor(data) {\n        this.bindings = {};\n        this.data = data;\n        this.segments = this.parsePathTemplate(data);\n        this.size = this.segments.length;\n    }\n    /**\n     * Matches a fully-qualified path template string.\n     *\n     * @param {String} path a fully-qualified path template string\n     * @return {Object} contains const names matched to binding values\n     * @throws {TypeError} if path can't be matched to this template\n     */\n    match(path) {\n        let pathSegments = path.split('/');\n        const bindings = {};\n        if (pathSegments.length !== this.segments.length) {\n            // if the path contains a wildcard, then the length may differ by 1.\n            if (!this.data.includes('**')) {\n                throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same.`);\n            }\n            else if (pathSegments.length !== this.segments.length + 1) {\n                throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same with one wildcard.`);\n            }\n        }\n        for (let index = 0; index < this.segments.length && pathSegments.length > 0; index++) {\n            if (this.segments[index] !== pathSegments[0]) {\n                if (!this.segments[index].includes('*')) {\n                    throw new TypeError(`segment does not match, ${this.segments[index]} and  ${pathSegments[index]}.`);\n                }\n                else {\n                    let segment = this.segments[index];\n                    const matches = segment.match(/\\{[$0-9a-zA-Z_]+=.*?\\}/g);\n                    if (!matches) {\n                        throw new Error(`Error processing path template segment ${segment}`);\n                    }\n                    const variables = matches.map(str => str.replace(/^\\{/, '').replace(/=.*/, ''));\n                    if (segment.includes('**')) {\n                        bindings[variables[0]] = pathSegments[0] + '/' + pathSegments[1];\n                        pathSegments = pathSegments.slice(2);\n                    }\n                    else {\n                        // atomic resource\n                        if (variables.length === 1) {\n                            bindings[variables[0]] = pathSegments[0];\n                        }\n                        else {\n                            // non-slash resource\n                            // segment: {blurb_id=*}.{legacy_user=*} to match pathSegments: ['bar.user2']\n                            // split the match pathSegments[0] -> value: ['bar', 'user2']\n                            // compare the length of two arrays, and compare array items\n                            const value = pathSegments[0].split(/[-_.~]/);\n                            if (value.length !== variables.length) {\n                                throw new Error(`segment ${segment} does not match ${pathSegments[0]}`);\n                            }\n                            for (const v of variables) {\n                                bindings[v] = value[0];\n                                segment = segment.replace(`{${v}=*}`, `${value[0]}`);\n                                value.shift();\n                            }\n                            // segment: {blurb_id=*}.{legacy_user=*} matching pathSegments: ['bar~user2'] should fail\n                            if (segment !== pathSegments[0]) {\n                                throw new TypeError(`non slash resource pattern ${this.segments[index]} and ${pathSegments[0]} should have same separator`);\n                            }\n                        }\n                        pathSegments.shift();\n                    }\n                }\n            }\n            else {\n                pathSegments.shift();\n            }\n        }\n        return bindings;\n    }\n    /**\n     * Renders a path template using the provided bindings.\n     *\n     * @param {Object} bindings a mapping of const names to binding strings\n     * @return {String} a rendered representation of the path template\n     * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n     *   parsed\n     */\n    render(bindings) {\n        if (Object.keys(bindings).length !== Object.keys(this.bindings).length) {\n            throw new TypeError(`The number of variables ${Object.keys(bindings).length} does not match the number of needed variables ${Object.keys(this.bindings).length}`);\n        }\n        let path = this.inspect();\n        for (const key of Object.keys(bindings)) {\n            const b = bindings[key].toString();\n            if (!this.bindings[key]) {\n                throw new TypeError(`render fails for not matching ${bindings[key]}`);\n            }\n            const variable = this.bindings[key];\n            if (variable === '*') {\n                if (!b.match(/[^/{}]+/)) {\n                    throw new TypeError(`render fails for not matching ${b}`);\n                }\n                path = path.replace(`{${key}=*}`, `${b}`);\n            }\n            else if (variable === '**') {\n                if (!b.match(/[^{}]+/)) {\n                    throw new TypeError(`render fails for not matching ${b}`);\n                }\n                path = path.replace(`{${key}=**}`, `${b}`);\n            }\n        }\n        return path;\n    }\n    /**\n     * Renders the path template.\n     *\n     * @return {string} contains const names matched to binding values\n     */\n    inspect() {\n        return this.segments.join('/');\n    }\n    /**\n     * Parse the path template.\n     *\n     * @return {string[]} return segments of the input path.\n     * For example: 'buckets/{hello}'' will give back ['buckets', {hello=*}]\n     */\n    parsePathTemplate(data) {\n        const pathSegments = splitPathTemplate(data);\n        let index = 0;\n        let wildCardCount = 0;\n        const segments = [];\n        let matches;\n        pathSegments.forEach(segment => {\n            // * or ** -> segments.push('{$0=*}');\n            //         -> bindings['$0'] = '*'\n            if (segment === '*' || segment === '**') {\n                this.bindings[`$${index}`] = segment;\n                segments.push(`{$${index}=${segment}}`);\n                index = index + 1;\n                if (segment === '**') {\n                    ++wildCardCount;\n                }\n            }\n            else if ((matches = segment.match(/\\{[0-9a-zA-Z-.~_]+(?:=.*?)?\\}/g))) {\n                for (const subsegment of matches) {\n                    const pairMatch = subsegment.match(/^\\{([0-9a-zA-Z-.~_]+)(?:=(.*?))?\\}$/);\n                    if (!pairMatch) {\n                        throw new Error(`Cannot process path template segment ${subsegment}`);\n                    }\n                    const key = pairMatch[1];\n                    let value = pairMatch[2];\n                    if (!value) {\n                        value = '*';\n                        segment = segment.replace(key, key + '=*');\n                        this.bindings[key] = value;\n                    }\n                    else if (value === '*') {\n                        this.bindings[key] = value;\n                    }\n                    else if (value === '**') {\n                        ++wildCardCount;\n                        this.bindings[key] = value;\n                    }\n                }\n                segments.push(segment);\n            }\n            else if (segment.match(/[0-9a-zA-Z-.~_]+/)) {\n                segments.push(segment);\n            }\n        });\n        if (wildCardCount > 1) {\n            throw new TypeError('Can not have more than one wildcard.');\n        }\n        return segments;\n    }\n}\nexports.PathTemplate = PathTemplate;\n/**\n * Split the path template by `/`.\n * It can not be simply splitted by `/` because there might be `/` in the segments.\n * For example: 'a/b/{a=hello/world}' we do not want to break the brackets pair\n * so above path will be splitted as ['a', 'b', '{a=hello/world}']\n */\nfunction splitPathTemplate(data) {\n    let left = 0;\n    let right = 0;\n    let bracketCount = 0;\n    const segments = [];\n    while (right >= left && right < data.length) {\n        if (data.charAt(right) === '{') {\n            bracketCount = bracketCount + 1;\n        }\n        else if (data.charAt(right) === '}') {\n            bracketCount = bracketCount - 1;\n        }\n        else if (data.charAt(right) === '/') {\n            if (right === data.length - 1) {\n                throw new TypeError('Invalid path, it can not be ended by /');\n            }\n            if (bracketCount === 0) {\n                // complete bracket, to avoid the case a/b/**/*/{a=hello/world}\n                segments.push(data.substring(left, right));\n                left = right + 1;\n            }\n        }\n        if (right === data.length - 1) {\n            if (bracketCount !== 0) {\n                throw new TypeError('Brackets are invalid.');\n            }\n            segments.push(data.substring(left));\n        }\n        right = right + 1;\n    }\n    return segments;\n}\n//# sourceMappingURL=pathTemplate.js.map"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,YAAY,GAAG,KAAK,CAAC;AAC7B,MAAMA,YAAY,CAAC;EACf;AACJ;AACA;AACA;AACA;EACIC,WAAWA,CAACC,IAAI,EAAE;IACd,IAAI,CAACC,QAAQ,GAAG,CAAC,CAAC;IAClB,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACE,QAAQ,GAAG,IAAI,CAACC,iBAAiB,CAACH,IAAI,CAAC;IAC5C,IAAI,CAACI,IAAI,GAAG,IAAI,CAACF,QAAQ,CAACG,MAAM;EACpC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,KAAKA,CAACC,IAAI,EAAE;IACR,IAAIC,YAAY,GAAGD,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC;IAClC,MAAMR,QAAQ,GAAG,CAAC,CAAC;IACnB,IAAIO,YAAY,CAACH,MAAM,KAAK,IAAI,CAACH,QAAQ,CAACG,MAAM,EAAE;MAC9C;MACA,IAAI,CAAC,IAAI,CAACL,IAAI,CAACU,QAAQ,CAAC,IAAI,CAAC,EAAE;QAC3B,MAAM,IAAIC,SAAS,CAAC,aAAaJ,IAAI,iCAAiC,IAAI,CAACP,IAAI,yCAAyC,CAAC;MAC7H,CAAC,MACI,IAAIQ,YAAY,CAACH,MAAM,KAAK,IAAI,CAACH,QAAQ,CAACG,MAAM,GAAG,CAAC,EAAE;QACvD,MAAM,IAAIM,SAAS,CAAC,aAAaJ,IAAI,iCAAiC,IAAI,CAACP,IAAI,2DAA2D,CAAC;MAC/I;IACJ;IACA,KAAK,IAAIY,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAACV,QAAQ,CAACG,MAAM,IAAIG,YAAY,CAACH,MAAM,GAAG,CAAC,EAAEO,KAAK,EAAE,EAAE;MAClF,IAAI,IAAI,CAACV,QAAQ,CAACU,KAAK,CAAC,KAAKJ,YAAY,CAAC,CAAC,CAAC,EAAE;QAC1C,IAAI,CAAC,IAAI,CAACN,QAAQ,CAACU,KAAK,CAAC,CAACF,QAAQ,CAAC,GAAG,CAAC,EAAE;UACrC,MAAM,IAAIC,SAAS,CAAC,2BAA2B,IAAI,CAACT,QAAQ,CAACU,KAAK,CAAC,SAASJ,YAAY,CAACI,KAAK,CAAC,GAAG,CAAC;QACvG,CAAC,MACI;UACD,IAAIC,OAAO,GAAG,IAAI,CAACX,QAAQ,CAACU,KAAK,CAAC;UAClC,MAAME,OAAO,GAAGD,OAAO,CAACP,KAAK,CAAC,yBAAyB,CAAC;UACxD,IAAI,CAACQ,OAAO,EAAE;YACV,MAAM,IAAIC,KAAK,CAAC,0CAA0CF,OAAO,EAAE,CAAC;UACxE;UACA,MAAMG,SAAS,GAAGF,OAAO,CAACG,GAAG,CAACC,GAAG,IAAIA,GAAG,CAACC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;UAC/E,IAAIN,OAAO,CAACH,QAAQ,CAAC,IAAI,CAAC,EAAE;YACxBT,QAAQ,CAACe,SAAS,CAAC,CAAC,CAAC,CAAC,GAAGR,YAAY,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGA,YAAY,CAAC,CAAC,CAAC;YAChEA,YAAY,GAAGA,YAAY,CAACY,KAAK,CAAC,CAAC,CAAC;UACxC,CAAC,MACI;YACD;YACA,IAAIJ,SAAS,CAACX,MAAM,KAAK,CAAC,EAAE;cACxBJ,QAAQ,CAACe,SAAS,CAAC,CAAC,CAAC,CAAC,GAAGR,YAAY,CAAC,CAAC,CAAC;YAC5C,CAAC,MACI;cACD;cACA;cACA;cACA;cACA,MAAMX,KAAK,GAAGW,YAAY,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,QAAQ,CAAC;cAC7C,IAAIZ,KAAK,CAACQ,MAAM,KAAKW,SAAS,CAACX,MAAM,EAAE;gBACnC,MAAM,IAAIU,KAAK,CAAC,WAAWF,OAAO,mBAAmBL,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC;cAC3E;cACA,KAAK,MAAMa,CAAC,IAAIL,SAAS,EAAE;gBACvBf,QAAQ,CAACoB,CAAC,CAAC,GAAGxB,KAAK,CAAC,CAAC,CAAC;gBACtBgB,OAAO,GAAGA,OAAO,CAACM,OAAO,CAAC,IAAIE,CAAC,KAAK,EAAE,GAAGxB,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;gBACpDA,KAAK,CAACyB,KAAK,CAAC,CAAC;cACjB;cACA;cACA,IAAIT,OAAO,KAAKL,YAAY,CAAC,CAAC,CAAC,EAAE;gBAC7B,MAAM,IAAIG,SAAS,CAAC,8BAA8B,IAAI,CAACT,QAAQ,CAACU,KAAK,CAAC,QAAQJ,YAAY,CAAC,CAAC,CAAC,6BAA6B,CAAC;cAC/H;YACJ;YACAA,YAAY,CAACc,KAAK,CAAC,CAAC;UACxB;QACJ;MACJ,CAAC,MACI;QACDd,YAAY,CAACc,KAAK,CAAC,CAAC;MACxB;IACJ;IACA,OAAOrB,QAAQ;EACnB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIsB,MAAMA,CAACtB,QAAQ,EAAE;IACb,IAAIP,MAAM,CAAC8B,IAAI,CAACvB,QAAQ,CAAC,CAACI,MAAM,KAAKX,MAAM,CAAC8B,IAAI,CAAC,IAAI,CAACvB,QAAQ,CAAC,CAACI,MAAM,EAAE;MACpE,MAAM,IAAIM,SAAS,CAAC,2BAA2BjB,MAAM,CAAC8B,IAAI,CAACvB,QAAQ,CAAC,CAACI,MAAM,kDAAkDX,MAAM,CAAC8B,IAAI,CAAC,IAAI,CAACvB,QAAQ,CAAC,CAACI,MAAM,EAAE,CAAC;IACrK;IACA,IAAIE,IAAI,GAAG,IAAI,CAACkB,OAAO,CAAC,CAAC;IACzB,KAAK,MAAMC,GAAG,IAAIhC,MAAM,CAAC8B,IAAI,CAACvB,QAAQ,CAAC,EAAE;MACrC,MAAM0B,CAAC,GAAG1B,QAAQ,CAACyB,GAAG,CAAC,CAACE,QAAQ,CAAC,CAAC;MAClC,IAAI,CAAC,IAAI,CAAC3B,QAAQ,CAACyB,GAAG,CAAC,EAAE;QACrB,MAAM,IAAIf,SAAS,CAAC,iCAAiCV,QAAQ,CAACyB,GAAG,CAAC,EAAE,CAAC;MACzE;MACA,MAAMG,QAAQ,GAAG,IAAI,CAAC5B,QAAQ,CAACyB,GAAG,CAAC;MACnC,IAAIG,QAAQ,KAAK,GAAG,EAAE;QAClB,IAAI,CAACF,CAAC,CAACrB,KAAK,CAAC,SAAS,CAAC,EAAE;UACrB,MAAM,IAAIK,SAAS,CAAC,iCAAiCgB,CAAC,EAAE,CAAC;QAC7D;QACApB,IAAI,GAAGA,IAAI,CAACY,OAAO,CAAC,IAAIO,GAAG,KAAK,EAAE,GAAGC,CAAC,EAAE,CAAC;MAC7C,CAAC,MACI,IAAIE,QAAQ,KAAK,IAAI,EAAE;QACxB,IAAI,CAACF,CAAC,CAACrB,KAAK,CAAC,QAAQ,CAAC,EAAE;UACpB,MAAM,IAAIK,SAAS,CAAC,iCAAiCgB,CAAC,EAAE,CAAC;QAC7D;QACApB,IAAI,GAAGA,IAAI,CAACY,OAAO,CAAC,IAAIO,GAAG,MAAM,EAAE,GAAGC,CAAC,EAAE,CAAC;MAC9C;IACJ;IACA,OAAOpB,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;EACIkB,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAACvB,QAAQ,CAAC4B,IAAI,CAAC,GAAG,CAAC;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI3B,iBAAiBA,CAACH,IAAI,EAAE;IACpB,MAAMQ,YAAY,GAAGuB,iBAAiB,CAAC/B,IAAI,CAAC;IAC5C,IAAIY,KAAK,GAAG,CAAC;IACb,IAAIoB,aAAa,GAAG,CAAC;IACrB,MAAM9B,QAAQ,GAAG,EAAE;IACnB,IAAIY,OAAO;IACXN,YAAY,CAACyB,OAAO,CAACpB,OAAO,IAAI;MAC5B;MACA;MACA,IAAIA,OAAO,KAAK,GAAG,IAAIA,OAAO,KAAK,IAAI,EAAE;QACrC,IAAI,CAACZ,QAAQ,CAAC,IAAIW,KAAK,EAAE,CAAC,GAAGC,OAAO;QACpCX,QAAQ,CAACgC,IAAI,CAAC,KAAKtB,KAAK,IAAIC,OAAO,GAAG,CAAC;QACvCD,KAAK,GAAGA,KAAK,GAAG,CAAC;QACjB,IAAIC,OAAO,KAAK,IAAI,EAAE;UAClB,EAAEmB,aAAa;QACnB;MACJ,CAAC,MACI,IAAKlB,OAAO,GAAGD,OAAO,CAACP,KAAK,CAAC,gCAAgC,CAAC,EAAG;QAClE,KAAK,MAAM6B,UAAU,IAAIrB,OAAO,EAAE;UAC9B,MAAMsB,SAAS,GAAGD,UAAU,CAAC7B,KAAK,CAAC,qCAAqC,CAAC;UACzE,IAAI,CAAC8B,SAAS,EAAE;YACZ,MAAM,IAAIrB,KAAK,CAAC,wCAAwCoB,UAAU,EAAE,CAAC;UACzE;UACA,MAAMT,GAAG,GAAGU,SAAS,CAAC,CAAC,CAAC;UACxB,IAAIvC,KAAK,GAAGuC,SAAS,CAAC,CAAC,CAAC;UACxB,IAAI,CAACvC,KAAK,EAAE;YACRA,KAAK,GAAG,GAAG;YACXgB,OAAO,GAAGA,OAAO,CAACM,OAAO,CAACO,GAAG,EAAEA,GAAG,GAAG,IAAI,CAAC;YAC1C,IAAI,CAACzB,QAAQ,CAACyB,GAAG,CAAC,GAAG7B,KAAK;UAC9B,CAAC,MACI,IAAIA,KAAK,KAAK,GAAG,EAAE;YACpB,IAAI,CAACI,QAAQ,CAACyB,GAAG,CAAC,GAAG7B,KAAK;UAC9B,CAAC,MACI,IAAIA,KAAK,KAAK,IAAI,EAAE;YACrB,EAAEmC,aAAa;YACf,IAAI,CAAC/B,QAAQ,CAACyB,GAAG,CAAC,GAAG7B,KAAK;UAC9B;QACJ;QACAK,QAAQ,CAACgC,IAAI,CAACrB,OAAO,CAAC;MAC1B,CAAC,MACI,IAAIA,OAAO,CAACP,KAAK,CAAC,kBAAkB,CAAC,EAAE;QACxCJ,QAAQ,CAACgC,IAAI,CAACrB,OAAO,CAAC;MAC1B;IACJ,CAAC,CAAC;IACF,IAAImB,aAAa,GAAG,CAAC,EAAE;MACnB,MAAM,IAAIrB,SAAS,CAAC,sCAAsC,CAAC;IAC/D;IACA,OAAOT,QAAQ;EACnB;AACJ;AACAN,OAAO,CAACE,YAAY,GAAGA,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAASiC,iBAAiBA,CAAC/B,IAAI,EAAE;EAC7B,IAAIqC,IAAI,GAAG,CAAC;EACZ,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,YAAY,GAAG,CAAC;EACpB,MAAMrC,QAAQ,GAAG,EAAE;EACnB,OAAOoC,KAAK,IAAID,IAAI,IAAIC,KAAK,GAAGtC,IAAI,CAACK,MAAM,EAAE;IACzC,IAAIL,IAAI,CAACwC,MAAM,CAACF,KAAK,CAAC,KAAK,GAAG,EAAE;MAC5BC,YAAY,GAAGA,YAAY,GAAG,CAAC;IACnC,CAAC,MACI,IAAIvC,IAAI,CAACwC,MAAM,CAACF,KAAK,CAAC,KAAK,GAAG,EAAE;MACjCC,YAAY,GAAGA,YAAY,GAAG,CAAC;IACnC,CAAC,MACI,IAAIvC,IAAI,CAACwC,MAAM,CAACF,KAAK,CAAC,KAAK,GAAG,EAAE;MACjC,IAAIA,KAAK,KAAKtC,IAAI,CAACK,MAAM,GAAG,CAAC,EAAE;QAC3B,MAAM,IAAIM,SAAS,CAAC,wCAAwC,CAAC;MACjE;MACA,IAAI4B,YAAY,KAAK,CAAC,EAAE;QACpB;QACArC,QAAQ,CAACgC,IAAI,CAAClC,IAAI,CAACyC,SAAS,CAACJ,IAAI,EAAEC,KAAK,CAAC,CAAC;QAC1CD,IAAI,GAAGC,KAAK,GAAG,CAAC;MACpB;IACJ;IACA,IAAIA,KAAK,KAAKtC,IAAI,CAACK,MAAM,GAAG,CAAC,EAAE;MAC3B,IAAIkC,YAAY,KAAK,CAAC,EAAE;QACpB,MAAM,IAAI5B,SAAS,CAAC,uBAAuB,CAAC;MAChD;MACAT,QAAQ,CAACgC,IAAI,CAAClC,IAAI,CAACyC,SAAS,CAACJ,IAAI,CAAC,CAAC;IACvC;IACAC,KAAK,GAAGA,KAAK,GAAG,CAAC;EACrB;EACA,OAAOpC,QAAQ;AACnB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}