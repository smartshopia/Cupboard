{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Method;\n\n// extends ReflectionObject\nvar ReflectionObject = require(\"./object\");\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\nvar util = require(\"./util\");\n\n/**\r\n * Constructs a new service method instance.\r\n * @classdesc Reflected service method.\r\n * @extends ReflectionObject\r\n * @constructor\r\n * @param {string} name Method name\r\n * @param {string|undefined} type Method type, usually `\"rpc\"`\r\n * @param {string} requestType Request message type\r\n * @param {string} responseType Response message type\r\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\r\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @param {string} [comment] The comment for this method\r\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\r\n */\nfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\n  /* istanbul ignore next */\n  if (util.isObject(requestStream)) {\n    options = requestStream;\n    requestStream = responseStream = undefined;\n  } else if (util.isObject(responseStream)) {\n    options = responseStream;\n    responseStream = undefined;\n  }\n\n  /* istanbul ignore if */\n  if (!(type === undefined || util.isString(type))) throw TypeError(\"type must be a string\");\n\n  /* istanbul ignore if */\n  if (!util.isString(requestType)) throw TypeError(\"requestType must be a string\");\n\n  /* istanbul ignore if */\n  if (!util.isString(responseType)) throw TypeError(\"responseType must be a string\");\n  ReflectionObject.call(this, name, options);\n\n  /**\r\n   * Method type.\r\n   * @type {string}\r\n   */\n  this.type = type || \"rpc\"; // toJSON\n\n  /**\r\n   * Request type.\r\n   * @type {string}\r\n   */\n  this.requestType = requestType; // toJSON, marker\n\n  /**\r\n   * Whether requests are streamed or not.\r\n   * @type {boolean|undefined}\r\n   */\n  this.requestStream = requestStream ? true : undefined; // toJSON\n\n  /**\r\n   * Response type.\r\n   * @type {string}\r\n   */\n  this.responseType = responseType; // toJSON\n\n  /**\r\n   * Whether responses are streamed or not.\r\n   * @type {boolean|undefined}\r\n   */\n  this.responseStream = responseStream ? true : undefined; // toJSON\n\n  /**\r\n   * Resolved request type.\r\n   * @type {Type|null}\r\n   */\n  this.resolvedRequestType = null;\n\n  /**\r\n   * Resolved response type.\r\n   * @type {Type|null}\r\n   */\n  this.resolvedResponseType = null;\n\n  /**\r\n   * Comment for this method\r\n   * @type {string|null}\r\n   */\n  this.comment = comment;\n\n  /**\r\n   * Options properly parsed into an object\r\n   */\n  this.parsedOptions = parsedOptions;\n}\n\n/**\r\n * Method descriptor.\r\n * @interface IMethod\r\n * @property {string} [type=\"rpc\"] Method type\r\n * @property {string} requestType Request type\r\n * @property {string} responseType Response type\r\n * @property {boolean} [requestStream=false] Whether requests are streamed\r\n * @property {boolean} [responseStream=false] Whether responses are streamed\r\n * @property {Object.<string,*>} [options] Method options\r\n * @property {string} comment Method comments\r\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\r\n */\n\n/**\r\n * Constructs a method from a method descriptor.\r\n * @param {string} name Method name\r\n * @param {IMethod} json Method descriptor\r\n * @returns {Method} Created method\r\n * @throws {TypeError} If arguments are invalid\r\n */\nMethod.fromJSON = function fromJSON(name, json) {\n  return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\n};\n\n/**\r\n * Converts this method to a method descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IMethod} Method descriptor\r\n */\nMethod.prototype.toJSON = function toJSON(toJSONOptions) {\n  var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n  return util.toObject([\"type\", this.type !== \"rpc\" && /* istanbul ignore next */this.type || undefined, \"requestType\", this.requestType, \"requestStream\", this.requestStream, \"responseType\", this.responseType, \"responseStream\", this.responseStream, \"options\", this.options, \"comment\", keepComments ? this.comment : undefined, \"parsedOptions\", this.parsedOptions]);\n};\n\n/**\r\n * @override\r\n */\nMethod.prototype.resolve = function resolve() {\n  /* istanbul ignore if */\n  if (this.resolved) return this;\n  this.resolvedRequestType = this.parent.lookupType(this.requestType);\n  this.resolvedResponseType = this.parent.lookupType(this.responseType);\n  return ReflectionObject.prototype.resolve.call(this);\n};","map":{"version":3,"names":["module","exports","Method","ReflectionObject","require","prototype","Object","create","constructor","className","util","name","type","requestType","responseType","requestStream","responseStream","options","comment","parsedOptions","isObject","undefined","isString","TypeError","call","resolvedRequestType","resolvedResponseType","fromJSON","json","toJSON","toJSONOptions","keepComments","Boolean","toObject","resolve","resolved","parent","lookupType"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/protobufjs/src/method.js"],"sourcesContent":["\"use strict\";\r\nmodule.exports = Method;\r\n\r\n// extends ReflectionObject\r\nvar ReflectionObject = require(\"./object\");\r\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\r\n\r\nvar util = require(\"./util\");\r\n\r\n/**\r\n * Constructs a new service method instance.\r\n * @classdesc Reflected service method.\r\n * @extends ReflectionObject\r\n * @constructor\r\n * @param {string} name Method name\r\n * @param {string|undefined} type Method type, usually `\"rpc\"`\r\n * @param {string} requestType Request message type\r\n * @param {string} responseType Response message type\r\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\r\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @param {string} [comment] The comment for this method\r\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\r\n */\r\nfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\r\n\r\n    /* istanbul ignore next */\r\n    if (util.isObject(requestStream)) {\r\n        options = requestStream;\r\n        requestStream = responseStream = undefined;\r\n    } else if (util.isObject(responseStream)) {\r\n        options = responseStream;\r\n        responseStream = undefined;\r\n    }\r\n\r\n    /* istanbul ignore if */\r\n    if (!(type === undefined || util.isString(type)))\r\n        throw TypeError(\"type must be a string\");\r\n\r\n    /* istanbul ignore if */\r\n    if (!util.isString(requestType))\r\n        throw TypeError(\"requestType must be a string\");\r\n\r\n    /* istanbul ignore if */\r\n    if (!util.isString(responseType))\r\n        throw TypeError(\"responseType must be a string\");\r\n\r\n    ReflectionObject.call(this, name, options);\r\n\r\n    /**\r\n     * Method type.\r\n     * @type {string}\r\n     */\r\n    this.type = type || \"rpc\"; // toJSON\r\n\r\n    /**\r\n     * Request type.\r\n     * @type {string}\r\n     */\r\n    this.requestType = requestType; // toJSON, marker\r\n\r\n    /**\r\n     * Whether requests are streamed or not.\r\n     * @type {boolean|undefined}\r\n     */\r\n    this.requestStream = requestStream ? true : undefined; // toJSON\r\n\r\n    /**\r\n     * Response type.\r\n     * @type {string}\r\n     */\r\n    this.responseType = responseType; // toJSON\r\n\r\n    /**\r\n     * Whether responses are streamed or not.\r\n     * @type {boolean|undefined}\r\n     */\r\n    this.responseStream = responseStream ? true : undefined; // toJSON\r\n\r\n    /**\r\n     * Resolved request type.\r\n     * @type {Type|null}\r\n     */\r\n    this.resolvedRequestType = null;\r\n\r\n    /**\r\n     * Resolved response type.\r\n     * @type {Type|null}\r\n     */\r\n    this.resolvedResponseType = null;\r\n\r\n    /**\r\n     * Comment for this method\r\n     * @type {string|null}\r\n     */\r\n    this.comment = comment;\r\n\r\n    /**\r\n     * Options properly parsed into an object\r\n     */\r\n    this.parsedOptions = parsedOptions;\r\n}\r\n\r\n/**\r\n * Method descriptor.\r\n * @interface IMethod\r\n * @property {string} [type=\"rpc\"] Method type\r\n * @property {string} requestType Request type\r\n * @property {string} responseType Response type\r\n * @property {boolean} [requestStream=false] Whether requests are streamed\r\n * @property {boolean} [responseStream=false] Whether responses are streamed\r\n * @property {Object.<string,*>} [options] Method options\r\n * @property {string} comment Method comments\r\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\r\n */\r\n\r\n/**\r\n * Constructs a method from a method descriptor.\r\n * @param {string} name Method name\r\n * @param {IMethod} json Method descriptor\r\n * @returns {Method} Created method\r\n * @throws {TypeError} If arguments are invalid\r\n */\r\nMethod.fromJSON = function fromJSON(name, json) {\r\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\r\n};\r\n\r\n/**\r\n * Converts this method to a method descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IMethod} Method descriptor\r\n */\r\nMethod.prototype.toJSON = function toJSON(toJSONOptions) {\r\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\r\n    return util.toObject([\r\n        \"type\"           , this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\r\n        \"requestType\"    , this.requestType,\r\n        \"requestStream\"  , this.requestStream,\r\n        \"responseType\"   , this.responseType,\r\n        \"responseStream\" , this.responseStream,\r\n        \"options\"        , this.options,\r\n        \"comment\"        , keepComments ? this.comment : undefined,\r\n        \"parsedOptions\"  , this.parsedOptions,\r\n    ]);\r\n};\r\n\r\n/**\r\n * @override\r\n */\r\nMethod.prototype.resolve = function resolve() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.resolved)\r\n        return this;\r\n\r\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\r\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\r\n\r\n    return ReflectionObject.prototype.resolve.call(this);\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}