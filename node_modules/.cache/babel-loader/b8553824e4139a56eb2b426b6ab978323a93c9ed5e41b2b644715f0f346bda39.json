{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Query = void 0;\nconst stream_1 = require(\"stream\");\nconst query_util_1 = require(\"./query-util\");\nconst index_1 = require(\"../index\");\nconst field_order_1 = require(\"./field-order\");\nconst field_filter_internal_1 = require(\"./field-filter-internal\");\nconst composite_filter_internal_1 = require(\"./composite-filter-internal\");\nconst constants_1 = require(\"./constants\");\nconst vector_query_options_1 = require(\"./vector-query-options\");\nconst document_reference_1 = require(\"./document-reference\");\nconst query_snapshot_1 = require(\"./query-snapshot\");\nconst serializer_1 = require(\"../serializer\");\nconst query_profile_1 = require(\"../query-profile\");\nconst filter_1 = require(\"../filter\");\nconst path_1 = require(\"../path\");\nconst helpers_1 = require(\"./helpers\");\nconst validate_1 = require(\"../validate\");\nconst types_1 = require(\"./types\");\nconst aggregate_query_1 = require(\"./aggregate-query\");\nconst vector_query_1 = require(\"./vector-query\");\nconst order_1 = require(\"../order\");\nconst types_2 = require(\"../types\");\n/**\n * A Query refers to a query which you can read or stream from. You can also\n * construct refined Query objects by adding filters and ordering.\n *\n * @class Query\n */\nclass Query {\n  /**\n   * @internal\n   * @private\n   *\n   * @param _firestore The Firestore Database client.\n   * @param _queryOptions Options that define the query.\n   */\n  constructor(\n  /**\n   * @internal\n   * @private\n   **/\n  _firestore,\n  /**\n   * @internal\n   * @private\n   **/\n  _queryOptions) {\n    this._firestore = _firestore;\n    this._queryOptions = _queryOptions;\n    this._serializer = new serializer_1.Serializer(_firestore);\n    this._allowUndefined = !!this._firestore._settings.ignoreUndefinedProperties;\n    this._queryUtil = new query_util_1.QueryUtil(_firestore, _queryOptions, this._serializer);\n  }\n  /**\n   * Extracts field values from the DocumentSnapshot based on the provided\n   * field order.\n   *\n   * @private\n   * @internal\n   * @param documentSnapshot The document to extract the fields from.\n   * @param fieldOrders The field order that defines what fields we should\n   * extract.\n   * @return {Array.<*>} The field values to use.\n   */\n  static _extractFieldValues(documentSnapshot, fieldOrders) {\n    const fieldValues = [];\n    for (const fieldOrder of fieldOrders) {\n      if (index_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n        fieldValues.push(documentSnapshot.ref);\n      } else {\n        const fieldValue = documentSnapshot.get(fieldOrder.field);\n        if (fieldValue === undefined) {\n          throw new Error(`Field \"${fieldOrder.field}\" is missing in the provided DocumentSnapshot. ` + 'Please provide a document that contains values for all specified ' + 'orderBy() and where() constraints.');\n        } else {\n          fieldValues.push(fieldValue);\n        }\n      }\n    }\n    return fieldValues;\n  }\n  /**\n   * The [Firestore]{@link Firestore} instance for the Firestore\n   * database (useful for performing transactions, etc.).\n   *\n   * @type {Firestore}\n   * @name Query#firestore\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   let firestore = documentReference.firestore;\n   *   console.log(`Root location for document is ${firestore.formattedName}`);\n   * });\n   * ```\n   */\n  get firestore() {\n    return this._firestore;\n  }\n  where(fieldPathOrFilter, opStr, value) {\n    let filter;\n    if (fieldPathOrFilter instanceof index_1.Filter) {\n      filter = fieldPathOrFilter;\n    } else {\n      filter = index_1.Filter.where(fieldPathOrFilter, opStr, value);\n    }\n    if (this._queryOptions.startAt || this._queryOptions.endAt) {\n      throw new Error('Cannot specify a where() filter after calling startAt(), ' + 'startAfter(), endBefore() or endAt().');\n    }\n    const parsedFilter = this._parseFilter(filter);\n    if (parsedFilter.getFilters().length === 0) {\n      // Return the existing query if not adding any more filters (e.g. an empty composite filter).\n      return this;\n    }\n    const options = this._queryOptions.with({\n      filters: this._queryOptions.filters.concat(parsedFilter)\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * @internal\n   * @private\n   */\n  _parseFilter(filter) {\n    if (filter instanceof filter_1.UnaryFilter) {\n      return this._parseFieldFilter(filter);\n    }\n    return this._parseCompositeFilter(filter);\n  }\n  /**\n   * @internal\n   * @private\n   */\n  _parseFieldFilter(fieldFilterData) {\n    let value = fieldFilterData._getValue();\n    let operator = fieldFilterData._getOperator();\n    const fieldPath = fieldFilterData._getField();\n    (0, path_1.validateFieldPath)('fieldPath', fieldPath);\n    operator = (0, helpers_1.validateQueryOperator)('opStr', operator, value);\n    (0, helpers_1.validateQueryValue)('value', value, this._allowUndefined);\n    const path = index_1.FieldPath.fromArgument(fieldPath);\n    if (index_1.FieldPath.documentId().isEqual(path)) {\n      if (operator === 'array-contains' || operator === 'array-contains-any') {\n        throw new Error(`Invalid Query. You can't perform '${operator}' ` + 'queries on FieldPath.documentId().');\n      } else if (operator === 'in' || operator === 'not-in') {\n        if (!Array.isArray(value) || value.length === 0) {\n          throw new Error(`Invalid Query. A non-empty array is required for '${operator}' filters.`);\n        }\n        value = value.map(el => this.validateReference(el));\n      } else {\n        value = this.validateReference(value);\n      }\n    }\n    return new field_filter_internal_1.FieldFilterInternal(this._serializer, path, constants_1.comparisonOperators[operator], value);\n  }\n  /**\n   * @internal\n   * @private\n   */\n  _parseCompositeFilter(compositeFilterData) {\n    const parsedFilters = compositeFilterData._getFilters().map(filter => this._parseFilter(filter)).filter(parsedFilter => parsedFilter.getFilters().length > 0);\n    // For composite filters containing 1 filter, return the only filter.\n    // For example: AND(FieldFilter1) == FieldFilter1\n    if (parsedFilters.length === 1) {\n      return parsedFilters[0];\n    }\n    return new composite_filter_internal_1.CompositeFilterInternal(parsedFilters, compositeFilterData._getOperator() === 'AND' ? 'AND' : 'OR');\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} instance that applies a\n   * field mask to the result and returns only the specified subset of fields.\n   * You can specify a list of field paths to return, or use an empty list to\n   * only return the references of matching documents.\n   *\n   * Queries that contain field masks cannot be listened to via `onSnapshot()`\n   * listeners.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the field mask.\n   *\n   * @param {...(string|FieldPath)} fieldPaths The field paths to return.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   * let documentRef = collectionRef.doc('doc');\n   *\n   * return documentRef.set({x:10, y:5}).then(() => {\n   *   return collectionRef.where('x', '>', 5).select('y').get();\n   * }).then((res) => {\n   *   console.log(`y is ${res.docs[0].get('y')}.`);\n   * });\n   * ```\n   */\n  select(...fieldPaths) {\n    const fields = [];\n    if (fieldPaths.length === 0) {\n      fields.push({\n        fieldPath: index_1.FieldPath.documentId().formattedName\n      });\n    } else {\n      for (let i = 0; i < fieldPaths.length; ++i) {\n        (0, path_1.validateFieldPath)(i, fieldPaths[i]);\n        fields.push({\n          fieldPath: index_1.FieldPath.fromArgument(fieldPaths[i]).formattedName\n        });\n      }\n    }\n    // By specifying a field mask, the query result no longer conforms to type\n    // `T`. We there return `Query<DocumentData>`;\n    const options = this._queryOptions.with({\n      projection: {\n        fields\n      }\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that's additionally sorted\n   * by the specified field, optionally in descending order instead of\n   * ascending.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the field mask.\n   *\n   * @param {string|FieldPath} fieldPath The field to sort by.\n   * @param {string=} directionStr Optional direction to sort by ('asc' or\n   * 'desc'). If not specified, order will be ascending.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.orderBy('foo', 'desc').get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  orderBy(fieldPath, directionStr) {\n    (0, path_1.validateFieldPath)('fieldPath', fieldPath);\n    directionStr = (0, helpers_1.validateQueryOrder)('directionStr', directionStr);\n    if (this._queryOptions.startAt || this._queryOptions.endAt) {\n      throw new Error('Cannot specify an orderBy() constraint after calling ' + 'startAt(), startAfter(), endBefore() or endAt().');\n    }\n    const newOrder = new field_order_1.FieldOrder(index_1.FieldPath.fromArgument(fieldPath), constants_1.directionOperators[directionStr || 'asc']);\n    const options = this._queryOptions.with({\n      fieldOrders: this._queryOptions.fieldOrders.concat(newOrder)\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that only returns the\n   * first matching documents.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the limit.\n   *\n   * @param {number} limit The maximum number of items to return.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.limit(1).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  limit(limit) {\n    (0, validate_1.validateInteger)('limit', limit);\n    const options = this._queryOptions.with({\n      limit,\n      limitType: types_1.LimitType.First\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that only returns the\n   * last matching documents.\n   *\n   * You must specify at least one orderBy clause for limitToLast queries,\n   * otherwise an exception will be thrown during execution.\n   *\n   * Results for limitToLast queries cannot be streamed via the `stream()` API.\n   *\n   * @param limit The maximum number of items to return.\n   * @return The created Query.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.limitToLast(1).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Last matching document is ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  limitToLast(limit) {\n    (0, validate_1.validateInteger)('limitToLast', limit);\n    const options = this._queryOptions.with({\n      limit,\n      limitType: types_1.LimitType.Last\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Specifies the offset of the returned results.\n   *\n   * This function returns a new (immutable) instance of the\n   * [Query]{@link Query} (rather than modify the existing instance)\n   * to impose the offset.\n   *\n   * @param {number} offset The offset to apply to the Query results\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.limit(10).offset(20).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  offset(offset) {\n    (0, validate_1.validateInteger)('offset', offset);\n    const options = this._queryOptions.with({\n      offset\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Returns a query that counts the documents in the result set of this\n   * query.\n   *\n   * The returned query, when executed, counts the documents in the result set\n   * of this query without actually downloading the documents.\n   *\n   * Using the returned query to count the documents is efficient because only\n   * the final count, not the documents' data, is downloaded. The returned\n   * query can count the documents in cases where the result set is\n   * prohibitively large to download entirely (thousands of documents).\n   *\n   * @return a query that counts the documents in the result set of this\n   * query. The count can be retrieved from `snapshot.data().count`, where\n   * `snapshot` is the `AggregateQuerySnapshot` resulting from running the\n   * returned query.\n   */\n  count() {\n    return this.aggregate({\n      count: index_1.AggregateField.count()\n    });\n  }\n  /**\n   * Returns a query that can perform the given aggregations.\n   *\n   * The returned query, when executed, calculates the specified aggregations\n   * over the documents in the result set of this query without actually\n   * downloading the documents.\n   *\n   * Using the returned query to perform aggregations is efficient because only\n   * the final aggregation values, not the documents' data, is downloaded. The\n   * returned query can perform aggregations of the documents count the\n   * documents in cases where the result set is prohibitively large to download\n   * entirely (thousands of documents).\n   *\n   * @param aggregateSpec An `AggregateSpec` object that specifies the aggregates\n   * to perform over the result set. The AggregateSpec specifies aliases for each\n   * aggregate, which can be used to retrieve the aggregate result.\n   * @example\n   * ```typescript\n   * const aggregateQuery = col.aggregate(query, {\n   *   countOfDocs: count(),\n   *   totalHours: sum('hours'),\n   *   averageScore: average('score')\n   * });\n   *\n   * const aggregateSnapshot = await aggregateQuery.get();\n   * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n   * const totalHours: number = aggregateSnapshot.data().totalHours;\n   * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n   * ```\n   */\n  aggregate(aggregateSpec) {\n    return new aggregate_query_1.AggregateQuery(this, aggregateSpec);\n  }\n  /**\n   * Returns a query that can perform vector distance (similarity) search with given parameters.\n   *\n   * The returned query, when executed, performs a distance (similarity) search on the specified\n   * `vectorField` against the given `queryVector` and returns the top documents that are closest\n   * to the `queryVector`.\n   *\n   * Only documents whose `vectorField` field is a {@link VectorValue} of the same dimension as `queryVector`\n   * participate in the query, all other documents are ignored.\n   *\n   * @example\n   * ```\n   * // Returns the closest 10 documents whose Euclidean distance from their 'embedding' fields are closed to [41, 42].\n   * const vectorQuery = col.findNearest('embedding', [41, 42], {limit: 10, distanceMeasure: 'EUCLIDEAN'});\n   *\n   * const querySnapshot = await aggregateQuery.get();\n   * querySnapshot.forEach(...);\n   * ```\n   *\n   * @param vectorField - A string or {@link FieldPath} specifying the vector field to search on.\n   * @param queryVector - The {@link VectorValue} used to measure the distance from `vectorField` values in the documents.\n   * @param options - Options control the vector query. `limit` specifies the upper bound of documents to return, must\n   * be a positive integer with a maximum value of 1000. `distanceMeasure` specifies what type of distance is calculated\n   * when performing the query.\n   */\n  findNearest(vectorField, queryVector, options) {\n    (0, path_1.validateFieldPath)('vectorField', vectorField);\n    if (options.limit <= 0) {\n      throw (0, validate_1.invalidArgumentMessage)('options.limit', 'positive limit number');\n    }\n    if ((Array.isArray(queryVector) ? queryVector.length : queryVector.toArray().length) === 0) {\n      throw (0, validate_1.invalidArgumentMessage)('queryVector', 'vector size must be larger than 0');\n    }\n    return new vector_query_1.VectorQuery(this, vectorField, queryVector, new vector_query_options_1.VectorQueryOptions(options.limit, options.distanceMeasure));\n  }\n  /**\n   * Returns true if this `Query` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `Query` is equal to the provided value.\n   */\n  isEqual(other) {\n    if (this === other) {\n      return true;\n    }\n    return other instanceof Query && this._queryOptions.isEqual(other._queryOptions);\n  }\n  /**\n   * Returns the sorted array of inequality filter fields used in this query.\n   *\n   * @return An array of inequality filter fields sorted lexicographically by FieldPath.\n   */\n  getInequalityFilterFields() {\n    const inequalityFields = [];\n    for (const filter of this._queryOptions.filters) {\n      for (const subFilter of filter.getFlattenedFilters()) {\n        if (subFilter.isInequalityFilter()) {\n          inequalityFields.push(subFilter.field);\n        }\n      }\n    }\n    return inequalityFields.sort((a, b) => a.compareTo(b));\n  }\n  /**\n   * Computes the backend ordering semantics for DocumentSnapshot cursors.\n   *\n   * @private\n   * @internal\n   * @param cursorValuesOrDocumentSnapshot The snapshot of the document or the\n   * set of field values to use as the boundary.\n   * @returns The implicit ordering semantics.\n   */\n  createImplicitOrderBy(cursorValuesOrDocumentSnapshot) {\n    // Add an implicit orderBy if the only cursor value is a DocumentSnapshot.\n    if (cursorValuesOrDocumentSnapshot.length !== 1 || !(cursorValuesOrDocumentSnapshot[0] instanceof index_1.DocumentSnapshot)) {\n      return this._queryOptions.fieldOrders;\n    }\n    const fieldOrders = this._queryOptions.fieldOrders.slice();\n    const fieldsNormalized = new Set([...fieldOrders.map(item => item.field.toString())]);\n    /** The order of the implicit ordering always matches the last explicit order by. */\n    const lastDirection = fieldOrders.length === 0 ? constants_1.directionOperators.ASC : fieldOrders[fieldOrders.length - 1].direction;\n    /**\n     * Any inequality fields not explicitly ordered should be implicitly ordered in a\n     * lexicographical order. When there are multiple inequality filters on the same field, the\n     * field should be added only once.\n     * Note: getInequalityFilterFields function sorts the key field before\n     * other fields. However, we want the key field to be sorted last.\n     */\n    const inequalityFields = this.getInequalityFilterFields();\n    for (const field of inequalityFields) {\n      if (!fieldsNormalized.has(field.toString()) && !field.isEqual(index_1.FieldPath.documentId())) {\n        fieldOrders.push(new field_order_1.FieldOrder(field, lastDirection));\n        fieldsNormalized.add(field.toString());\n      }\n    }\n    // Add the document key field to the last if it is not explicitly ordered.\n    if (!fieldsNormalized.has(index_1.FieldPath.documentId().toString())) {\n      fieldOrders.push(new field_order_1.FieldOrder(index_1.FieldPath.documentId(), lastDirection));\n    }\n    return fieldOrders;\n  }\n  /**\n   * Builds a Firestore 'Position' proto message.\n   *\n   * @private\n   * @internal\n   * @param {Array.<FieldOrder>} fieldOrders The field orders to use for this\n   * cursor.\n   * @param {Array.<DocumentSnapshot|*>} cursorValuesOrDocumentSnapshot The\n   * snapshot of the document or the set of field values to use as the boundary.\n   * @param before Whether the query boundary lies just before or after the\n   * provided data.\n   * @returns {Object} The proto message.\n   */\n  createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) {\n    let fieldValues;\n    if (cursorValuesOrDocumentSnapshot.length === 1 && cursorValuesOrDocumentSnapshot[0] instanceof index_1.DocumentSnapshot) {\n      fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);\n    } else {\n      fieldValues = cursorValuesOrDocumentSnapshot;\n    }\n    if (fieldValues.length > fieldOrders.length) {\n      throw new Error('Too many cursor values specified. The specified ' + 'values must match the orderBy() constraints of the query.');\n    }\n    const options = {\n      values: [],\n      before\n    };\n    for (let i = 0; i < fieldValues.length; ++i) {\n      let fieldValue = fieldValues[i];\n      if (index_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) {\n        fieldValue = this.validateReference(fieldValue);\n      }\n      (0, helpers_1.validateQueryValue)(i, fieldValue, this._allowUndefined);\n      options.values.push(this._serializer.encodeValue(fieldValue));\n    }\n    return options;\n  }\n  /**\n   * Validates that a value used with FieldValue.documentId() is either a\n   * string or a DocumentReference that is part of the query`s result set.\n   * Throws a validation error or returns a DocumentReference that can\n   * directly be used in the Query.\n   *\n   * @param val The value to validate.\n   * @throws If the value cannot be used for this query.\n   * @return If valid, returns a DocumentReference that can be used with the\n   * query.\n   * @private\n   * @internal\n   */\n  validateReference(val) {\n    const basePath = this._queryOptions.allDescendants ? this._queryOptions.parentPath : this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n    let reference;\n    if (typeof val === 'string') {\n      const path = basePath.append(val);\n      if (this._queryOptions.allDescendants) {\n        if (!path.isDocument) {\n          throw new Error('When querying a collection group and ordering by ' + 'FieldPath.documentId(), the corresponding value must result in ' + `a valid document path, but '${val}' is not because it ` + 'contains an odd number of segments.');\n        }\n      } else if (val.indexOf('/') !== -1) {\n        throw new Error('When querying a collection and ordering by FieldPath.documentId(), ' + `the corresponding value must be a plain document ID, but '${val}' ` + 'contains a slash.');\n      }\n      reference = new document_reference_1.DocumentReference(this._firestore, basePath.append(val), this._queryOptions.converter);\n    } else if (val instanceof document_reference_1.DocumentReference) {\n      reference = val;\n      if (!basePath.isPrefixOf(reference._path)) {\n        throw new Error(`\"${reference.path}\" is not part of the query result set and ` + 'cannot be used as a query boundary.');\n      }\n    } else {\n      throw new Error('The corresponding value for FieldPath.documentId() must be a ' + `string or a DocumentReference, but was \"${val}\".`);\n    }\n    if (!this._queryOptions.allDescendants && reference._path.parent().compareTo(basePath) !== 0) {\n      throw new Error('Only a direct child can be used as a query boundary. ' + `Found: \"${reference.path}\".`);\n    }\n    return reference;\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that starts at the provided\n   * set of field values relative to the order of the query. The order of the\n   * provided values must match the order of the order by clauses of the query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should start at or the field values to\n   * start this query at, in order of the query's order by.\n   * @returns {Query} A query with the new starting point.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').startAt(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  startAt(...fieldValuesOrDocumentSnapshot) {\n    (0, validate_1.validateMinNumberOfArguments)('Query.startAt', fieldValuesOrDocumentSnapshot, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n    const options = this._queryOptions.with({\n      fieldOrders,\n      startAt\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that starts after the\n   * provided set of field values relative to the order of the query. The order\n   * of the provided values must match the order of the order by clauses of the\n   * query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should start after or the field values to\n   * start this query after, in order of the query's order by.\n   * @returns {Query} A query with the new starting point.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').startAfter(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  startAfter(...fieldValuesOrDocumentSnapshot) {\n    (0, validate_1.validateMinNumberOfArguments)('Query.startAfter', fieldValuesOrDocumentSnapshot, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n    const options = this._queryOptions.with({\n      fieldOrders,\n      startAt\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that ends before the set of\n   * field values relative to the order of the query. The order of the provided\n   * values must match the order of the order by clauses of the query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should end before or the field values to\n   * end this query before, in order of the query's order by.\n   * @returns {Query} A query with the new ending point.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').endBefore(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  endBefore(...fieldValuesOrDocumentSnapshot) {\n    (0, validate_1.validateMinNumberOfArguments)('Query.endBefore', fieldValuesOrDocumentSnapshot, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n    const options = this._queryOptions.with({\n      fieldOrders,\n      endAt\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that ends at the provided\n   * set of field values relative to the order of the query. The order of the\n   * provided values must match the order of the order by clauses of the query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should end at or the field values to end\n   * this query at, in order of the query's order by.\n   * @returns {Query} A query with the new ending point.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').endAt(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  endAt(...fieldValuesOrDocumentSnapshot) {\n    (0, validate_1.validateMinNumberOfArguments)('Query.endAt', fieldValuesOrDocumentSnapshot, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n    const options = this._queryOptions.with({\n      fieldOrders,\n      endAt\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Executes the query and returns the results as a\n   * [QuerySnapshot]{@link QuerySnapshot}.\n   *\n   * @returns {Promise.<QuerySnapshot>} A Promise that resolves with the results\n   * of the Query.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  async get() {\n    const {\n      result\n    } = await this._get();\n    return result;\n  }\n  /**\n   * Plans and optionally executes this query. Returns a Promise that will be\n   * resolved with the planner information, statistics from the query execution (if any),\n   * and the query results (if any).\n   *\n   * @return A Promise that will be resolved with the planner information, statistics\n   *  from the query execution (if any), and the query results (if any).\n   */\n  async explain(options) {\n    if (options === undefined) {\n      options = {};\n    }\n    const {\n      result,\n      explainMetrics\n    } = await this._getResponse(undefined, options);\n    if (!explainMetrics) {\n      throw new Error('No explain results');\n    }\n    return new query_profile_1.ExplainResults(explainMetrics, result || null);\n  }\n  /**\n   * Internal get() method that accepts an optional transaction options, and\n   * returns a query snapshot with transaction and explain metadata.\n   *\n   * @private\n   * @internal\n   * @param transactionOrReadTime A transaction ID, options to start a new\n   *  transaction, or timestamp to use as read time.\n   */\n  async _get(transactionOrReadTime) {\n    const result = await this._getResponse(transactionOrReadTime);\n    if (!result.result) {\n      throw new Error('No QuerySnapshot result');\n    }\n    return result;\n  }\n  _getResponse(transactionOrReadTime, explainOptions) {\n    return this._queryUtil._getResponse(this, transactionOrReadTime, true, explainOptions);\n  }\n  /**\n   * Executes the query and streams the results as\n   * [QueryDocumentSnapshots]{@link QueryDocumentSnapshot}.\n   *\n   * @returns {Stream.<QueryDocumentSnapshot>} A stream of\n   * QueryDocumentSnapshots.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * let count = 0;\n   *\n   * query.stream().on('data', (documentSnapshot) => {\n   *   console.log(`Found document with name '${documentSnapshot.id}'`);\n   *   ++count;\n   * }).on('end', () => {\n   *   console.log(`Total count is ${count}`);\n   * });\n   * ```\n   */\n  stream() {\n    return this._queryUtil.stream(this);\n  }\n  /**\n   * Executes the query and streams the results as the following object:\n   * {document?: DocumentSnapshot, metrics?: ExplainMetrics}\n   *\n   * The stream surfaces documents one at a time as they are received from the\n   * server, and at the end, it will surface the metrics associated with\n   * executing the query.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * let count = 0;\n   *\n   * query.explainStream({analyze: true}).on('data', (data) => {\n   *   if (data.document) {\n   *     // Use data.document which is a DocumentSnapshot instance.\n   *     console.log(`Found document with name '${data.document.id}'`);\n   *     ++count;\n   *   }\n   *   if (data.metrics) {\n   *     // Use data.metrics which is an ExplainMetrics instance.\n   *   }\n   * }).on('end', () => {\n   *   console.log(`Received ${count} documents.`);\n   * });\n   * ```\n   */\n  explainStream(explainOptions) {\n    if (explainOptions === undefined) {\n      explainOptions = {};\n    }\n    if (this._queryOptions.limitType === types_1.LimitType.Last) {\n      throw new Error('Query results for queries that include limitToLast() ' + 'constraints cannot be streamed. Use Query.explain() instead.');\n    }\n    const responseStream = this._stream(undefined, explainOptions);\n    const transform = new stream_1.Transform({\n      objectMode: true,\n      transform(chunk, encoding, callback) {\n        if (chunk.document || chunk.explainMetrics) {\n          callback(undefined, {\n            document: chunk.document,\n            metrics: chunk.explainMetrics\n          });\n        }\n      }\n    });\n    responseStream.pipe(transform);\n    responseStream.on('error', e => transform.destroy(e));\n    return transform;\n  }\n  /**\n   * Converts a QueryCursor to its proto representation.\n   *\n   * @param cursor The original cursor value\n   * @private\n   * @internal\n   */\n  toCursor(cursor) {\n    if (cursor) {\n      return cursor.before ? {\n        before: true,\n        values: cursor.values\n      } : {\n        values: cursor.values\n      };\n    }\n    return undefined;\n  }\n  /**\n   * Internal method for serializing a query to its RunQuery proto\n   * representation with an optional transaction id or read time.\n   *\n   * @param transactionOrReadTime A transaction ID, options to start a new\n   *  transaction, or timestamp to use as read time.\n   * @param explainOptions Options to use for explaining the query (if any).\n   * @private\n   * @internal\n   * @returns Serialized JSON for the query.\n   */\n  toProto(transactionOrReadTime, explainOptions) {\n    const projectId = this.firestore.projectId;\n    const databaseId = this.firestore.databaseId;\n    const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId, databaseId);\n    const structuredQuery = this.toStructuredQuery();\n    // For limitToLast queries, the structured query has to be translated to a version with\n    // reversed ordered, and flipped startAt/endAt to work properly.\n    if (this._queryOptions.limitType === types_1.LimitType.Last) {\n      if (!this._queryOptions.hasFieldOrders()) {\n        throw new Error('limitToLast() queries require specifying at least one orderBy() clause.');\n      }\n      structuredQuery.orderBy = this._queryOptions.fieldOrders.map(order => {\n        // Flip the orderBy directions since we want the last results\n        const dir = order.direction === 'DESCENDING' ? 'ASCENDING' : 'DESCENDING';\n        return new field_order_1.FieldOrder(order.field, dir).toProto();\n      });\n      // Swap the cursors to match the now-flipped query ordering.\n      structuredQuery.startAt = this._queryOptions.endAt ? this.toCursor({\n        values: this._queryOptions.endAt.values,\n        before: !this._queryOptions.endAt.before\n      }) : undefined;\n      structuredQuery.endAt = this._queryOptions.startAt ? this.toCursor({\n        values: this._queryOptions.startAt.values,\n        before: !this._queryOptions.startAt.before\n      }) : undefined;\n    }\n    const runQueryRequest = {\n      parent: parentPath.formattedName,\n      structuredQuery\n    };\n    if (transactionOrReadTime instanceof Uint8Array) {\n      runQueryRequest.transaction = transactionOrReadTime;\n    } else if (transactionOrReadTime instanceof index_1.Timestamp) {\n      runQueryRequest.readTime = transactionOrReadTime.toProto().timestampValue;\n    } else if (transactionOrReadTime) {\n      runQueryRequest.newTransaction = transactionOrReadTime;\n    }\n    if (explainOptions) {\n      runQueryRequest.explainOptions = explainOptions;\n    }\n    return runQueryRequest;\n  }\n  /**\n   * Converts current Query to an IBundledQuery.\n   *\n   * @private\n   * @internal\n   */\n  _toBundledQuery() {\n    const projectId = this.firestore.projectId;\n    const databaseId = this.firestore.databaseId;\n    const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId, databaseId);\n    const structuredQuery = this.toStructuredQuery();\n    const bundledQuery = {\n      parent: parentPath.formattedName,\n      structuredQuery\n    };\n    if (this._queryOptions.limitType === types_1.LimitType.First) {\n      bundledQuery.limitType = 'FIRST';\n    } else if (this._queryOptions.limitType === types_1.LimitType.Last) {\n      bundledQuery.limitType = 'LAST';\n    }\n    return bundledQuery;\n  }\n  toStructuredQuery() {\n    const structuredQuery = {\n      from: [{}]\n    };\n    if (this._queryOptions.allDescendants) {\n      structuredQuery.from[0].allDescendants = true;\n    }\n    // Kindless queries select all descendant documents, so we remove the\n    // collectionId field.\n    if (!this._queryOptions.kindless) {\n      structuredQuery.from[0].collectionId = this._queryOptions.collectionId;\n    }\n    if (this._queryOptions.filters.length >= 1) {\n      structuredQuery.where = new composite_filter_internal_1.CompositeFilterInternal(this._queryOptions.filters, 'AND').toProto();\n    }\n    if (this._queryOptions.hasFieldOrders()) {\n      structuredQuery.orderBy = this._queryOptions.fieldOrders.map(o => o.toProto());\n    }\n    structuredQuery.startAt = this.toCursor(this._queryOptions.startAt);\n    structuredQuery.endAt = this.toCursor(this._queryOptions.endAt);\n    if (this._queryOptions.limit) {\n      structuredQuery.limit = {\n        value: this._queryOptions.limit\n      };\n    }\n    structuredQuery.offset = this._queryOptions.offset;\n    structuredQuery.select = this._queryOptions.projection;\n    return structuredQuery;\n  }\n  /**\n   * @internal\n   * @private\n   * This method exists solely to maintain backward compatability.\n   */\n  _isPermanentRpcError(err, methodName) {\n    return this._queryUtil._isPermanentRpcError(err, methodName);\n  }\n  /**\n   * @internal\n   * @private\n   * This method exists solely to maintain backward compatability.\n   */\n  _hasRetryTimedOut(methodName, startTime) {\n    return this._queryUtil._hasRetryTimedOut(methodName, startTime);\n  }\n  /**\n   * Internal streaming method that accepts an optional transaction ID.\n   *\n   * BEWARE: If `transactionOrReadTime` is `ITransactionOptions`, then the first\n   * response in the stream will be a transaction response.\n   *\n   * @param transactionOrReadTime A transaction ID, options to start a new\n   *  transaction, or timestamp to use as read time.\n   * @param explainOptions Options to use for explaining the query (if any).\n   * @private\n   * @internal\n   * @returns A stream of document results, optionally preceded by a transaction response.\n   */\n  _stream(transactionOrReadTime, explainOptions) {\n    return this._queryUtil._stream(this, transactionOrReadTime, true, explainOptions);\n  }\n  /**\n   * Attaches a listener for QuerySnapshot events.\n   *\n   * @param {querySnapshotCallback} onNext A callback to be called every time\n   * a new [QuerySnapshot]{@link QuerySnapshot} is available.\n   * @param {errorCallback=} onError A callback to be called if the listen\n   * fails or is cancelled. No further callbacks will occur.\n   *\n   * @returns {function()} An unsubscribe function that can be called to cancel\n   * the snapshot listener.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * let unsubscribe = query.onSnapshot(querySnapshot => {\n   *   console.log(`Received query snapshot of size ${querySnapshot.size}`);\n   * }, err => {\n   *   console.log(`Encountered error: ${err}`);\n   * });\n   *\n   * // Remove this listener.\n   * unsubscribe();\n   * ```\n   */\n  onSnapshot(onNext, onError) {\n    (0, validate_1.validateFunction)('onNext', onNext);\n    (0, validate_1.validateFunction)('onError', onError, {\n      optional: true\n    });\n    const watch = new (require('../watch').QueryWatch)(this.firestore, this, this._queryOptions.converter);\n    return watch.onSnapshot((readTime, size, docs, changes) => {\n      onNext(new query_snapshot_1.QuerySnapshot(this, readTime, size, docs, changes));\n    }, onError || console.error);\n  }\n  /**\n   * Returns a function that can be used to sort QueryDocumentSnapshots\n   * according to the sort criteria of this query.\n   *\n   * @private\n   * @internal\n   */\n  comparator() {\n    return (doc1, doc2) => {\n      // Add implicit sorting by name, using the last specified direction.\n      const lastDirection = this._queryOptions.hasFieldOrders() ? this._queryOptions.fieldOrders[this._queryOptions.fieldOrders.length - 1].direction : 'ASCENDING';\n      const orderBys = this._queryOptions.fieldOrders.concat(new field_order_1.FieldOrder(index_1.FieldPath.documentId(), lastDirection));\n      for (const orderBy of orderBys) {\n        let comp;\n        if (index_1.FieldPath.documentId().isEqual(orderBy.field)) {\n          comp = doc1.ref._path.compareTo(doc2.ref._path);\n        } else {\n          const v1 = doc1.protoField(orderBy.field);\n          const v2 = doc2.protoField(orderBy.field);\n          if (v1 === undefined || v2 === undefined) {\n            throw new Error('Trying to compare documents on fields that ' + \"don't exist. Please include the fields you are ordering on \" + 'in your select() call.');\n          }\n          comp = (0, order_1.compare)(v1, v2);\n        }\n        if (comp !== 0) {\n          const direction = orderBy.direction === 'ASCENDING' ? 1 : -1;\n          return direction * comp;\n        }\n      }\n      return 0;\n    };\n  }\n  /**\n   * Applies a custom data converter to this Query, allowing you to use your\n   * own custom model objects with Firestore. When you call get() on the\n   * returned Query, the provided converter will convert between Firestore\n   * data of type `NewDbModelType` and your custom type `NewAppModelType`.\n   *\n   * Using the converter allows you to specify generic type arguments when\n   * storing and retrieving objects from Firestore.\n   *\n   * Passing in `null` as the converter parameter removes the current\n   * converter.\n   *\n   * @example\n   * ```\n   * class Post {\n   *   constructor(readonly title: string, readonly author: string) {}\n   *\n   *   toString(): string {\n   *     return this.title + ', by ' + this.author;\n   *   }\n   * }\n   *\n   * const postConverter = {\n   *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n   *     return {title: post.title, author: post.author};\n   *   },\n   *   fromFirestore(\n   *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\n   *   ): Post {\n   *     const data = snapshot.data();\n   *     return new Post(data.title, data.author);\n   *   }\n   * };\n   *\n   * const postSnap = await Firestore()\n   *   .collection('posts')\n   *   .withConverter(postConverter)\n   *   .doc().get();\n   * const post = postSnap.data();\n   * if (post !== undefined) {\n   *   post.title; // string\n   *   post.toString(); // Should be defined\n   *   post.someNonExistentProperty; // TS error\n   * }\n   *\n   * ```\n   * @param {FirestoreDataConverter | null} converter Converts objects to and\n   * from Firestore. Passing in `null` removes the current converter.\n   * @return A Query that uses the provided converter.\n   */\n  withConverter(converter) {\n    return new Query(this.firestore, this._queryOptions.withConverter(converter !== null && converter !== void 0 ? converter : (0, types_2.defaultConverter)()));\n  }\n  /**\n   * Construct the resulting snapshot for this query with given documents.\n   *\n   * @private\n   * @internal\n   */\n  _createSnapshot(readTime, size, docs, changes) {\n    return new query_snapshot_1.QuerySnapshot(this, readTime, size, docs, changes);\n  }\n}\nexports.Query = Query;","map":{"version":3,"names":["Object","defineProperty","exports","value","Query","stream_1","require","query_util_1","index_1","field_order_1","field_filter_internal_1","composite_filter_internal_1","constants_1","vector_query_options_1","document_reference_1","query_snapshot_1","serializer_1","query_profile_1","filter_1","path_1","helpers_1","validate_1","types_1","aggregate_query_1","vector_query_1","order_1","types_2","constructor","_firestore","_queryOptions","_serializer","Serializer","_allowUndefined","_settings","ignoreUndefinedProperties","_queryUtil","QueryUtil","_extractFieldValues","documentSnapshot","fieldOrders","fieldValues","fieldOrder","FieldPath","documentId","isEqual","field","push","ref","fieldValue","get","undefined","Error","firestore","where","fieldPathOrFilter","opStr","filter","Filter","startAt","endAt","parsedFilter","_parseFilter","getFilters","length","options","with","filters","concat","UnaryFilter","_parseFieldFilter","_parseCompositeFilter","fieldFilterData","_getValue","operator","_getOperator","fieldPath","_getField","validateFieldPath","validateQueryOperator","validateQueryValue","path","fromArgument","Array","isArray","map","el","validateReference","FieldFilterInternal","comparisonOperators","compositeFilterData","parsedFilters","_getFilters","CompositeFilterInternal","select","fieldPaths","fields","formattedName","i","projection","orderBy","directionStr","validateQueryOrder","newOrder","FieldOrder","directionOperators","limit","validateInteger","limitType","LimitType","First","limitToLast","Last","offset","count","aggregate","AggregateField","aggregateSpec","AggregateQuery","findNearest","vectorField","queryVector","invalidArgumentMessage","toArray","VectorQuery","VectorQueryOptions","distanceMeasure","other","getInequalityFilterFields","inequalityFields","subFilter","getFlattenedFilters","isInequalityFilter","sort","a","b","compareTo","createImplicitOrderBy","cursorValuesOrDocumentSnapshot","DocumentSnapshot","slice","fieldsNormalized","Set","item","toString","lastDirection","ASC","direction","has","add","createCursor","before","values","encodeValue","val","basePath","allDescendants","parentPath","append","collectionId","reference","isDocument","indexOf","DocumentReference","converter","isPrefixOf","_path","parent","fieldValuesOrDocumentSnapshot","validateMinNumberOfArguments","startAfter","endBefore","result","_get","explain","explainMetrics","_getResponse","ExplainResults","transactionOrReadTime","explainOptions","stream","explainStream","responseStream","_stream","transform","Transform","objectMode","chunk","encoding","callback","document","metrics","pipe","on","e","destroy","toCursor","cursor","toProto","projectId","databaseId","toQualifiedResourcePath","structuredQuery","toStructuredQuery","hasFieldOrders","order","dir","runQueryRequest","Uint8Array","transaction","Timestamp","readTime","timestampValue","newTransaction","_toBundledQuery","bundledQuery","from","kindless","o","_isPermanentRpcError","err","methodName","_hasRetryTimedOut","startTime","onSnapshot","onNext","onError","validateFunction","optional","watch","QueryWatch","size","docs","changes","QuerySnapshot","console","error","comparator","doc1","doc2","orderBys","comp","v1","protoField","v2","compare","withConverter","defaultConverter","_createSnapshot"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@google-cloud/firestore/build/src/reference/query.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Query = void 0;\nconst stream_1 = require(\"stream\");\nconst query_util_1 = require(\"./query-util\");\nconst index_1 = require(\"../index\");\nconst field_order_1 = require(\"./field-order\");\nconst field_filter_internal_1 = require(\"./field-filter-internal\");\nconst composite_filter_internal_1 = require(\"./composite-filter-internal\");\nconst constants_1 = require(\"./constants\");\nconst vector_query_options_1 = require(\"./vector-query-options\");\nconst document_reference_1 = require(\"./document-reference\");\nconst query_snapshot_1 = require(\"./query-snapshot\");\nconst serializer_1 = require(\"../serializer\");\nconst query_profile_1 = require(\"../query-profile\");\nconst filter_1 = require(\"../filter\");\nconst path_1 = require(\"../path\");\nconst helpers_1 = require(\"./helpers\");\nconst validate_1 = require(\"../validate\");\nconst types_1 = require(\"./types\");\nconst aggregate_query_1 = require(\"./aggregate-query\");\nconst vector_query_1 = require(\"./vector-query\");\nconst order_1 = require(\"../order\");\nconst types_2 = require(\"../types\");\n/**\n * A Query refers to a query which you can read or stream from. You can also\n * construct refined Query objects by adding filters and ordering.\n *\n * @class Query\n */\nclass Query {\n    /**\n     * @internal\n     * @private\n     *\n     * @param _firestore The Firestore Database client.\n     * @param _queryOptions Options that define the query.\n     */\n    constructor(\n    /**\n     * @internal\n     * @private\n     **/\n    _firestore, \n    /**\n     * @internal\n     * @private\n     **/\n    _queryOptions) {\n        this._firestore = _firestore;\n        this._queryOptions = _queryOptions;\n        this._serializer = new serializer_1.Serializer(_firestore);\n        this._allowUndefined =\n            !!this._firestore._settings.ignoreUndefinedProperties;\n        this._queryUtil = new query_util_1.QueryUtil(_firestore, _queryOptions, this._serializer);\n    }\n    /**\n     * Extracts field values from the DocumentSnapshot based on the provided\n     * field order.\n     *\n     * @private\n     * @internal\n     * @param documentSnapshot The document to extract the fields from.\n     * @param fieldOrders The field order that defines what fields we should\n     * extract.\n     * @return {Array.<*>} The field values to use.\n     */\n    static _extractFieldValues(documentSnapshot, fieldOrders) {\n        const fieldValues = [];\n        for (const fieldOrder of fieldOrders) {\n            if (index_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n                fieldValues.push(documentSnapshot.ref);\n            }\n            else {\n                const fieldValue = documentSnapshot.get(fieldOrder.field);\n                if (fieldValue === undefined) {\n                    throw new Error(`Field \"${fieldOrder.field}\" is missing in the provided DocumentSnapshot. ` +\n                        'Please provide a document that contains values for all specified ' +\n                        'orderBy() and where() constraints.');\n                }\n                else {\n                    fieldValues.push(fieldValue);\n                }\n            }\n        }\n        return fieldValues;\n    }\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name Query#firestore\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     * ```\n     */\n    get firestore() {\n        return this._firestore;\n    }\n    where(fieldPathOrFilter, opStr, value) {\n        let filter;\n        if (fieldPathOrFilter instanceof index_1.Filter) {\n            filter = fieldPathOrFilter;\n        }\n        else {\n            filter = index_1.Filter.where(fieldPathOrFilter, opStr, value);\n        }\n        if (this._queryOptions.startAt || this._queryOptions.endAt) {\n            throw new Error('Cannot specify a where() filter after calling startAt(), ' +\n                'startAfter(), endBefore() or endAt().');\n        }\n        const parsedFilter = this._parseFilter(filter);\n        if (parsedFilter.getFilters().length === 0) {\n            // Return the existing query if not adding any more filters (e.g. an empty composite filter).\n            return this;\n        }\n        const options = this._queryOptions.with({\n            filters: this._queryOptions.filters.concat(parsedFilter),\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * @internal\n     * @private\n     */\n    _parseFilter(filter) {\n        if (filter instanceof filter_1.UnaryFilter) {\n            return this._parseFieldFilter(filter);\n        }\n        return this._parseCompositeFilter(filter);\n    }\n    /**\n     * @internal\n     * @private\n     */\n    _parseFieldFilter(fieldFilterData) {\n        let value = fieldFilterData._getValue();\n        let operator = fieldFilterData._getOperator();\n        const fieldPath = fieldFilterData._getField();\n        (0, path_1.validateFieldPath)('fieldPath', fieldPath);\n        operator = (0, helpers_1.validateQueryOperator)('opStr', operator, value);\n        (0, helpers_1.validateQueryValue)('value', value, this._allowUndefined);\n        const path = index_1.FieldPath.fromArgument(fieldPath);\n        if (index_1.FieldPath.documentId().isEqual(path)) {\n            if (operator === 'array-contains' || operator === 'array-contains-any') {\n                throw new Error(`Invalid Query. You can't perform '${operator}' ` +\n                    'queries on FieldPath.documentId().');\n            }\n            else if (operator === 'in' || operator === 'not-in') {\n                if (!Array.isArray(value) || value.length === 0) {\n                    throw new Error(`Invalid Query. A non-empty array is required for '${operator}' filters.`);\n                }\n                value = value.map(el => this.validateReference(el));\n            }\n            else {\n                value = this.validateReference(value);\n            }\n        }\n        return new field_filter_internal_1.FieldFilterInternal(this._serializer, path, constants_1.comparisonOperators[operator], value);\n    }\n    /**\n     * @internal\n     * @private\n     */\n    _parseCompositeFilter(compositeFilterData) {\n        const parsedFilters = compositeFilterData\n            ._getFilters()\n            .map(filter => this._parseFilter(filter))\n            .filter(parsedFilter => parsedFilter.getFilters().length > 0);\n        // For composite filters containing 1 filter, return the only filter.\n        // For example: AND(FieldFilter1) == FieldFilter1\n        if (parsedFilters.length === 1) {\n            return parsedFilters[0];\n        }\n        return new composite_filter_internal_1.CompositeFilterInternal(parsedFilters, compositeFilterData._getOperator() === 'AND' ? 'AND' : 'OR');\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} instance that applies a\n     * field mask to the result and returns only the specified subset of fields.\n     * You can specify a list of field paths to return, or use an empty list to\n     * only return the references of matching documents.\n     *\n     * Queries that contain field masks cannot be listened to via `onSnapshot()`\n     * listeners.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the field mask.\n     *\n     * @param {...(string|FieldPath)} fieldPaths The field paths to return.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     * let documentRef = collectionRef.doc('doc');\n     *\n     * return documentRef.set({x:10, y:5}).then(() => {\n     *   return collectionRef.where('x', '>', 5).select('y').get();\n     * }).then((res) => {\n     *   console.log(`y is ${res.docs[0].get('y')}.`);\n     * });\n     * ```\n     */\n    select(...fieldPaths) {\n        const fields = [];\n        if (fieldPaths.length === 0) {\n            fields.push({ fieldPath: index_1.FieldPath.documentId().formattedName });\n        }\n        else {\n            for (let i = 0; i < fieldPaths.length; ++i) {\n                (0, path_1.validateFieldPath)(i, fieldPaths[i]);\n                fields.push({\n                    fieldPath: index_1.FieldPath.fromArgument(fieldPaths[i]).formattedName,\n                });\n            }\n        }\n        // By specifying a field mask, the query result no longer conforms to type\n        // `T`. We there return `Query<DocumentData>`;\n        const options = this._queryOptions.with({\n            projection: { fields },\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that's additionally sorted\n     * by the specified field, optionally in descending order instead of\n     * ascending.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the field mask.\n     *\n     * @param {string|FieldPath} fieldPath The field to sort by.\n     * @param {string=} directionStr Optional direction to sort by ('asc' or\n     * 'desc'). If not specified, order will be ascending.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.orderBy('foo', 'desc').get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    orderBy(fieldPath, directionStr) {\n        (0, path_1.validateFieldPath)('fieldPath', fieldPath);\n        directionStr = (0, helpers_1.validateQueryOrder)('directionStr', directionStr);\n        if (this._queryOptions.startAt || this._queryOptions.endAt) {\n            throw new Error('Cannot specify an orderBy() constraint after calling ' +\n                'startAt(), startAfter(), endBefore() or endAt().');\n        }\n        const newOrder = new field_order_1.FieldOrder(index_1.FieldPath.fromArgument(fieldPath), constants_1.directionOperators[directionStr || 'asc']);\n        const options = this._queryOptions.with({\n            fieldOrders: this._queryOptions.fieldOrders.concat(newOrder),\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that only returns the\n     * first matching documents.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the limit.\n     *\n     * @param {number} limit The maximum number of items to return.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limit(1).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    limit(limit) {\n        (0, validate_1.validateInteger)('limit', limit);\n        const options = this._queryOptions.with({\n            limit,\n            limitType: types_1.LimitType.First,\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that only returns the\n     * last matching documents.\n     *\n     * You must specify at least one orderBy clause for limitToLast queries,\n     * otherwise an exception will be thrown during execution.\n     *\n     * Results for limitToLast queries cannot be streamed via the `stream()` API.\n     *\n     * @param limit The maximum number of items to return.\n     * @return The created Query.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limitToLast(1).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Last matching document is ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    limitToLast(limit) {\n        (0, validate_1.validateInteger)('limitToLast', limit);\n        const options = this._queryOptions.with({ limit, limitType: types_1.LimitType.Last });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Specifies the offset of the returned results.\n     *\n     * This function returns a new (immutable) instance of the\n     * [Query]{@link Query} (rather than modify the existing instance)\n     * to impose the offset.\n     *\n     * @param {number} offset The offset to apply to the Query results\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limit(10).offset(20).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    offset(offset) {\n        (0, validate_1.validateInteger)('offset', offset);\n        const options = this._queryOptions.with({ offset });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Returns a query that counts the documents in the result set of this\n     * query.\n     *\n     * The returned query, when executed, counts the documents in the result set\n     * of this query without actually downloading the documents.\n     *\n     * Using the returned query to count the documents is efficient because only\n     * the final count, not the documents' data, is downloaded. The returned\n     * query can count the documents in cases where the result set is\n     * prohibitively large to download entirely (thousands of documents).\n     *\n     * @return a query that counts the documents in the result set of this\n     * query. The count can be retrieved from `snapshot.data().count`, where\n     * `snapshot` is the `AggregateQuerySnapshot` resulting from running the\n     * returned query.\n     */\n    count() {\n        return this.aggregate({\n            count: index_1.AggregateField.count(),\n        });\n    }\n    /**\n     * Returns a query that can perform the given aggregations.\n     *\n     * The returned query, when executed, calculates the specified aggregations\n     * over the documents in the result set of this query without actually\n     * downloading the documents.\n     *\n     * Using the returned query to perform aggregations is efficient because only\n     * the final aggregation values, not the documents' data, is downloaded. The\n     * returned query can perform aggregations of the documents count the\n     * documents in cases where the result set is prohibitively large to download\n     * entirely (thousands of documents).\n     *\n     * @param aggregateSpec An `AggregateSpec` object that specifies the aggregates\n     * to perform over the result set. The AggregateSpec specifies aliases for each\n     * aggregate, which can be used to retrieve the aggregate result.\n     * @example\n     * ```typescript\n     * const aggregateQuery = col.aggregate(query, {\n     *   countOfDocs: count(),\n     *   totalHours: sum('hours'),\n     *   averageScore: average('score')\n     * });\n     *\n     * const aggregateSnapshot = await aggregateQuery.get();\n     * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n     * const totalHours: number = aggregateSnapshot.data().totalHours;\n     * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n     * ```\n     */\n    aggregate(aggregateSpec) {\n        return new aggregate_query_1.AggregateQuery(this, aggregateSpec);\n    }\n    /**\n     * Returns a query that can perform vector distance (similarity) search with given parameters.\n     *\n     * The returned query, when executed, performs a distance (similarity) search on the specified\n     * `vectorField` against the given `queryVector` and returns the top documents that are closest\n     * to the `queryVector`.\n     *\n     * Only documents whose `vectorField` field is a {@link VectorValue} of the same dimension as `queryVector`\n     * participate in the query, all other documents are ignored.\n     *\n     * @example\n     * ```\n     * // Returns the closest 10 documents whose Euclidean distance from their 'embedding' fields are closed to [41, 42].\n     * const vectorQuery = col.findNearest('embedding', [41, 42], {limit: 10, distanceMeasure: 'EUCLIDEAN'});\n     *\n     * const querySnapshot = await aggregateQuery.get();\n     * querySnapshot.forEach(...);\n     * ```\n     *\n     * @param vectorField - A string or {@link FieldPath} specifying the vector field to search on.\n     * @param queryVector - The {@link VectorValue} used to measure the distance from `vectorField` values in the documents.\n     * @param options - Options control the vector query. `limit` specifies the upper bound of documents to return, must\n     * be a positive integer with a maximum value of 1000. `distanceMeasure` specifies what type of distance is calculated\n     * when performing the query.\n     */\n    findNearest(vectorField, queryVector, options) {\n        (0, path_1.validateFieldPath)('vectorField', vectorField);\n        if (options.limit <= 0) {\n            throw (0, validate_1.invalidArgumentMessage)('options.limit', 'positive limit number');\n        }\n        if ((Array.isArray(queryVector)\n            ? queryVector.length\n            : queryVector.toArray().length) === 0) {\n            throw (0, validate_1.invalidArgumentMessage)('queryVector', 'vector size must be larger than 0');\n        }\n        return new vector_query_1.VectorQuery(this, vectorField, queryVector, new vector_query_options_1.VectorQueryOptions(options.limit, options.distanceMeasure));\n    }\n    /**\n     * Returns true if this `Query` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `Query` is equal to the provided value.\n     */\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        return (other instanceof Query && this._queryOptions.isEqual(other._queryOptions));\n    }\n    /**\n     * Returns the sorted array of inequality filter fields used in this query.\n     *\n     * @return An array of inequality filter fields sorted lexicographically by FieldPath.\n     */\n    getInequalityFilterFields() {\n        const inequalityFields = [];\n        for (const filter of this._queryOptions.filters) {\n            for (const subFilter of filter.getFlattenedFilters()) {\n                if (subFilter.isInequalityFilter()) {\n                    inequalityFields.push(subFilter.field);\n                }\n            }\n        }\n        return inequalityFields.sort((a, b) => a.compareTo(b));\n    }\n    /**\n     * Computes the backend ordering semantics for DocumentSnapshot cursors.\n     *\n     * @private\n     * @internal\n     * @param cursorValuesOrDocumentSnapshot The snapshot of the document or the\n     * set of field values to use as the boundary.\n     * @returns The implicit ordering semantics.\n     */\n    createImplicitOrderBy(cursorValuesOrDocumentSnapshot) {\n        // Add an implicit orderBy if the only cursor value is a DocumentSnapshot.\n        if (cursorValuesOrDocumentSnapshot.length !== 1 ||\n            !(cursorValuesOrDocumentSnapshot[0] instanceof index_1.DocumentSnapshot)) {\n            return this._queryOptions.fieldOrders;\n        }\n        const fieldOrders = this._queryOptions.fieldOrders.slice();\n        const fieldsNormalized = new Set([\n            ...fieldOrders.map(item => item.field.toString()),\n        ]);\n        /** The order of the implicit ordering always matches the last explicit order by. */\n        const lastDirection = fieldOrders.length === 0\n            ? constants_1.directionOperators.ASC\n            : fieldOrders[fieldOrders.length - 1].direction;\n        /**\n         * Any inequality fields not explicitly ordered should be implicitly ordered in a\n         * lexicographical order. When there are multiple inequality filters on the same field, the\n         * field should be added only once.\n         * Note: getInequalityFilterFields function sorts the key field before\n         * other fields. However, we want the key field to be sorted last.\n         */\n        const inequalityFields = this.getInequalityFilterFields();\n        for (const field of inequalityFields) {\n            if (!fieldsNormalized.has(field.toString()) &&\n                !field.isEqual(index_1.FieldPath.documentId())) {\n                fieldOrders.push(new field_order_1.FieldOrder(field, lastDirection));\n                fieldsNormalized.add(field.toString());\n            }\n        }\n        // Add the document key field to the last if it is not explicitly ordered.\n        if (!fieldsNormalized.has(index_1.FieldPath.documentId().toString())) {\n            fieldOrders.push(new field_order_1.FieldOrder(index_1.FieldPath.documentId(), lastDirection));\n        }\n        return fieldOrders;\n    }\n    /**\n     * Builds a Firestore 'Position' proto message.\n     *\n     * @private\n     * @internal\n     * @param {Array.<FieldOrder>} fieldOrders The field orders to use for this\n     * cursor.\n     * @param {Array.<DocumentSnapshot|*>} cursorValuesOrDocumentSnapshot The\n     * snapshot of the document or the set of field values to use as the boundary.\n     * @param before Whether the query boundary lies just before or after the\n     * provided data.\n     * @returns {Object} The proto message.\n     */\n    createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) {\n        let fieldValues;\n        if (cursorValuesOrDocumentSnapshot.length === 1 &&\n            cursorValuesOrDocumentSnapshot[0] instanceof index_1.DocumentSnapshot) {\n            fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);\n        }\n        else {\n            fieldValues = cursorValuesOrDocumentSnapshot;\n        }\n        if (fieldValues.length > fieldOrders.length) {\n            throw new Error('Too many cursor values specified. The specified ' +\n                'values must match the orderBy() constraints of the query.');\n        }\n        const options = { values: [], before };\n        for (let i = 0; i < fieldValues.length; ++i) {\n            let fieldValue = fieldValues[i];\n            if (index_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) {\n                fieldValue = this.validateReference(fieldValue);\n            }\n            (0, helpers_1.validateQueryValue)(i, fieldValue, this._allowUndefined);\n            options.values.push(this._serializer.encodeValue(fieldValue));\n        }\n        return options;\n    }\n    /**\n     * Validates that a value used with FieldValue.documentId() is either a\n     * string or a DocumentReference that is part of the query`s result set.\n     * Throws a validation error or returns a DocumentReference that can\n     * directly be used in the Query.\n     *\n     * @param val The value to validate.\n     * @throws If the value cannot be used for this query.\n     * @return If valid, returns a DocumentReference that can be used with the\n     * query.\n     * @private\n     * @internal\n     */\n    validateReference(val) {\n        const basePath = this._queryOptions.allDescendants\n            ? this._queryOptions.parentPath\n            : this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n        let reference;\n        if (typeof val === 'string') {\n            const path = basePath.append(val);\n            if (this._queryOptions.allDescendants) {\n                if (!path.isDocument) {\n                    throw new Error('When querying a collection group and ordering by ' +\n                        'FieldPath.documentId(), the corresponding value must result in ' +\n                        `a valid document path, but '${val}' is not because it ` +\n                        'contains an odd number of segments.');\n                }\n            }\n            else if (val.indexOf('/') !== -1) {\n                throw new Error('When querying a collection and ordering by FieldPath.documentId(), ' +\n                    `the corresponding value must be a plain document ID, but '${val}' ` +\n                    'contains a slash.');\n            }\n            reference = new document_reference_1.DocumentReference(this._firestore, basePath.append(val), this._queryOptions.converter);\n        }\n        else if (val instanceof document_reference_1.DocumentReference) {\n            reference = val;\n            if (!basePath.isPrefixOf(reference._path)) {\n                throw new Error(`\"${reference.path}\" is not part of the query result set and ` +\n                    'cannot be used as a query boundary.');\n            }\n        }\n        else {\n            throw new Error('The corresponding value for FieldPath.documentId() must be a ' +\n                `string or a DocumentReference, but was \"${val}\".`);\n        }\n        if (!this._queryOptions.allDescendants &&\n            reference._path.parent().compareTo(basePath) !== 0) {\n            throw new Error('Only a direct child can be used as a query boundary. ' +\n                `Found: \"${reference.path}\".`);\n        }\n        return reference;\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that starts at the provided\n     * set of field values relative to the order of the query. The order of the\n     * provided values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should start at or the field values to\n     * start this query at, in order of the query's order by.\n     * @returns {Query} A query with the new starting point.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').startAt(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    startAt(...fieldValuesOrDocumentSnapshot) {\n        (0, validate_1.validateMinNumberOfArguments)('Query.startAt', fieldValuesOrDocumentSnapshot, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n        const options = this._queryOptions.with({ fieldOrders, startAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that starts after the\n     * provided set of field values relative to the order of the query. The order\n     * of the provided values must match the order of the order by clauses of the\n     * query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should start after or the field values to\n     * start this query after, in order of the query's order by.\n     * @returns {Query} A query with the new starting point.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').startAfter(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    startAfter(...fieldValuesOrDocumentSnapshot) {\n        (0, validate_1.validateMinNumberOfArguments)('Query.startAfter', fieldValuesOrDocumentSnapshot, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n        const options = this._queryOptions.with({ fieldOrders, startAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that ends before the set of\n     * field values relative to the order of the query. The order of the provided\n     * values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should end before or the field values to\n     * end this query before, in order of the query's order by.\n     * @returns {Query} A query with the new ending point.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').endBefore(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    endBefore(...fieldValuesOrDocumentSnapshot) {\n        (0, validate_1.validateMinNumberOfArguments)('Query.endBefore', fieldValuesOrDocumentSnapshot, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n        const options = this._queryOptions.with({ fieldOrders, endAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that ends at the provided\n     * set of field values relative to the order of the query. The order of the\n     * provided values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should end at or the field values to end\n     * this query at, in order of the query's order by.\n     * @returns {Query} A query with the new ending point.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').endAt(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    endAt(...fieldValuesOrDocumentSnapshot) {\n        (0, validate_1.validateMinNumberOfArguments)('Query.endAt', fieldValuesOrDocumentSnapshot, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n        const options = this._queryOptions.with({ fieldOrders, endAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Executes the query and returns the results as a\n     * [QuerySnapshot]{@link QuerySnapshot}.\n     *\n     * @returns {Promise.<QuerySnapshot>} A Promise that resolves with the results\n     * of the Query.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    async get() {\n        const { result } = await this._get();\n        return result;\n    }\n    /**\n     * Plans and optionally executes this query. Returns a Promise that will be\n     * resolved with the planner information, statistics from the query execution (if any),\n     * and the query results (if any).\n     *\n     * @return A Promise that will be resolved with the planner information, statistics\n     *  from the query execution (if any), and the query results (if any).\n     */\n    async explain(options) {\n        if (options === undefined) {\n            options = {};\n        }\n        const { result, explainMetrics } = await this._getResponse(undefined, options);\n        if (!explainMetrics) {\n            throw new Error('No explain results');\n        }\n        return new query_profile_1.ExplainResults(explainMetrics, result || null);\n    }\n    /**\n     * Internal get() method that accepts an optional transaction options, and\n     * returns a query snapshot with transaction and explain metadata.\n     *\n     * @private\n     * @internal\n     * @param transactionOrReadTime A transaction ID, options to start a new\n     *  transaction, or timestamp to use as read time.\n     */\n    async _get(transactionOrReadTime) {\n        const result = await this._getResponse(transactionOrReadTime);\n        if (!result.result) {\n            throw new Error('No QuerySnapshot result');\n        }\n        return result;\n    }\n    _getResponse(transactionOrReadTime, explainOptions) {\n        return this._queryUtil._getResponse(this, transactionOrReadTime, true, explainOptions);\n    }\n    /**\n     * Executes the query and streams the results as\n     * [QueryDocumentSnapshots]{@link QueryDocumentSnapshot}.\n     *\n     * @returns {Stream.<QueryDocumentSnapshot>} A stream of\n     * QueryDocumentSnapshots.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let count = 0;\n     *\n     * query.stream().on('data', (documentSnapshot) => {\n     *   console.log(`Found document with name '${documentSnapshot.id}'`);\n     *   ++count;\n     * }).on('end', () => {\n     *   console.log(`Total count is ${count}`);\n     * });\n     * ```\n     */\n    stream() {\n        return this._queryUtil.stream(this);\n    }\n    /**\n     * Executes the query and streams the results as the following object:\n     * {document?: DocumentSnapshot, metrics?: ExplainMetrics}\n     *\n     * The stream surfaces documents one at a time as they are received from the\n     * server, and at the end, it will surface the metrics associated with\n     * executing the query.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let count = 0;\n     *\n     * query.explainStream({analyze: true}).on('data', (data) => {\n     *   if (data.document) {\n     *     // Use data.document which is a DocumentSnapshot instance.\n     *     console.log(`Found document with name '${data.document.id}'`);\n     *     ++count;\n     *   }\n     *   if (data.metrics) {\n     *     // Use data.metrics which is an ExplainMetrics instance.\n     *   }\n     * }).on('end', () => {\n     *   console.log(`Received ${count} documents.`);\n     * });\n     * ```\n     */\n    explainStream(explainOptions) {\n        if (explainOptions === undefined) {\n            explainOptions = {};\n        }\n        if (this._queryOptions.limitType === types_1.LimitType.Last) {\n            throw new Error('Query results for queries that include limitToLast() ' +\n                'constraints cannot be streamed. Use Query.explain() instead.');\n        }\n        const responseStream = this._stream(undefined, explainOptions);\n        const transform = new stream_1.Transform({\n            objectMode: true,\n            transform(chunk, encoding, callback) {\n                if (chunk.document || chunk.explainMetrics) {\n                    callback(undefined, {\n                        document: chunk.document,\n                        metrics: chunk.explainMetrics,\n                    });\n                }\n            },\n        });\n        responseStream.pipe(transform);\n        responseStream.on('error', e => transform.destroy(e));\n        return transform;\n    }\n    /**\n     * Converts a QueryCursor to its proto representation.\n     *\n     * @param cursor The original cursor value\n     * @private\n     * @internal\n     */\n    toCursor(cursor) {\n        if (cursor) {\n            return cursor.before\n                ? { before: true, values: cursor.values }\n                : { values: cursor.values };\n        }\n        return undefined;\n    }\n    /**\n     * Internal method for serializing a query to its RunQuery proto\n     * representation with an optional transaction id or read time.\n     *\n     * @param transactionOrReadTime A transaction ID, options to start a new\n     *  transaction, or timestamp to use as read time.\n     * @param explainOptions Options to use for explaining the query (if any).\n     * @private\n     * @internal\n     * @returns Serialized JSON for the query.\n     */\n    toProto(transactionOrReadTime, explainOptions) {\n        const projectId = this.firestore.projectId;\n        const databaseId = this.firestore.databaseId;\n        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId, databaseId);\n        const structuredQuery = this.toStructuredQuery();\n        // For limitToLast queries, the structured query has to be translated to a version with\n        // reversed ordered, and flipped startAt/endAt to work properly.\n        if (this._queryOptions.limitType === types_1.LimitType.Last) {\n            if (!this._queryOptions.hasFieldOrders()) {\n                throw new Error('limitToLast() queries require specifying at least one orderBy() clause.');\n            }\n            structuredQuery.orderBy = this._queryOptions.fieldOrders.map(order => {\n                // Flip the orderBy directions since we want the last results\n                const dir = order.direction === 'DESCENDING' ? 'ASCENDING' : 'DESCENDING';\n                return new field_order_1.FieldOrder(order.field, dir).toProto();\n            });\n            // Swap the cursors to match the now-flipped query ordering.\n            structuredQuery.startAt = this._queryOptions.endAt\n                ? this.toCursor({\n                    values: this._queryOptions.endAt.values,\n                    before: !this._queryOptions.endAt.before,\n                })\n                : undefined;\n            structuredQuery.endAt = this._queryOptions.startAt\n                ? this.toCursor({\n                    values: this._queryOptions.startAt.values,\n                    before: !this._queryOptions.startAt.before,\n                })\n                : undefined;\n        }\n        const runQueryRequest = {\n            parent: parentPath.formattedName,\n            structuredQuery,\n        };\n        if (transactionOrReadTime instanceof Uint8Array) {\n            runQueryRequest.transaction = transactionOrReadTime;\n        }\n        else if (transactionOrReadTime instanceof index_1.Timestamp) {\n            runQueryRequest.readTime = transactionOrReadTime.toProto().timestampValue;\n        }\n        else if (transactionOrReadTime) {\n            runQueryRequest.newTransaction = transactionOrReadTime;\n        }\n        if (explainOptions) {\n            runQueryRequest.explainOptions = explainOptions;\n        }\n        return runQueryRequest;\n    }\n    /**\n     * Converts current Query to an IBundledQuery.\n     *\n     * @private\n     * @internal\n     */\n    _toBundledQuery() {\n        const projectId = this.firestore.projectId;\n        const databaseId = this.firestore.databaseId;\n        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId, databaseId);\n        const structuredQuery = this.toStructuredQuery();\n        const bundledQuery = {\n            parent: parentPath.formattedName,\n            structuredQuery,\n        };\n        if (this._queryOptions.limitType === types_1.LimitType.First) {\n            bundledQuery.limitType = 'FIRST';\n        }\n        else if (this._queryOptions.limitType === types_1.LimitType.Last) {\n            bundledQuery.limitType = 'LAST';\n        }\n        return bundledQuery;\n    }\n    toStructuredQuery() {\n        const structuredQuery = {\n            from: [{}],\n        };\n        if (this._queryOptions.allDescendants) {\n            structuredQuery.from[0].allDescendants = true;\n        }\n        // Kindless queries select all descendant documents, so we remove the\n        // collectionId field.\n        if (!this._queryOptions.kindless) {\n            structuredQuery.from[0].collectionId = this._queryOptions.collectionId;\n        }\n        if (this._queryOptions.filters.length >= 1) {\n            structuredQuery.where = new composite_filter_internal_1.CompositeFilterInternal(this._queryOptions.filters, 'AND').toProto();\n        }\n        if (this._queryOptions.hasFieldOrders()) {\n            structuredQuery.orderBy = this._queryOptions.fieldOrders.map(o => o.toProto());\n        }\n        structuredQuery.startAt = this.toCursor(this._queryOptions.startAt);\n        structuredQuery.endAt = this.toCursor(this._queryOptions.endAt);\n        if (this._queryOptions.limit) {\n            structuredQuery.limit = { value: this._queryOptions.limit };\n        }\n        structuredQuery.offset = this._queryOptions.offset;\n        structuredQuery.select = this._queryOptions.projection;\n        return structuredQuery;\n    }\n    /**\n     * @internal\n     * @private\n     * This method exists solely to maintain backward compatability.\n     */\n    _isPermanentRpcError(err, methodName) {\n        return this._queryUtil._isPermanentRpcError(err, methodName);\n    }\n    /**\n     * @internal\n     * @private\n     * This method exists solely to maintain backward compatability.\n     */\n    _hasRetryTimedOut(methodName, startTime) {\n        return this._queryUtil._hasRetryTimedOut(methodName, startTime);\n    }\n    /**\n     * Internal streaming method that accepts an optional transaction ID.\n     *\n     * BEWARE: If `transactionOrReadTime` is `ITransactionOptions`, then the first\n     * response in the stream will be a transaction response.\n     *\n     * @param transactionOrReadTime A transaction ID, options to start a new\n     *  transaction, or timestamp to use as read time.\n     * @param explainOptions Options to use for explaining the query (if any).\n     * @private\n     * @internal\n     * @returns A stream of document results, optionally preceded by a transaction response.\n     */\n    _stream(transactionOrReadTime, explainOptions) {\n        return this._queryUtil._stream(this, transactionOrReadTime, true, explainOptions);\n    }\n    /**\n     * Attaches a listener for QuerySnapshot events.\n     *\n     * @param {querySnapshotCallback} onNext A callback to be called every time\n     * a new [QuerySnapshot]{@link QuerySnapshot} is available.\n     * @param {errorCallback=} onError A callback to be called if the listen\n     * fails or is cancelled. No further callbacks will occur.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let unsubscribe = query.onSnapshot(querySnapshot => {\n     *   console.log(`Received query snapshot of size ${querySnapshot.size}`);\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     * ```\n     */\n    onSnapshot(onNext, onError) {\n        (0, validate_1.validateFunction)('onNext', onNext);\n        (0, validate_1.validateFunction)('onError', onError, { optional: true });\n        const watch = new (require('../watch').QueryWatch)(this.firestore, this, this._queryOptions.converter);\n        return watch.onSnapshot((readTime, size, docs, changes) => {\n            onNext(new query_snapshot_1.QuerySnapshot(this, readTime, size, docs, changes));\n        }, onError || console.error);\n    }\n    /**\n     * Returns a function that can be used to sort QueryDocumentSnapshots\n     * according to the sort criteria of this query.\n     *\n     * @private\n     * @internal\n     */\n    comparator() {\n        return (doc1, doc2) => {\n            // Add implicit sorting by name, using the last specified direction.\n            const lastDirection = this._queryOptions.hasFieldOrders()\n                ? this._queryOptions.fieldOrders[this._queryOptions.fieldOrders.length - 1].direction\n                : 'ASCENDING';\n            const orderBys = this._queryOptions.fieldOrders.concat(new field_order_1.FieldOrder(index_1.FieldPath.documentId(), lastDirection));\n            for (const orderBy of orderBys) {\n                let comp;\n                if (index_1.FieldPath.documentId().isEqual(orderBy.field)) {\n                    comp = doc1.ref._path.compareTo(doc2.ref._path);\n                }\n                else {\n                    const v1 = doc1.protoField(orderBy.field);\n                    const v2 = doc2.protoField(orderBy.field);\n                    if (v1 === undefined || v2 === undefined) {\n                        throw new Error('Trying to compare documents on fields that ' +\n                            \"don't exist. Please include the fields you are ordering on \" +\n                            'in your select() call.');\n                    }\n                    comp = (0, order_1.compare)(v1, v2);\n                }\n                if (comp !== 0) {\n                    const direction = orderBy.direction === 'ASCENDING' ? 1 : -1;\n                    return direction * comp;\n                }\n            }\n            return 0;\n        };\n    }\n    /**\n     * Applies a custom data converter to this Query, allowing you to use your\n     * own custom model objects with Firestore. When you call get() on the\n     * returned Query, the provided converter will convert between Firestore\n     * data of type `NewDbModelType` and your custom type `NewAppModelType`.\n     *\n     * Using the converter allows you to specify generic type arguments when\n     * storing and retrieving objects from Firestore.\n     *\n     * Passing in `null` as the converter parameter removes the current\n     * converter.\n     *\n     * @example\n     * ```\n     * class Post {\n     *   constructor(readonly title: string, readonly author: string) {}\n     *\n     *   toString(): string {\n     *     return this.title + ', by ' + this.author;\n     *   }\n     * }\n     *\n     * const postConverter = {\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n     *     return {title: post.title, author: post.author};\n     *   },\n     *   fromFirestore(\n     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\n     *   ): Post {\n     *     const data = snapshot.data();\n     *     return new Post(data.title, data.author);\n     *   }\n     * };\n     *\n     * const postSnap = await Firestore()\n     *   .collection('posts')\n     *   .withConverter(postConverter)\n     *   .doc().get();\n     * const post = postSnap.data();\n     * if (post !== undefined) {\n     *   post.title; // string\n     *   post.toString(); // Should be defined\n     *   post.someNonExistentProperty; // TS error\n     * }\n     *\n     * ```\n     * @param {FirestoreDataConverter | null} converter Converts objects to and\n     * from Firestore. Passing in `null` removes the current converter.\n     * @return A Query that uses the provided converter.\n     */\n    withConverter(converter) {\n        return new Query(this.firestore, this._queryOptions.withConverter(converter !== null && converter !== void 0 ? converter : (0, types_2.defaultConverter)()));\n    }\n    /**\n     * Construct the resulting snapshot for this query with given documents.\n     *\n     * @private\n     * @internal\n     */\n    _createSnapshot(readTime, size, docs, changes) {\n        return new query_snapshot_1.QuerySnapshot(this, readTime, size, docs, changes);\n    }\n}\nexports.Query = Query;\n//# sourceMappingURL=query.js.map"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,KAAK,GAAG,KAAK,CAAC;AACtB,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAClC,MAAMC,YAAY,GAAGD,OAAO,CAAC,cAAc,CAAC;AAC5C,MAAME,OAAO,GAAGF,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMG,aAAa,GAAGH,OAAO,CAAC,eAAe,CAAC;AAC9C,MAAMI,uBAAuB,GAAGJ,OAAO,CAAC,yBAAyB,CAAC;AAClE,MAAMK,2BAA2B,GAAGL,OAAO,CAAC,6BAA6B,CAAC;AAC1E,MAAMM,WAAW,GAAGN,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMO,sBAAsB,GAAGP,OAAO,CAAC,wBAAwB,CAAC;AAChE,MAAMQ,oBAAoB,GAAGR,OAAO,CAAC,sBAAsB,CAAC;AAC5D,MAAMS,gBAAgB,GAAGT,OAAO,CAAC,kBAAkB,CAAC;AACpD,MAAMU,YAAY,GAAGV,OAAO,CAAC,eAAe,CAAC;AAC7C,MAAMW,eAAe,GAAGX,OAAO,CAAC,kBAAkB,CAAC;AACnD,MAAMY,QAAQ,GAAGZ,OAAO,CAAC,WAAW,CAAC;AACrC,MAAMa,MAAM,GAAGb,OAAO,CAAC,SAAS,CAAC;AACjC,MAAMc,SAAS,GAAGd,OAAO,CAAC,WAAW,CAAC;AACtC,MAAMe,UAAU,GAAGf,OAAO,CAAC,aAAa,CAAC;AACzC,MAAMgB,OAAO,GAAGhB,OAAO,CAAC,SAAS,CAAC;AAClC,MAAMiB,iBAAiB,GAAGjB,OAAO,CAAC,mBAAmB,CAAC;AACtD,MAAMkB,cAAc,GAAGlB,OAAO,CAAC,gBAAgB,CAAC;AAChD,MAAMmB,OAAO,GAAGnB,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMoB,OAAO,GAAGpB,OAAO,CAAC,UAAU,CAAC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,MAAMF,KAAK,CAAC;EACR;AACJ;AACA;AACA;AACA;AACA;AACA;EACIuB,WAAWA;EACX;AACJ;AACA;AACA;EACIC,UAAU;EACV;AACJ;AACA;AACA;EACIC,aAAa,EAAE;IACX,IAAI,CAACD,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,WAAW,GAAG,IAAId,YAAY,CAACe,UAAU,CAACH,UAAU,CAAC;IAC1D,IAAI,CAACI,eAAe,GAChB,CAAC,CAAC,IAAI,CAACJ,UAAU,CAACK,SAAS,CAACC,yBAAyB;IACzD,IAAI,CAACC,UAAU,GAAG,IAAI5B,YAAY,CAAC6B,SAAS,CAACR,UAAU,EAAEC,aAAa,EAAE,IAAI,CAACC,WAAW,CAAC;EAC7F;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOO,mBAAmBA,CAACC,gBAAgB,EAAEC,WAAW,EAAE;IACtD,MAAMC,WAAW,GAAG,EAAE;IACtB,KAAK,MAAMC,UAAU,IAAIF,WAAW,EAAE;MAClC,IAAI/B,OAAO,CAACkC,SAAS,CAACC,UAAU,CAAC,CAAC,CAACC,OAAO,CAACH,UAAU,CAACI,KAAK,CAAC,EAAE;QAC1DL,WAAW,CAACM,IAAI,CAACR,gBAAgB,CAACS,GAAG,CAAC;MAC1C,CAAC,MACI;QACD,MAAMC,UAAU,GAAGV,gBAAgB,CAACW,GAAG,CAACR,UAAU,CAACI,KAAK,CAAC;QACzD,IAAIG,UAAU,KAAKE,SAAS,EAAE;UAC1B,MAAM,IAAIC,KAAK,CAAC,UAAUV,UAAU,CAACI,KAAK,iDAAiD,GACvF,mEAAmE,GACnE,oCAAoC,CAAC;QAC7C,CAAC,MACI;UACDL,WAAW,CAACM,IAAI,CAACE,UAAU,CAAC;QAChC;MACJ;IACJ;IACA,OAAOR,WAAW;EACtB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIY,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACxB,UAAU;EAC1B;EACAyB,KAAKA,CAACC,iBAAiB,EAAEC,KAAK,EAAEpD,KAAK,EAAE;IACnC,IAAIqD,MAAM;IACV,IAAIF,iBAAiB,YAAY9C,OAAO,CAACiD,MAAM,EAAE;MAC7CD,MAAM,GAAGF,iBAAiB;IAC9B,CAAC,MACI;MACDE,MAAM,GAAGhD,OAAO,CAACiD,MAAM,CAACJ,KAAK,CAACC,iBAAiB,EAAEC,KAAK,EAAEpD,KAAK,CAAC;IAClE;IACA,IAAI,IAAI,CAAC0B,aAAa,CAAC6B,OAAO,IAAI,IAAI,CAAC7B,aAAa,CAAC8B,KAAK,EAAE;MACxD,MAAM,IAAIR,KAAK,CAAC,2DAA2D,GACvE,uCAAuC,CAAC;IAChD;IACA,MAAMS,YAAY,GAAG,IAAI,CAACC,YAAY,CAACL,MAAM,CAAC;IAC9C,IAAII,YAAY,CAACE,UAAU,CAAC,CAAC,CAACC,MAAM,KAAK,CAAC,EAAE;MACxC;MACA,OAAO,IAAI;IACf;IACA,MAAMC,OAAO,GAAG,IAAI,CAACnC,aAAa,CAACoC,IAAI,CAAC;MACpCC,OAAO,EAAE,IAAI,CAACrC,aAAa,CAACqC,OAAO,CAACC,MAAM,CAACP,YAAY;IAC3D,CAAC,CAAC;IACF,OAAO,IAAIxD,KAAK,CAAC,IAAI,CAACwB,UAAU,EAAEoC,OAAO,CAAC;EAC9C;EACA;AACJ;AACA;AACA;EACIH,YAAYA,CAACL,MAAM,EAAE;IACjB,IAAIA,MAAM,YAAYtC,QAAQ,CAACkD,WAAW,EAAE;MACxC,OAAO,IAAI,CAACC,iBAAiB,CAACb,MAAM,CAAC;IACzC;IACA,OAAO,IAAI,CAACc,qBAAqB,CAACd,MAAM,CAAC;EAC7C;EACA;AACJ;AACA;AACA;EACIa,iBAAiBA,CAACE,eAAe,EAAE;IAC/B,IAAIpE,KAAK,GAAGoE,eAAe,CAACC,SAAS,CAAC,CAAC;IACvC,IAAIC,QAAQ,GAAGF,eAAe,CAACG,YAAY,CAAC,CAAC;IAC7C,MAAMC,SAAS,GAAGJ,eAAe,CAACK,SAAS,CAAC,CAAC;IAC7C,CAAC,CAAC,EAAEzD,MAAM,CAAC0D,iBAAiB,EAAE,WAAW,EAAEF,SAAS,CAAC;IACrDF,QAAQ,GAAG,CAAC,CAAC,EAAErD,SAAS,CAAC0D,qBAAqB,EAAE,OAAO,EAAEL,QAAQ,EAAEtE,KAAK,CAAC;IACzE,CAAC,CAAC,EAAEiB,SAAS,CAAC2D,kBAAkB,EAAE,OAAO,EAAE5E,KAAK,EAAE,IAAI,CAAC6B,eAAe,CAAC;IACvE,MAAMgD,IAAI,GAAGxE,OAAO,CAACkC,SAAS,CAACuC,YAAY,CAACN,SAAS,CAAC;IACtD,IAAInE,OAAO,CAACkC,SAAS,CAACC,UAAU,CAAC,CAAC,CAACC,OAAO,CAACoC,IAAI,CAAC,EAAE;MAC9C,IAAIP,QAAQ,KAAK,gBAAgB,IAAIA,QAAQ,KAAK,oBAAoB,EAAE;QACpE,MAAM,IAAItB,KAAK,CAAC,qCAAqCsB,QAAQ,IAAI,GAC7D,oCAAoC,CAAC;MAC7C,CAAC,MACI,IAAIA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,QAAQ,EAAE;QACjD,IAAI,CAACS,KAAK,CAACC,OAAO,CAAChF,KAAK,CAAC,IAAIA,KAAK,CAAC4D,MAAM,KAAK,CAAC,EAAE;UAC7C,MAAM,IAAIZ,KAAK,CAAC,qDAAqDsB,QAAQ,YAAY,CAAC;QAC9F;QACAtE,KAAK,GAAGA,KAAK,CAACiF,GAAG,CAACC,EAAE,IAAI,IAAI,CAACC,iBAAiB,CAACD,EAAE,CAAC,CAAC;MACvD,CAAC,MACI;QACDlF,KAAK,GAAG,IAAI,CAACmF,iBAAiB,CAACnF,KAAK,CAAC;MACzC;IACJ;IACA,OAAO,IAAIO,uBAAuB,CAAC6E,mBAAmB,CAAC,IAAI,CAACzD,WAAW,EAAEkD,IAAI,EAAEpE,WAAW,CAAC4E,mBAAmB,CAACf,QAAQ,CAAC,EAAEtE,KAAK,CAAC;EACpI;EACA;AACJ;AACA;AACA;EACImE,qBAAqBA,CAACmB,mBAAmB,EAAE;IACvC,MAAMC,aAAa,GAAGD,mBAAmB,CACpCE,WAAW,CAAC,CAAC,CACbP,GAAG,CAAC5B,MAAM,IAAI,IAAI,CAACK,YAAY,CAACL,MAAM,CAAC,CAAC,CACxCA,MAAM,CAACI,YAAY,IAAIA,YAAY,CAACE,UAAU,CAAC,CAAC,CAACC,MAAM,GAAG,CAAC,CAAC;IACjE;IACA;IACA,IAAI2B,aAAa,CAAC3B,MAAM,KAAK,CAAC,EAAE;MAC5B,OAAO2B,aAAa,CAAC,CAAC,CAAC;IAC3B;IACA,OAAO,IAAI/E,2BAA2B,CAACiF,uBAAuB,CAACF,aAAa,EAAED,mBAAmB,CAACf,YAAY,CAAC,CAAC,KAAK,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC;EAC9I;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACImB,MAAMA,CAAC,GAAGC,UAAU,EAAE;IAClB,MAAMC,MAAM,GAAG,EAAE;IACjB,IAAID,UAAU,CAAC/B,MAAM,KAAK,CAAC,EAAE;MACzBgC,MAAM,CAACjD,IAAI,CAAC;QAAE6B,SAAS,EAAEnE,OAAO,CAACkC,SAAS,CAACC,UAAU,CAAC,CAAC,CAACqD;MAAc,CAAC,CAAC;IAC5E,CAAC,MACI;MACD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,UAAU,CAAC/B,MAAM,EAAE,EAAEkC,CAAC,EAAE;QACxC,CAAC,CAAC,EAAE9E,MAAM,CAAC0D,iBAAiB,EAAEoB,CAAC,EAAEH,UAAU,CAACG,CAAC,CAAC,CAAC;QAC/CF,MAAM,CAACjD,IAAI,CAAC;UACR6B,SAAS,EAAEnE,OAAO,CAACkC,SAAS,CAACuC,YAAY,CAACa,UAAU,CAACG,CAAC,CAAC,CAAC,CAACD;QAC7D,CAAC,CAAC;MACN;IACJ;IACA;IACA;IACA,MAAMhC,OAAO,GAAG,IAAI,CAACnC,aAAa,CAACoC,IAAI,CAAC;MACpCiC,UAAU,EAAE;QAAEH;MAAO;IACzB,CAAC,CAAC;IACF,OAAO,IAAI3F,KAAK,CAAC,IAAI,CAACwB,UAAU,EAAEoC,OAAO,CAAC;EAC9C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACImC,OAAOA,CAACxB,SAAS,EAAEyB,YAAY,EAAE;IAC7B,CAAC,CAAC,EAAEjF,MAAM,CAAC0D,iBAAiB,EAAE,WAAW,EAAEF,SAAS,CAAC;IACrDyB,YAAY,GAAG,CAAC,CAAC,EAAEhF,SAAS,CAACiF,kBAAkB,EAAE,cAAc,EAAED,YAAY,CAAC;IAC9E,IAAI,IAAI,CAACvE,aAAa,CAAC6B,OAAO,IAAI,IAAI,CAAC7B,aAAa,CAAC8B,KAAK,EAAE;MACxD,MAAM,IAAIR,KAAK,CAAC,uDAAuD,GACnE,kDAAkD,CAAC;IAC3D;IACA,MAAMmD,QAAQ,GAAG,IAAI7F,aAAa,CAAC8F,UAAU,CAAC/F,OAAO,CAACkC,SAAS,CAACuC,YAAY,CAACN,SAAS,CAAC,EAAE/D,WAAW,CAAC4F,kBAAkB,CAACJ,YAAY,IAAI,KAAK,CAAC,CAAC;IAC/I,MAAMpC,OAAO,GAAG,IAAI,CAACnC,aAAa,CAACoC,IAAI,CAAC;MACpC1B,WAAW,EAAE,IAAI,CAACV,aAAa,CAACU,WAAW,CAAC4B,MAAM,CAACmC,QAAQ;IAC/D,CAAC,CAAC;IACF,OAAO,IAAIlG,KAAK,CAAC,IAAI,CAACwB,UAAU,EAAEoC,OAAO,CAAC;EAC9C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIyC,KAAKA,CAACA,KAAK,EAAE;IACT,CAAC,CAAC,EAAEpF,UAAU,CAACqF,eAAe,EAAE,OAAO,EAAED,KAAK,CAAC;IAC/C,MAAMzC,OAAO,GAAG,IAAI,CAACnC,aAAa,CAACoC,IAAI,CAAC;MACpCwC,KAAK;MACLE,SAAS,EAAErF,OAAO,CAACsF,SAAS,CAACC;IACjC,CAAC,CAAC;IACF,OAAO,IAAIzG,KAAK,CAAC,IAAI,CAACwB,UAAU,EAAEoC,OAAO,CAAC;EAC9C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI8C,WAAWA,CAACL,KAAK,EAAE;IACf,CAAC,CAAC,EAAEpF,UAAU,CAACqF,eAAe,EAAE,aAAa,EAAED,KAAK,CAAC;IACrD,MAAMzC,OAAO,GAAG,IAAI,CAACnC,aAAa,CAACoC,IAAI,CAAC;MAAEwC,KAAK;MAAEE,SAAS,EAAErF,OAAO,CAACsF,SAAS,CAACG;IAAK,CAAC,CAAC;IACrF,OAAO,IAAI3G,KAAK,CAAC,IAAI,CAACwB,UAAU,EAAEoC,OAAO,CAAC;EAC9C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIgD,MAAMA,CAACA,MAAM,EAAE;IACX,CAAC,CAAC,EAAE3F,UAAU,CAACqF,eAAe,EAAE,QAAQ,EAAEM,MAAM,CAAC;IACjD,MAAMhD,OAAO,GAAG,IAAI,CAACnC,aAAa,CAACoC,IAAI,CAAC;MAAE+C;IAAO,CAAC,CAAC;IACnD,OAAO,IAAI5G,KAAK,CAAC,IAAI,CAACwB,UAAU,EAAEoC,OAAO,CAAC;EAC9C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIiD,KAAKA,CAAA,EAAG;IACJ,OAAO,IAAI,CAACC,SAAS,CAAC;MAClBD,KAAK,EAAEzG,OAAO,CAAC2G,cAAc,CAACF,KAAK,CAAC;IACxC,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,SAASA,CAACE,aAAa,EAAE;IACrB,OAAO,IAAI7F,iBAAiB,CAAC8F,cAAc,CAAC,IAAI,EAAED,aAAa,CAAC;EACpE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}