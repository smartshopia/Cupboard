{"ast":null,"code":"\"use strict\";\n\nmodule.exports = encoder;\nvar Enum = require(\"./enum\"),\n  types = require(\"./types\"),\n  util = require(\"./util\");\n\n/**\r\n * Generates a partial message type encoder.\r\n * @param {Codegen} gen Codegen instance\r\n * @param {Field} field Reflected field\r\n * @param {number} fieldIndex Field index\r\n * @param {string} ref Variable reference\r\n * @returns {Codegen} Codegen instance\r\n * @ignore\r\n */\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n  return field.resolvedType.group ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n\n/**\r\n * Generates an encoder specific to the specified message type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\nfunction encoder(mtype) {\n  /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n  var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")(\"if(!w)\")(\"w=Writer.create()\");\n  var i, ref;\n\n  // \"when a message is serialized its known fields should be written sequentially by field number\"\n  var fields = /* initializes */mtype.fieldsArray.slice().sort(util.compareFieldsById);\n  for (var i = 0; i < fields.length; ++i) {\n    var field = fields[i].resolve(),\n      index = mtype._fieldsArray.indexOf(field),\n      type = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n      wireType = types.basic[type];\n    ref = \"m\" + util.safeProp(field.name);\n\n    // Map fields\n    if (field.map) {\n      gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n      (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)(\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n      if (wireType === undefined) gen(\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n      else gen(\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n      gen(\"}\")(\"}\");\n\n      // Repeated fields\n    } else if (field.repeated) {\n      gen(\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n\n      // Packed repeated\n      if (field.packed && types.packed[type] !== undefined) {\n        gen(\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)(\"for(var i=0;i<%s.length;++i)\", ref)(\"w.%s(%s[i])\", type, ref)(\"w.ldelim()\");\n\n        // Non-packed\n      } else {\n        gen(\"for(var i=0;i<%s.length;++i)\", ref);\n        if (wireType === undefined) genTypePartial(gen, field, index, ref + \"[i]\");else gen(\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n      }\n      gen(\"}\");\n\n      // Non-repeated\n    } else {\n      if (field.optional) gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n      if (wireType === undefined) genTypePartial(gen, field, index, ref);else gen(\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n    }\n  }\n  return gen(\"return w\");\n  /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}","map":{"version":3,"names":["module","exports","encoder","Enum","require","types","util","genTypePartial","gen","field","fieldIndex","ref","resolvedType","group","id","mtype","codegen","name","i","fields","fieldsArray","slice","sort","compareFieldsById","length","resolve","index","_fieldsArray","indexOf","type","wireType","basic","safeProp","map","mapKey","keyType","undefined","repeated","packed","optional"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/protobufjs/src/encoder.js"],"sourcesContent":["\"use strict\";\r\nmodule.exports = encoder;\r\n\r\nvar Enum     = require(\"./enum\"),\r\n    types    = require(\"./types\"),\r\n    util     = require(\"./util\");\r\n\r\n/**\r\n * Generates a partial message type encoder.\r\n * @param {Codegen} gen Codegen instance\r\n * @param {Field} field Reflected field\r\n * @param {number} fieldIndex Field index\r\n * @param {string} ref Variable reference\r\n * @returns {Codegen} Codegen instance\r\n * @ignore\r\n */\r\nfunction genTypePartial(gen, field, fieldIndex, ref) {\r\n    return field.resolvedType.group\r\n        ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)\r\n        : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\r\n}\r\n\r\n/**\r\n * Generates an encoder specific to the specified message type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\r\nfunction encoder(mtype) {\r\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n    var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")\r\n    (\"if(!w)\")\r\n        (\"w=Writer.create()\");\r\n\r\n    var i, ref;\r\n\r\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\r\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\r\n\r\n    for (var i = 0; i < fields.length; ++i) {\r\n        var field    = fields[i].resolve(),\r\n            index    = mtype._fieldsArray.indexOf(field),\r\n            type     = field.resolvedType instanceof Enum ? \"int32\" : field.type,\r\n            wireType = types.basic[type];\r\n            ref      = \"m\" + util.safeProp(field.name);\r\n\r\n        // Map fields\r\n        if (field.map) {\r\n            gen\r\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\r\n        (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)\r\n            (\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\r\n            if (wireType === undefined) gen\r\n            (\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\r\n            else gen\r\n            (\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\r\n            gen\r\n        (\"}\")\r\n    (\"}\");\r\n\r\n            // Repeated fields\r\n        } else if (field.repeated) { gen\r\n    (\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\r\n\r\n            // Packed repeated\r\n            if (field.packed && types.packed[type] !== undefined) { gen\r\n\r\n        (\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)\r\n        (\"for(var i=0;i<%s.length;++i)\", ref)\r\n            (\"w.%s(%s[i])\", type, ref)\r\n        (\"w.ldelim()\");\r\n\r\n            // Non-packed\r\n            } else { gen\r\n\r\n        (\"for(var i=0;i<%s.length;++i)\", ref);\r\n                if (wireType === undefined)\r\n            genTypePartial(gen, field, index, ref + \"[i]\");\r\n                else gen\r\n            (\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\r\n\r\n            } gen\r\n    (\"}\");\r\n\r\n        // Non-repeated\r\n        } else {\r\n            if (field.optional) gen\r\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\r\n\r\n            if (wireType === undefined)\r\n        genTypePartial(gen, field, index, ref);\r\n            else gen\r\n        (\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\r\n\r\n        }\r\n    }\r\n\r\n    return gen\r\n    (\"return w\");\r\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}