{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events').EventEmitter;\nconst inherits = require('node:util').inherits;\nconst getLimit = require('../../../lib/utils/getLimit');\nconst StreamSearch = require('../../streamsearch/sbmh');\nconst B_DCRLF = Buffer.from('\\r\\n\\r\\n');\nconst RE_CRLF = /\\r\\n/g;\nconst RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/; // eslint-disable-line no-control-regex\n\nfunction HeaderParser(cfg) {\n  EventEmitter.call(this);\n  cfg = cfg || {};\n  const self = this;\n  this.nread = 0;\n  this.maxed = false;\n  this.npairs = 0;\n  this.maxHeaderPairs = getLimit(cfg, 'maxHeaderPairs', 2000);\n  this.maxHeaderSize = getLimit(cfg, 'maxHeaderSize', 80 * 1024);\n  this.buffer = '';\n  this.header = {};\n  this.finished = false;\n  this.ss = new StreamSearch(B_DCRLF);\n  this.ss.on('info', function (isMatch, data, start, end) {\n    if (data && !self.maxed) {\n      if (self.nread + end - start >= self.maxHeaderSize) {\n        end = self.maxHeaderSize - self.nread + start;\n        self.nread = self.maxHeaderSize;\n        self.maxed = true;\n      } else {\n        self.nread += end - start;\n      }\n      self.buffer += data.toString('binary', start, end);\n    }\n    if (isMatch) {\n      self._finish();\n    }\n  });\n}\ninherits(HeaderParser, EventEmitter);\nHeaderParser.prototype.push = function (data) {\n  const r = this.ss.push(data);\n  if (this.finished) {\n    return r;\n  }\n};\nHeaderParser.prototype.reset = function () {\n  this.finished = false;\n  this.buffer = '';\n  this.header = {};\n  this.ss.reset();\n};\nHeaderParser.prototype._finish = function () {\n  if (this.buffer) {\n    this._parseHeader();\n  }\n  this.ss.matches = this.ss.maxMatches;\n  const header = this.header;\n  this.header = {};\n  this.buffer = '';\n  this.finished = true;\n  this.nread = this.npairs = 0;\n  this.maxed = false;\n  this.emit('header', header);\n};\nHeaderParser.prototype._parseHeader = function () {\n  if (this.npairs === this.maxHeaderPairs) {\n    return;\n  }\n  const lines = this.buffer.split(RE_CRLF);\n  const len = lines.length;\n  let m, h;\n  for (var i = 0; i < len; ++i) {\n    // eslint-disable-line no-var\n    if (lines[i].length === 0) {\n      continue;\n    }\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      // folded header content\n      // RFC2822 says to just remove the CRLF and not the whitespace following\n      // it, so we follow the RFC and include the leading whitespace ...\n      if (h) {\n        this.header[h][this.header[h].length - 1] += lines[i];\n        continue;\n      }\n    }\n    const posColon = lines[i].indexOf(':');\n    if (posColon === -1 || posColon === 0) {\n      return;\n    }\n    m = RE_HDR.exec(lines[i]);\n    h = m[1].toLowerCase();\n    this.header[h] = this.header[h] || [];\n    this.header[h].push(m[2] || '');\n    if (++this.npairs === this.maxHeaderPairs) {\n      break;\n    }\n  }\n};\nmodule.exports = HeaderParser;","map":{"version":3,"names":["EventEmitter","require","inherits","getLimit","StreamSearch","B_DCRLF","Buffer","from","RE_CRLF","RE_HDR","HeaderParser","cfg","call","self","nread","maxed","npairs","maxHeaderPairs","maxHeaderSize","buffer","header","finished","ss","on","isMatch","data","start","end","toString","_finish","prototype","push","r","reset","_parseHeader","matches","maxMatches","emit","lines","split","len","length","m","h","i","posColon","indexOf","exec","toLowerCase","module","exports"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"],"sourcesContent":["'use strict'\n\nconst EventEmitter = require('node:events').EventEmitter\nconst inherits = require('node:util').inherits\nconst getLimit = require('../../../lib/utils/getLimit')\n\nconst StreamSearch = require('../../streamsearch/sbmh')\n\nconst B_DCRLF = Buffer.from('\\r\\n\\r\\n')\nconst RE_CRLF = /\\r\\n/g\nconst RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/ // eslint-disable-line no-control-regex\n\nfunction HeaderParser (cfg) {\n  EventEmitter.call(this)\n\n  cfg = cfg || {}\n  const self = this\n  this.nread = 0\n  this.maxed = false\n  this.npairs = 0\n  this.maxHeaderPairs = getLimit(cfg, 'maxHeaderPairs', 2000)\n  this.maxHeaderSize = getLimit(cfg, 'maxHeaderSize', 80 * 1024)\n  this.buffer = ''\n  this.header = {}\n  this.finished = false\n  this.ss = new StreamSearch(B_DCRLF)\n  this.ss.on('info', function (isMatch, data, start, end) {\n    if (data && !self.maxed) {\n      if (self.nread + end - start >= self.maxHeaderSize) {\n        end = self.maxHeaderSize - self.nread + start\n        self.nread = self.maxHeaderSize\n        self.maxed = true\n      } else { self.nread += (end - start) }\n\n      self.buffer += data.toString('binary', start, end)\n    }\n    if (isMatch) { self._finish() }\n  })\n}\ninherits(HeaderParser, EventEmitter)\n\nHeaderParser.prototype.push = function (data) {\n  const r = this.ss.push(data)\n  if (this.finished) { return r }\n}\n\nHeaderParser.prototype.reset = function () {\n  this.finished = false\n  this.buffer = ''\n  this.header = {}\n  this.ss.reset()\n}\n\nHeaderParser.prototype._finish = function () {\n  if (this.buffer) { this._parseHeader() }\n  this.ss.matches = this.ss.maxMatches\n  const header = this.header\n  this.header = {}\n  this.buffer = ''\n  this.finished = true\n  this.nread = this.npairs = 0\n  this.maxed = false\n  this.emit('header', header)\n}\n\nHeaderParser.prototype._parseHeader = function () {\n  if (this.npairs === this.maxHeaderPairs) { return }\n\n  const lines = this.buffer.split(RE_CRLF)\n  const len = lines.length\n  let m, h\n\n  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var\n    if (lines[i].length === 0) { continue }\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      // folded header content\n      // RFC2822 says to just remove the CRLF and not the whitespace following\n      // it, so we follow the RFC and include the leading whitespace ...\n      if (h) {\n        this.header[h][this.header[h].length - 1] += lines[i]\n        continue\n      }\n    }\n\n    const posColon = lines[i].indexOf(':')\n    if (\n      posColon === -1 ||\n      posColon === 0\n    ) {\n      return\n    }\n    m = RE_HDR.exec(lines[i])\n    h = m[1].toLowerCase()\n    this.header[h] = this.header[h] || []\n    this.header[h].push((m[2] || ''))\n    if (++this.npairs === this.maxHeaderPairs) { break }\n  }\n}\n\nmodule.exports = HeaderParser\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}