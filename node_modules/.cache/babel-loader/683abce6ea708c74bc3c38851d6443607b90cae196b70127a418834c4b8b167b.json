{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PageDescriptor = void 0;\nconst stream_1 = require(\"stream\");\nconst normalApiCaller_1 = require(\"../normalCalls/normalApiCaller\");\nconst pagedApiCaller_1 = require(\"./pagedApiCaller\");\nconst maxAttemptsEmptyResponse = 10;\n/**\n * A descriptor for methods that support pagination.\n */\nclass PageDescriptor {\n  constructor(requestPageTokenField, responsePageTokenField, resourceField) {\n    this.requestPageTokenField = requestPageTokenField;\n    this.responsePageTokenField = responsePageTokenField;\n    this.resourceField = resourceField;\n  }\n  /**\n   * Creates a new object Stream which emits the resource on 'data' event.\n   */\n  createStream(apiCall, request, options) {\n    const stream = new stream_1.PassThrough({\n      objectMode: true\n    });\n    options = Object.assign({}, options, {\n      autoPaginate: false\n    });\n    const maxResults = 'maxResults' in options ? options.maxResults : -1;\n    let pushCount = 0;\n    let started = false;\n    function callback(err, resources, next, apiResp) {\n      if (err) {\n        stream.emit('error', err);\n        return;\n      }\n      // emit full api response with every page.\n      stream.emit('response', apiResp);\n      for (let i = 0; i < resources.length; ++i) {\n        // TODO: rewrite without accessing stream internals\n        if (stream._readableState.ended) {\n          return;\n        }\n        if (resources[i] === null) {\n          continue;\n        }\n        stream.push(resources[i]);\n        pushCount++;\n        if (pushCount === maxResults) {\n          stream.end();\n        }\n      }\n      // TODO: rewrite without accessing stream internals\n      if (stream._readableState.ended) {\n        return;\n      }\n      if (!next) {\n        stream.end();\n        return;\n      }\n      // When pageToken is specified in the original options, it will overwrite\n      // the page token field in the next request. Therefore it must be cleared.\n      if ('pageToken' in options) {\n        delete options.pageToken;\n      }\n      if (stream.isPaused()) {\n        request = next;\n        started = false;\n      } else {\n        setImmediate(apiCall, next, options, callback);\n      }\n    }\n    stream.on('resume', () => {\n      if (!started) {\n        started = true;\n        apiCall(request, options, callback);\n      }\n    });\n    return stream;\n  }\n  /**\n   * Create an async iterable which can be recursively called for data on-demand.\n   */\n  asyncIterate(apiCall, request, options) {\n    options = Object.assign({}, options, {\n      autoPaginate: false\n    });\n    const iterable = this.createIterator(apiCall, request, options);\n    return iterable;\n  }\n  createIterator(apiCall, request, options) {\n    const asyncIterable = {\n      [Symbol.asyncIterator]() {\n        let nextPageRequest = request;\n        const cache = [];\n        return {\n          async next() {\n            if (cache.length > 0) {\n              return Promise.resolve({\n                done: false,\n                value: cache.shift()\n              });\n            }\n            let attempts = 0;\n            while (cache.length === 0 && nextPageRequest) {\n              let result;\n              [result, nextPageRequest] = await apiCall(nextPageRequest, options);\n              // For pagination response with protobuf map type, use tuple as representation.\n              if (result && !Array.isArray(result)) {\n                for (const [key, value] of Object.entries(result)) {\n                  cache.push([key, value]);\n                }\n              } else {\n                cache.push(...result);\n              }\n              if (cache.length === 0) {\n                ++attempts;\n                if (attempts > maxAttemptsEmptyResponse) {\n                  break;\n                }\n              }\n            }\n            if (cache.length === 0) {\n              return Promise.resolve({\n                done: true,\n                value: undefined\n              });\n            }\n            return Promise.resolve({\n              done: false,\n              value: cache.shift()\n            });\n          }\n        };\n      }\n    };\n    return asyncIterable;\n  }\n  getApiCaller(settings) {\n    if (!settings.autoPaginate) {\n      return new normalApiCaller_1.NormalApiCaller();\n    }\n    return new pagedApiCaller_1.PagedApiCaller(this);\n  }\n}\nexports.PageDescriptor = PageDescriptor;","map":{"version":3,"names":["Object","defineProperty","exports","value","PageDescriptor","stream_1","require","normalApiCaller_1","pagedApiCaller_1","maxAttemptsEmptyResponse","constructor","requestPageTokenField","responsePageTokenField","resourceField","createStream","apiCall","request","options","stream","PassThrough","objectMode","assign","autoPaginate","maxResults","pushCount","started","callback","err","resources","next","apiResp","emit","i","length","_readableState","ended","push","end","pageToken","isPaused","setImmediate","on","asyncIterate","iterable","createIterator","asyncIterable","Symbol","asyncIterator","nextPageRequest","cache","Promise","resolve","done","shift","attempts","result","Array","isArray","key","entries","undefined","getApiCaller","settings","NormalApiCaller","PagedApiCaller"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/google-gax/build/src/paginationCalls/pageDescriptor.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PageDescriptor = void 0;\nconst stream_1 = require(\"stream\");\nconst normalApiCaller_1 = require(\"../normalCalls/normalApiCaller\");\nconst pagedApiCaller_1 = require(\"./pagedApiCaller\");\nconst maxAttemptsEmptyResponse = 10;\n/**\n * A descriptor for methods that support pagination.\n */\nclass PageDescriptor {\n    constructor(requestPageTokenField, responsePageTokenField, resourceField) {\n        this.requestPageTokenField = requestPageTokenField;\n        this.responsePageTokenField = responsePageTokenField;\n        this.resourceField = resourceField;\n    }\n    /**\n     * Creates a new object Stream which emits the resource on 'data' event.\n     */\n    createStream(apiCall, request, options) {\n        const stream = new stream_1.PassThrough({ objectMode: true });\n        options = Object.assign({}, options, { autoPaginate: false });\n        const maxResults = 'maxResults' in options ? options.maxResults : -1;\n        let pushCount = 0;\n        let started = false;\n        function callback(err, resources, next, apiResp) {\n            if (err) {\n                stream.emit('error', err);\n                return;\n            }\n            // emit full api response with every page.\n            stream.emit('response', apiResp);\n            for (let i = 0; i < resources.length; ++i) {\n                // TODO: rewrite without accessing stream internals\n                if (stream\n                    ._readableState.ended) {\n                    return;\n                }\n                if (resources[i] === null) {\n                    continue;\n                }\n                stream.push(resources[i]);\n                pushCount++;\n                if (pushCount === maxResults) {\n                    stream.end();\n                }\n            }\n            // TODO: rewrite without accessing stream internals\n            if (stream._readableState\n                .ended) {\n                return;\n            }\n            if (!next) {\n                stream.end();\n                return;\n            }\n            // When pageToken is specified in the original options, it will overwrite\n            // the page token field in the next request. Therefore it must be cleared.\n            if ('pageToken' in options) {\n                delete options.pageToken;\n            }\n            if (stream.isPaused()) {\n                request = next;\n                started = false;\n            }\n            else {\n                setImmediate(apiCall, next, options, callback);\n            }\n        }\n        stream.on('resume', () => {\n            if (!started) {\n                started = true;\n                apiCall(request, options, callback);\n            }\n        });\n        return stream;\n    }\n    /**\n     * Create an async iterable which can be recursively called for data on-demand.\n     */\n    asyncIterate(apiCall, request, options) {\n        options = Object.assign({}, options, { autoPaginate: false });\n        const iterable = this.createIterator(apiCall, request, options);\n        return iterable;\n    }\n    createIterator(apiCall, request, options) {\n        const asyncIterable = {\n            [Symbol.asyncIterator]() {\n                let nextPageRequest = request;\n                const cache = [];\n                return {\n                    async next() {\n                        if (cache.length > 0) {\n                            return Promise.resolve({\n                                done: false,\n                                value: cache.shift(),\n                            });\n                        }\n                        let attempts = 0;\n                        while (cache.length === 0 && nextPageRequest) {\n                            let result;\n                            [result, nextPageRequest] = (await apiCall(nextPageRequest, options));\n                            // For pagination response with protobuf map type, use tuple as representation.\n                            if (result && !Array.isArray(result)) {\n                                for (const [key, value] of Object.entries(result)) {\n                                    cache.push([key, value]);\n                                }\n                            }\n                            else {\n                                cache.push(...result);\n                            }\n                            if (cache.length === 0) {\n                                ++attempts;\n                                if (attempts > maxAttemptsEmptyResponse) {\n                                    break;\n                                }\n                            }\n                        }\n                        if (cache.length === 0) {\n                            return Promise.resolve({ done: true, value: undefined });\n                        }\n                        return Promise.resolve({ done: false, value: cache.shift() });\n                    },\n                };\n            },\n        };\n        return asyncIterable;\n    }\n    getApiCaller(settings) {\n        if (!settings.autoPaginate) {\n            return new normalApiCaller_1.NormalApiCaller();\n        }\n        return new pagedApiCaller_1.PagedApiCaller(this);\n    }\n}\nexports.PageDescriptor = PageDescriptor;\n//# sourceMappingURL=pageDescriptor.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}