{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryWatch = exports.DocumentWatch = exports.WATCH_IDLE_TIMEOUT_MS = void 0;\nconst assert = require(\"assert\");\nconst rbtree = require(\"functional-red-black-tree\");\nconst google_gax_1 = require(\"google-gax\");\nconst backoff_1 = require(\"./backoff\");\nconst document_1 = require(\"./document\");\nconst document_change_1 = require(\"./document-change\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst timestamp_1 = require(\"./timestamp\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n * @type {number}\n */\nconst WATCH_TARGET_ID = 0x1;\n/*!\n * Idle timeout used to detect Watch streams that stall (see\n * https://github.com/googleapis/nodejs-firestore/issues/1057, b/156308554).\n * Under normal load, the Watch backend will send a TARGET_CHANGE message\n * roughly every 30 seconds. As discussed with the backend team, we reset the\n * Watch stream if we do not receive any message within 120 seconds.\n */\nexports.WATCH_IDLE_TIMEOUT_MS = 120 * 1000;\n/*!\n * Sentinel value for a document remove.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst REMOVED = {};\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\nconst ChangeType = {\n  added: 'added',\n  modified: 'modified',\n  removed: 'removed'\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\nconst DOCUMENT_WATCH_COMPARATOR = (doc1, doc2) => {\n  assert(doc1 === doc2, 'Document watches only support one document.');\n  return 0;\n};\nconst EMPTY_FUNCTION = () => {};\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n * @internal\n */\nclass Watch {\n  /**\n   * @private\n   * @internal\n   *\n   * @param firestore The Firestore Database client.\n   */\n  constructor(firestore, _converter = (0, types_1.defaultConverter)()) {\n    this._converter = _converter;\n    /**\n     * Indicates whether we are interested in data from the stream. Set to false in the\n     * 'unsubscribe()' callback.\n     * @private\n     * @internal\n     */\n    this.isActive = true;\n    /**\n     * The current stream to the backend.\n     * @private\n     * @internal\n     */\n    this.currentStream = null;\n    /**\n     * The server assigns and updates the resume token.\n     * @private\n     * @internal\n     */\n    this.resumeToken = undefined;\n    /**\n     * A map of document names to QueryDocumentSnapshots for the last sent snapshot.\n     * @private\n     * @internal\n     */\n    this.docMap = new Map();\n    /**\n     * The accumulated map of document changes (keyed by document name) for the\n     * current snapshot.\n     * @private\n     * @internal\n     */\n    this.changeMap = new Map();\n    /**\n     * The current state of the query results. *\n     * @private\n     * @internal\n     */\n    this.current = false;\n    /**\n     * We need this to track whether we've pushed an initial set of changes,\n     * since we should push those even when there are no changes, if there\n     * aren't docs.\n     * @private\n     * @internal\n     */\n    this.hasPushed = false;\n    this.firestore = firestore;\n    this.backoff = new backoff_1.ExponentialBackoff();\n    this.requestTag = (0, util_1.requestTag)();\n    this.onNext = EMPTY_FUNCTION;\n    this.onError = EMPTY_FUNCTION;\n  }\n  /**\n   * Starts a watch and attaches a listener for document change events.\n   *\n   * @private\n   * @internal\n   * @param onNext A callback to be called every time a new snapshot is\n   * available.\n   * @param onError A callback to be called if the listen fails or is cancelled.\n   * No further callbacks will occur.\n   *\n   * @returns An unsubscribe function that can be called to cancel the snapshot\n   * listener.\n   */\n  onSnapshot(onNext, onError) {\n    assert(this.onNext === EMPTY_FUNCTION, 'onNext should not already be defined.');\n    assert(this.onError === EMPTY_FUNCTION, 'onError should not already be defined.');\n    assert(this.docTree === undefined, 'docTree should not already be defined.');\n    this.onNext = onNext;\n    this.onError = onError;\n    this.docTree = rbtree(this.getComparator());\n    this.initStream();\n    const unsubscribe = () => {\n      (0, logger_1.logger)('Watch.onSnapshot', this.requestTag, 'Unsubscribe called');\n      // Prevent further callbacks.\n      this.onNext = () => {};\n      this.onError = () => {};\n      this.shutdown();\n    };\n    this.firestore.registerListener();\n    return unsubscribe;\n  }\n  /**\n   * Returns the current count of all documents, including the changes from\n   * the current changeMap.\n   * @private\n   * @internal\n   */\n  currentSize() {\n    const changes = this.extractCurrentChanges(timestamp_1.Timestamp.now());\n    return this.docMap.size + changes.adds.length - changes.deletes.length;\n  }\n  /**\n   * Splits up document changes into removals, additions, and updates.\n   * @private\n   * @internal\n   */\n  extractCurrentChanges(readTime) {\n    const deletes = [];\n    const adds = [];\n    const updates = [];\n    this.changeMap.forEach((value, name) => {\n      if (value === REMOVED) {\n        if (this.docMap.has(name)) {\n          deletes.push(name);\n        }\n      } else if (this.docMap.has(name)) {\n        value.readTime = readTime;\n        updates.push(value.build());\n      } else {\n        value.readTime = readTime;\n        adds.push(value.build());\n      }\n    });\n    return {\n      deletes,\n      adds,\n      updates\n    };\n  }\n  /**\n   * Helper to clear the docs on RESET or filter mismatch.\n   * @private\n   * @internal\n   */\n  resetDocs() {\n    (0, logger_1.logger)('Watch.resetDocs', this.requestTag, 'Resetting documents');\n    this.changeMap.clear();\n    this.resumeToken = undefined;\n    this.docTree.forEach(snapshot => {\n      // Mark each document as deleted. If documents are not deleted, they\n      // will be send again by the server.\n      this.changeMap.set(snapshot.ref.path, REMOVED);\n    });\n    this.current = false;\n  }\n  /**\n   * Closes the stream and calls onError() if the stream is still active.\n   * @private\n   * @internal\n   */\n  closeStream(err) {\n    if (this.isActive) {\n      (0, logger_1.logger)('Watch.closeStream', this.requestTag, 'Invoking onError: ', err);\n      this.onError(err);\n    }\n    this.shutdown();\n  }\n  /**\n   * Re-opens the stream unless the specified error is considered permanent.\n   * Clears the change map.\n   * @private\n   * @internal\n   */\n  maybeReopenStream(err) {\n    if (this.isActive && !this.isPermanentWatchError(err)) {\n      (0, logger_1.logger)('Watch.maybeReopenStream', this.requestTag, 'Stream ended, re-opening after retryable error:', err);\n      this.changeMap.clear();\n      if (this.isResourceExhaustedError(err)) {\n        this.backoff.resetToMax();\n      }\n      this.initStream();\n    } else {\n      this.closeStream(err);\n    }\n  }\n  /**\n   * Cancels the current idle timeout and reschedules a new timer.\n   *\n   * @private\n   * @internal\n   */\n  resetIdleTimeout() {\n    if (this.idleTimeoutHandle) {\n      clearTimeout(this.idleTimeoutHandle);\n    }\n    this.idleTimeoutHandle = (0, backoff_1.delayExecution)(() => {\n      var _a;\n      (0, logger_1.logger)('Watch.resetIdleTimeout', this.requestTag, 'Resetting stream after idle timeout');\n      (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n      this.currentStream = null;\n      const error = new google_gax_1.GoogleError('Watch stream idle timeout');\n      error.code = google_gax_1.Status.UNKNOWN;\n      this.maybeReopenStream(error);\n    }, exports.WATCH_IDLE_TIMEOUT_MS);\n  }\n  /**\n   * Helper to restart the outgoing stream to the backend.\n   * @private\n   * @internal\n   */\n  resetStream() {\n    (0, logger_1.logger)('Watch.resetStream', this.requestTag, 'Restarting stream');\n    if (this.currentStream) {\n      this.currentStream.end();\n      this.currentStream = null;\n    }\n    this.initStream();\n  }\n  /**\n   * Initializes a new stream to the backend with backoff.\n   * @private\n   * @internal\n   */\n  initStream() {\n    this.backoff.backoffAndWait().then(async () => {\n      if (!this.isActive) {\n        (0, logger_1.logger)('Watch.initStream', this.requestTag, 'Not initializing inactive stream');\n        return;\n      }\n      await this.firestore.initializeIfNeeded(this.requestTag);\n      const request = {};\n      request.database = this.firestore.formattedName;\n      request.addTarget = this.getTarget(this.resumeToken);\n      // Note that we need to call the internal _listen API to pass additional\n      // header values in readWriteStream.\n      return this.firestore.requestStream('listen', /* bidirectional= */true, request, this.requestTag).then(backendStream => {\n        if (!this.isActive) {\n          (0, logger_1.logger)('Watch.initStream', this.requestTag, 'Closing inactive stream');\n          backendStream.emit('end');\n          return;\n        }\n        (0, logger_1.logger)('Watch.initStream', this.requestTag, 'Opened new stream');\n        this.currentStream = backendStream;\n        this.resetIdleTimeout();\n        this.currentStream.on('data', proto => {\n          this.resetIdleTimeout();\n          this.onData(proto);\n        }).on('error', err => {\n          if (this.currentStream === backendStream) {\n            this.currentStream = null;\n            this.maybeReopenStream(err);\n          }\n        }).on('end', () => {\n          if (this.currentStream === backendStream) {\n            this.currentStream = null;\n            const err = new google_gax_1.GoogleError('Stream ended unexpectedly');\n            err.code = google_gax_1.Status.UNKNOWN;\n            this.maybeReopenStream(err);\n          }\n        });\n        this.currentStream.resume();\n      });\n    }).catch(err => {\n      this.closeStream(err);\n    });\n  }\n  /**\n   * Handles 'data' events and closes the stream if the response type is\n   * invalid.\n   * @private\n   * @internal\n   */\n  onData(proto) {\n    if (proto.targetChange) {\n      (0, logger_1.logger)('Watch.onData', this.requestTag, 'Processing target change');\n      const change = proto.targetChange;\n      const noTargetIds = !change.targetIds || change.targetIds.length === 0;\n      if (change.targetChangeType === 'NO_CHANGE') {\n        if (noTargetIds && change.readTime && this.current) {\n          // This means everything is up-to-date, so emit the current\n          // set of docs as a snapshot, if there were changes.\n          this.pushSnapshot(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n        }\n      } else if (change.targetChangeType === 'ADD') {\n        if (WATCH_TARGET_ID !== change.targetIds[0]) {\n          this.closeStream(Error('Unexpected target ID sent by server'));\n        }\n      } else if (change.targetChangeType === 'REMOVE') {\n        let code = google_gax_1.Status.INTERNAL;\n        let message = 'internal error';\n        if (change.cause) {\n          code = change.cause.code;\n          message = change.cause.message;\n        }\n        // @todo: Surface a .code property on the exception.\n        this.closeStream(new Error('Error ' + code + ': ' + message));\n      } else if (change.targetChangeType === 'RESET') {\n        // Whatever changes have happened so far no longer matter.\n        this.resetDocs();\n      } else if (change.targetChangeType === 'CURRENT') {\n        this.current = true;\n      } else {\n        this.closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n      }\n      if (change.resumeToken && this.affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n        this.backoff.reset();\n      }\n    } else if (proto.documentChange) {\n      (0, logger_1.logger)('Watch.onData', this.requestTag, 'Processing change event');\n      // No other targetIds can show up here, but we still need to see\n      // if the targetId was in the added list or removed list.\n      const targetIds = proto.documentChange.targetIds || [];\n      const removedTargetIds = proto.documentChange.removedTargetIds || [];\n      let changed = false;\n      let removed = false;\n      for (let i = 0; i < targetIds.length; i++) {\n        if (targetIds[i] === WATCH_TARGET_ID) {\n          changed = true;\n        }\n      }\n      for (let i = 0; i < removedTargetIds.length; i++) {\n        if (removedTargetIds[i] === WATCH_TARGET_ID) {\n          removed = true;\n        }\n      }\n      const document = proto.documentChange.document;\n      const name = document.name;\n      const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n      if (changed) {\n        (0, logger_1.logger)('Watch.onData', this.requestTag, 'Received document change');\n        const ref = this.firestore.doc(relativeName);\n        const snapshot = new document_1.DocumentSnapshotBuilder(ref.withConverter(this._converter));\n        snapshot.fieldsProto = document.fields || {};\n        snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n        snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n        this.changeMap.set(relativeName, snapshot);\n      } else if (removed) {\n        (0, logger_1.logger)('Watch.onData', this.requestTag, 'Received document remove');\n        this.changeMap.set(relativeName, REMOVED);\n      }\n    } else if (proto.documentDelete || proto.documentRemove) {\n      (0, logger_1.logger)('Watch.onData', this.requestTag, 'Processing remove event');\n      const name = (proto.documentDelete || proto.documentRemove).document;\n      const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n      this.changeMap.set(relativeName, REMOVED);\n    } else if (proto.filter) {\n      (0, logger_1.logger)('Watch.onData', this.requestTag, 'Processing filter update');\n      if (proto.filter.count !== this.currentSize()) {\n        // We need to remove all the current results.\n        this.resetDocs();\n        // The filter didn't match, so re-issue the query.\n        this.resetStream();\n      }\n    } else {\n      this.closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n    }\n  }\n  /**\n   * Checks if the current target id is included in the list of target ids.\n   * If no targetIds are provided, returns true.\n   * @private\n   * @internal\n   */\n  affectsTarget(targetIds, currentId) {\n    if (targetIds === undefined || targetIds.length === 0) {\n      return true;\n    }\n    for (const targetId of targetIds) {\n      if (targetId === currentId) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Assembles a new snapshot from the current set of changes and invokes the\n   * user's callback. Clears the current changes on completion.\n   * @private\n   * @internal\n   */\n  pushSnapshot(readTime, nextResumeToken) {\n    const appliedChanges = this.computeSnapshot(readTime);\n    if (!this.hasPushed || appliedChanges.length > 0) {\n      (0, logger_1.logger)('Watch.pushSnapshot', this.requestTag, 'Sending snapshot with %d changes and %d documents', String(appliedChanges.length), this.docTree.length);\n      // We pass the current set of changes, even if `docTree` is modified later.\n      const currentTree = this.docTree;\n      this.onNext(readTime, currentTree.length, () => currentTree.keys, () => appliedChanges);\n      this.hasPushed = true;\n    }\n    this.changeMap.clear();\n    this.resumeToken = nextResumeToken;\n  }\n  /**\n   * Applies a document delete to the document tree and the document map.\n   * Returns the corresponding DocumentChange event.\n   * @private\n   * @internal\n   */\n  deleteDoc(name) {\n    assert(this.docMap.has(name), 'Document to delete does not exist');\n    const oldDocument = this.docMap.get(name);\n    const existing = this.docTree.find(oldDocument);\n    const oldIndex = existing.index;\n    this.docTree = existing.remove();\n    this.docMap.delete(name);\n    return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n  }\n  /**\n   * Applies a document add to the document tree and the document map. Returns\n   * the corresponding DocumentChange event.\n   * @private\n   * @internal\n   */\n  addDoc(newDocument) {\n    const name = newDocument.ref.path;\n    assert(!this.docMap.has(name), 'Document to add already exists');\n    this.docTree = this.docTree.insert(newDocument, null);\n    const newIndex = this.docTree.find(newDocument).index;\n    this.docMap.set(name, newDocument);\n    return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n  }\n  /**\n   * Applies a document modification to the document tree and the document map.\n   * Returns the DocumentChange event for successful modifications.\n   * @private\n   * @internal\n   */\n  modifyDoc(newDocument) {\n    const name = newDocument.ref.path;\n    assert(this.docMap.has(name), 'Document to modify does not exist');\n    const oldDocument = this.docMap.get(name);\n    if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n      const removeChange = this.deleteDoc(name);\n      const addChange = this.addDoc(newDocument);\n      return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n    }\n    return null;\n  }\n  /**\n   * Applies the mutations in changeMap to both the document tree and the\n   * document lookup map. Modified docMap in-place and returns the updated\n   * state.\n   * @private\n   * @internal\n   */\n  computeSnapshot(readTime) {\n    const changeSet = this.extractCurrentChanges(readTime);\n    const appliedChanges = [];\n    // Process the sorted changes in the order that is expected by our clients\n    // (removals, additions, and then modifications). We also need to sort the\n    // individual changes to assure that oldIndex/newIndex keep incrementing.\n    changeSet.deletes.sort((name1, name2) => {\n      // Deletes are sorted based on the order of the existing document.\n      return this.getComparator()(this.docMap.get(name1), this.docMap.get(name2));\n    });\n    changeSet.deletes.forEach(name => {\n      const change = this.deleteDoc(name);\n      appliedChanges.push(change);\n    });\n    changeSet.adds.sort(this.getComparator());\n    changeSet.adds.forEach(snapshot => {\n      const change = this.addDoc(snapshot);\n      appliedChanges.push(change);\n    });\n    changeSet.updates.sort(this.getComparator());\n    changeSet.updates.forEach(snapshot => {\n      const change = this.modifyDoc(snapshot);\n      if (change) {\n        appliedChanges.push(change);\n      }\n    });\n    assert(this.docTree.length === this.docMap.size, 'The update document ' + 'tree and document map should have the same number of entries.');\n    return appliedChanges;\n  }\n  /**\n   * Determines whether a watch error is considered permanent and should not be\n   * retried. Errors that don't provide a GRPC error code are always considered\n   * transient in this context.\n   *\n   * @private\n   * @internal\n   * @param error An error object.\n   * @return Whether the error is permanent.\n   */\n  isPermanentWatchError(error) {\n    if (error.code === undefined) {\n      (0, logger_1.logger)('Watch.isPermanentError', this.requestTag, 'Unable to determine error code: ', error);\n      return false;\n    }\n    switch (error.code) {\n      case google_gax_1.Status.ABORTED:\n      case google_gax_1.Status.CANCELLED:\n      case google_gax_1.Status.UNKNOWN:\n      case google_gax_1.Status.DEADLINE_EXCEEDED:\n      case google_gax_1.Status.RESOURCE_EXHAUSTED:\n      case google_gax_1.Status.INTERNAL:\n      case google_gax_1.Status.UNAVAILABLE:\n      case google_gax_1.Status.UNAUTHENTICATED:\n        return false;\n      default:\n        return true;\n    }\n  }\n  /**\n   * Determines whether we need to initiate a longer backoff due to system\n   * overload.\n   *\n   * @private\n   * @internal\n   * @param error A GRPC Error object that exposes an error code.\n   * @return Whether we need to back off our retries.\n   */\n  isResourceExhaustedError(error) {\n    return error.code === google_gax_1.Status.RESOURCE_EXHAUSTED;\n  }\n  /** Closes the stream and clears all timeouts. */\n  shutdown() {\n    var _a;\n    if (this.isActive) {\n      this.isActive = false;\n      if (this.idleTimeoutHandle) {\n        clearTimeout(this.idleTimeoutHandle);\n        this.idleTimeoutHandle = undefined;\n      }\n      this.firestore.unregisterListener();\n    }\n    (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n    this.currentStream = null;\n  }\n}\n/**\n * Creates a new Watch instance to listen on DocumentReferences.\n *\n * @private\n * @internal\n */\nclass DocumentWatch extends Watch {\n  constructor(firestore, ref) {\n    super(firestore, ref._converter);\n    this.ref = ref;\n  }\n  getComparator() {\n    return DOCUMENT_WATCH_COMPARATOR;\n  }\n  getTarget(resumeToken) {\n    const formattedName = this.ref.formattedName;\n    return {\n      documents: {\n        documents: [formattedName]\n      },\n      targetId: WATCH_TARGET_ID,\n      resumeToken\n    };\n  }\n}\nexports.DocumentWatch = DocumentWatch;\n/**\n * Creates a new Watch instance to listen on Queries.\n *\n * @private\n * @internal\n */\nclass QueryWatch extends Watch {\n  constructor(firestore, query, converter) {\n    super(firestore, converter);\n    this.query = query;\n    this.comparator = query.comparator();\n  }\n  getComparator() {\n    return this.query.comparator();\n  }\n  getTarget(resumeToken) {\n    const query = this.query.toProto();\n    return {\n      query,\n      targetId: WATCH_TARGET_ID,\n      resumeToken\n    };\n  }\n}\nexports.QueryWatch = QueryWatch;","map":{"version":3,"names":["Object","defineProperty","exports","value","QueryWatch","DocumentWatch","WATCH_IDLE_TIMEOUT_MS","assert","require","rbtree","google_gax_1","backoff_1","document_1","document_change_1","logger_1","path_1","timestamp_1","types_1","util_1","WATCH_TARGET_ID","REMOVED","ChangeType","added","modified","removed","DOCUMENT_WATCH_COMPARATOR","doc1","doc2","EMPTY_FUNCTION","Watch","constructor","firestore","_converter","defaultConverter","isActive","currentStream","resumeToken","undefined","docMap","Map","changeMap","current","hasPushed","backoff","ExponentialBackoff","requestTag","onNext","onError","onSnapshot","docTree","getComparator","initStream","unsubscribe","logger","shutdown","registerListener","currentSize","changes","extractCurrentChanges","Timestamp","now","size","adds","length","deletes","readTime","updates","forEach","name","has","push","build","resetDocs","clear","snapshot","set","ref","path","closeStream","err","maybeReopenStream","isPermanentWatchError","isResourceExhaustedError","resetToMax","resetIdleTimeout","idleTimeoutHandle","clearTimeout","delayExecution","_a","end","error","GoogleError","code","Status","UNKNOWN","resetStream","backoffAndWait","then","initializeIfNeeded","request","database","formattedName","addTarget","getTarget","requestStream","backendStream","emit","on","proto","onData","resume","catch","targetChange","change","noTargetIds","targetIds","targetChangeType","pushSnapshot","fromProto","Error","INTERNAL","message","cause","JSON","stringify","affectsTarget","reset","documentChange","removedTargetIds","changed","i","document","relativeName","QualifiedResourcePath","fromSlashSeparatedString","doc","DocumentSnapshotBuilder","withConverter","fieldsProto","fields","createTime","updateTime","documentDelete","documentRemove","filter","count","currentId","targetId","nextResumeToken","appliedChanges","computeSnapshot","String","currentTree","keys","deleteDoc","oldDocument","get","existing","find","oldIndex","index","remove","delete","DocumentChange","addDoc","newDocument","insert","newIndex","modifyDoc","isEqual","removeChange","addChange","changeSet","sort","name1","name2","ABORTED","CANCELLED","DEADLINE_EXCEEDED","RESOURCE_EXHAUSTED","UNAVAILABLE","UNAUTHENTICATED","unregisterListener","documents","query","converter","comparator","toProto"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@google-cloud/firestore/build/src/watch.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueryWatch = exports.DocumentWatch = exports.WATCH_IDLE_TIMEOUT_MS = void 0;\nconst assert = require(\"assert\");\nconst rbtree = require(\"functional-red-black-tree\");\nconst google_gax_1 = require(\"google-gax\");\nconst backoff_1 = require(\"./backoff\");\nconst document_1 = require(\"./document\");\nconst document_change_1 = require(\"./document-change\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst timestamp_1 = require(\"./timestamp\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n * @type {number}\n */\nconst WATCH_TARGET_ID = 0x1;\n/*!\n * Idle timeout used to detect Watch streams that stall (see\n * https://github.com/googleapis/nodejs-firestore/issues/1057, b/156308554).\n * Under normal load, the Watch backend will send a TARGET_CHANGE message\n * roughly every 30 seconds. As discussed with the backend team, we reset the\n * Watch stream if we do not receive any message within 120 seconds.\n */\nexports.WATCH_IDLE_TIMEOUT_MS = 120 * 1000;\n/*!\n * Sentinel value for a document remove.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst REMOVED = {};\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\nconst ChangeType = {\n    added: 'added',\n    modified: 'modified',\n    removed: 'removed',\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\nconst DOCUMENT_WATCH_COMPARATOR = (doc1, doc2) => {\n    assert(doc1 === doc2, 'Document watches only support one document.');\n    return 0;\n};\nconst EMPTY_FUNCTION = () => { };\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n * @internal\n */\nclass Watch {\n    /**\n     * @private\n     * @internal\n     *\n     * @param firestore The Firestore Database client.\n     */\n    constructor(firestore, _converter = (0, types_1.defaultConverter)()) {\n        this._converter = _converter;\n        /**\n         * Indicates whether we are interested in data from the stream. Set to false in the\n         * 'unsubscribe()' callback.\n         * @private\n         * @internal\n         */\n        this.isActive = true;\n        /**\n         * The current stream to the backend.\n         * @private\n         * @internal\n         */\n        this.currentStream = null;\n        /**\n         * The server assigns and updates the resume token.\n         * @private\n         * @internal\n         */\n        this.resumeToken = undefined;\n        /**\n         * A map of document names to QueryDocumentSnapshots for the last sent snapshot.\n         * @private\n         * @internal\n         */\n        this.docMap = new Map();\n        /**\n         * The accumulated map of document changes (keyed by document name) for the\n         * current snapshot.\n         * @private\n         * @internal\n         */\n        this.changeMap = new Map();\n        /**\n         * The current state of the query results. *\n         * @private\n         * @internal\n         */\n        this.current = false;\n        /**\n         * We need this to track whether we've pushed an initial set of changes,\n         * since we should push those even when there are no changes, if there\n         * aren't docs.\n         * @private\n         * @internal\n         */\n        this.hasPushed = false;\n        this.firestore = firestore;\n        this.backoff = new backoff_1.ExponentialBackoff();\n        this.requestTag = (0, util_1.requestTag)();\n        this.onNext = EMPTY_FUNCTION;\n        this.onError = EMPTY_FUNCTION;\n    }\n    /**\n     * Starts a watch and attaches a listener for document change events.\n     *\n     * @private\n     * @internal\n     * @param onNext A callback to be called every time a new snapshot is\n     * available.\n     * @param onError A callback to be called if the listen fails or is cancelled.\n     * No further callbacks will occur.\n     *\n     * @returns An unsubscribe function that can be called to cancel the snapshot\n     * listener.\n     */\n    onSnapshot(onNext, onError) {\n        assert(this.onNext === EMPTY_FUNCTION, 'onNext should not already be defined.');\n        assert(this.onError === EMPTY_FUNCTION, 'onError should not already be defined.');\n        assert(this.docTree === undefined, 'docTree should not already be defined.');\n        this.onNext = onNext;\n        this.onError = onError;\n        this.docTree = rbtree(this.getComparator());\n        this.initStream();\n        const unsubscribe = () => {\n            (0, logger_1.logger)('Watch.onSnapshot', this.requestTag, 'Unsubscribe called');\n            // Prevent further callbacks.\n            this.onNext = () => { };\n            this.onError = () => { };\n            this.shutdown();\n        };\n        this.firestore.registerListener();\n        return unsubscribe;\n    }\n    /**\n     * Returns the current count of all documents, including the changes from\n     * the current changeMap.\n     * @private\n     * @internal\n     */\n    currentSize() {\n        const changes = this.extractCurrentChanges(timestamp_1.Timestamp.now());\n        return this.docMap.size + changes.adds.length - changes.deletes.length;\n    }\n    /**\n     * Splits up document changes into removals, additions, and updates.\n     * @private\n     * @internal\n     */\n    extractCurrentChanges(readTime) {\n        const deletes = [];\n        const adds = [];\n        const updates = [];\n        this.changeMap.forEach((value, name) => {\n            if (value === REMOVED) {\n                if (this.docMap.has(name)) {\n                    deletes.push(name);\n                }\n            }\n            else if (this.docMap.has(name)) {\n                value.readTime = readTime;\n                updates.push(value.build());\n            }\n            else {\n                value.readTime = readTime;\n                adds.push(value.build());\n            }\n        });\n        return { deletes, adds, updates };\n    }\n    /**\n     * Helper to clear the docs on RESET or filter mismatch.\n     * @private\n     * @internal\n     */\n    resetDocs() {\n        (0, logger_1.logger)('Watch.resetDocs', this.requestTag, 'Resetting documents');\n        this.changeMap.clear();\n        this.resumeToken = undefined;\n        this.docTree.forEach((snapshot) => {\n            // Mark each document as deleted. If documents are not deleted, they\n            // will be send again by the server.\n            this.changeMap.set(snapshot.ref.path, REMOVED);\n        });\n        this.current = false;\n    }\n    /**\n     * Closes the stream and calls onError() if the stream is still active.\n     * @private\n     * @internal\n     */\n    closeStream(err) {\n        if (this.isActive) {\n            (0, logger_1.logger)('Watch.closeStream', this.requestTag, 'Invoking onError: ', err);\n            this.onError(err);\n        }\n        this.shutdown();\n    }\n    /**\n     * Re-opens the stream unless the specified error is considered permanent.\n     * Clears the change map.\n     * @private\n     * @internal\n     */\n    maybeReopenStream(err) {\n        if (this.isActive && !this.isPermanentWatchError(err)) {\n            (0, logger_1.logger)('Watch.maybeReopenStream', this.requestTag, 'Stream ended, re-opening after retryable error:', err);\n            this.changeMap.clear();\n            if (this.isResourceExhaustedError(err)) {\n                this.backoff.resetToMax();\n            }\n            this.initStream();\n        }\n        else {\n            this.closeStream(err);\n        }\n    }\n    /**\n     * Cancels the current idle timeout and reschedules a new timer.\n     *\n     * @private\n     * @internal\n     */\n    resetIdleTimeout() {\n        if (this.idleTimeoutHandle) {\n            clearTimeout(this.idleTimeoutHandle);\n        }\n        this.idleTimeoutHandle = (0, backoff_1.delayExecution)(() => {\n            var _a;\n            (0, logger_1.logger)('Watch.resetIdleTimeout', this.requestTag, 'Resetting stream after idle timeout');\n            (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n            this.currentStream = null;\n            const error = new google_gax_1.GoogleError('Watch stream idle timeout');\n            error.code = google_gax_1.Status.UNKNOWN;\n            this.maybeReopenStream(error);\n        }, exports.WATCH_IDLE_TIMEOUT_MS);\n    }\n    /**\n     * Helper to restart the outgoing stream to the backend.\n     * @private\n     * @internal\n     */\n    resetStream() {\n        (0, logger_1.logger)('Watch.resetStream', this.requestTag, 'Restarting stream');\n        if (this.currentStream) {\n            this.currentStream.end();\n            this.currentStream = null;\n        }\n        this.initStream();\n    }\n    /**\n     * Initializes a new stream to the backend with backoff.\n     * @private\n     * @internal\n     */\n    initStream() {\n        this.backoff\n            .backoffAndWait()\n            .then(async () => {\n            if (!this.isActive) {\n                (0, logger_1.logger)('Watch.initStream', this.requestTag, 'Not initializing inactive stream');\n                return;\n            }\n            await this.firestore.initializeIfNeeded(this.requestTag);\n            const request = {};\n            request.database = this.firestore.formattedName;\n            request.addTarget = this.getTarget(this.resumeToken);\n            // Note that we need to call the internal _listen API to pass additional\n            // header values in readWriteStream.\n            return this.firestore\n                .requestStream('listen', \n            /* bidirectional= */ true, request, this.requestTag)\n                .then(backendStream => {\n                if (!this.isActive) {\n                    (0, logger_1.logger)('Watch.initStream', this.requestTag, 'Closing inactive stream');\n                    backendStream.emit('end');\n                    return;\n                }\n                (0, logger_1.logger)('Watch.initStream', this.requestTag, 'Opened new stream');\n                this.currentStream = backendStream;\n                this.resetIdleTimeout();\n                this.currentStream.on('data', (proto) => {\n                    this.resetIdleTimeout();\n                    this.onData(proto);\n                })\n                    .on('error', err => {\n                    if (this.currentStream === backendStream) {\n                        this.currentStream = null;\n                        this.maybeReopenStream(err);\n                    }\n                })\n                    .on('end', () => {\n                    if (this.currentStream === backendStream) {\n                        this.currentStream = null;\n                        const err = new google_gax_1.GoogleError('Stream ended unexpectedly');\n                        err.code = google_gax_1.Status.UNKNOWN;\n                        this.maybeReopenStream(err);\n                    }\n                });\n                this.currentStream.resume();\n            });\n        })\n            .catch(err => {\n            this.closeStream(err);\n        });\n    }\n    /**\n     * Handles 'data' events and closes the stream if the response type is\n     * invalid.\n     * @private\n     * @internal\n     */\n    onData(proto) {\n        if (proto.targetChange) {\n            (0, logger_1.logger)('Watch.onData', this.requestTag, 'Processing target change');\n            const change = proto.targetChange;\n            const noTargetIds = !change.targetIds || change.targetIds.length === 0;\n            if (change.targetChangeType === 'NO_CHANGE') {\n                if (noTargetIds && change.readTime && this.current) {\n                    // This means everything is up-to-date, so emit the current\n                    // set of docs as a snapshot, if there were changes.\n                    this.pushSnapshot(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n                }\n            }\n            else if (change.targetChangeType === 'ADD') {\n                if (WATCH_TARGET_ID !== change.targetIds[0]) {\n                    this.closeStream(Error('Unexpected target ID sent by server'));\n                }\n            }\n            else if (change.targetChangeType === 'REMOVE') {\n                let code = google_gax_1.Status.INTERNAL;\n                let message = 'internal error';\n                if (change.cause) {\n                    code = change.cause.code;\n                    message = change.cause.message;\n                }\n                // @todo: Surface a .code property on the exception.\n                this.closeStream(new Error('Error ' + code + ': ' + message));\n            }\n            else if (change.targetChangeType === 'RESET') {\n                // Whatever changes have happened so far no longer matter.\n                this.resetDocs();\n            }\n            else if (change.targetChangeType === 'CURRENT') {\n                this.current = true;\n            }\n            else {\n                this.closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n            }\n            if (change.resumeToken &&\n                this.affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n                this.backoff.reset();\n            }\n        }\n        else if (proto.documentChange) {\n            (0, logger_1.logger)('Watch.onData', this.requestTag, 'Processing change event');\n            // No other targetIds can show up here, but we still need to see\n            // if the targetId was in the added list or removed list.\n            const targetIds = proto.documentChange.targetIds || [];\n            const removedTargetIds = proto.documentChange.removedTargetIds || [];\n            let changed = false;\n            let removed = false;\n            for (let i = 0; i < targetIds.length; i++) {\n                if (targetIds[i] === WATCH_TARGET_ID) {\n                    changed = true;\n                }\n            }\n            for (let i = 0; i < removedTargetIds.length; i++) {\n                if (removedTargetIds[i] === WATCH_TARGET_ID) {\n                    removed = true;\n                }\n            }\n            const document = proto.documentChange.document;\n            const name = document.name;\n            const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n            if (changed) {\n                (0, logger_1.logger)('Watch.onData', this.requestTag, 'Received document change');\n                const ref = this.firestore.doc(relativeName);\n                const snapshot = new document_1.DocumentSnapshotBuilder(ref.withConverter(this._converter));\n                snapshot.fieldsProto = document.fields || {};\n                snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n                snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n                this.changeMap.set(relativeName, snapshot);\n            }\n            else if (removed) {\n                (0, logger_1.logger)('Watch.onData', this.requestTag, 'Received document remove');\n                this.changeMap.set(relativeName, REMOVED);\n            }\n        }\n        else if (proto.documentDelete || proto.documentRemove) {\n            (0, logger_1.logger)('Watch.onData', this.requestTag, 'Processing remove event');\n            const name = (proto.documentDelete || proto.documentRemove).document;\n            const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n            this.changeMap.set(relativeName, REMOVED);\n        }\n        else if (proto.filter) {\n            (0, logger_1.logger)('Watch.onData', this.requestTag, 'Processing filter update');\n            if (proto.filter.count !== this.currentSize()) {\n                // We need to remove all the current results.\n                this.resetDocs();\n                // The filter didn't match, so re-issue the query.\n                this.resetStream();\n            }\n        }\n        else {\n            this.closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n        }\n    }\n    /**\n     * Checks if the current target id is included in the list of target ids.\n     * If no targetIds are provided, returns true.\n     * @private\n     * @internal\n     */\n    affectsTarget(targetIds, currentId) {\n        if (targetIds === undefined || targetIds.length === 0) {\n            return true;\n        }\n        for (const targetId of targetIds) {\n            if (targetId === currentId) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Assembles a new snapshot from the current set of changes and invokes the\n     * user's callback. Clears the current changes on completion.\n     * @private\n     * @internal\n     */\n    pushSnapshot(readTime, nextResumeToken) {\n        const appliedChanges = this.computeSnapshot(readTime);\n        if (!this.hasPushed || appliedChanges.length > 0) {\n            (0, logger_1.logger)('Watch.pushSnapshot', this.requestTag, 'Sending snapshot with %d changes and %d documents', String(appliedChanges.length), this.docTree.length);\n            // We pass the current set of changes, even if `docTree` is modified later.\n            const currentTree = this.docTree;\n            this.onNext(readTime, currentTree.length, () => currentTree.keys, () => appliedChanges);\n            this.hasPushed = true;\n        }\n        this.changeMap.clear();\n        this.resumeToken = nextResumeToken;\n    }\n    /**\n     * Applies a document delete to the document tree and the document map.\n     * Returns the corresponding DocumentChange event.\n     * @private\n     * @internal\n     */\n    deleteDoc(name) {\n        assert(this.docMap.has(name), 'Document to delete does not exist');\n        const oldDocument = this.docMap.get(name);\n        const existing = this.docTree.find(oldDocument);\n        const oldIndex = existing.index;\n        this.docTree = existing.remove();\n        this.docMap.delete(name);\n        return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n    }\n    /**\n     * Applies a document add to the document tree and the document map. Returns\n     * the corresponding DocumentChange event.\n     * @private\n     * @internal\n     */\n    addDoc(newDocument) {\n        const name = newDocument.ref.path;\n        assert(!this.docMap.has(name), 'Document to add already exists');\n        this.docTree = this.docTree.insert(newDocument, null);\n        const newIndex = this.docTree.find(newDocument).index;\n        this.docMap.set(name, newDocument);\n        return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n    }\n    /**\n     * Applies a document modification to the document tree and the document map.\n     * Returns the DocumentChange event for successful modifications.\n     * @private\n     * @internal\n     */\n    modifyDoc(newDocument) {\n        const name = newDocument.ref.path;\n        assert(this.docMap.has(name), 'Document to modify does not exist');\n        const oldDocument = this.docMap.get(name);\n        if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n            const removeChange = this.deleteDoc(name);\n            const addChange = this.addDoc(newDocument);\n            return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n        }\n        return null;\n    }\n    /**\n     * Applies the mutations in changeMap to both the document tree and the\n     * document lookup map. Modified docMap in-place and returns the updated\n     * state.\n     * @private\n     * @internal\n     */\n    computeSnapshot(readTime) {\n        const changeSet = this.extractCurrentChanges(readTime);\n        const appliedChanges = [];\n        // Process the sorted changes in the order that is expected by our clients\n        // (removals, additions, and then modifications). We also need to sort the\n        // individual changes to assure that oldIndex/newIndex keep incrementing.\n        changeSet.deletes.sort((name1, name2) => {\n            // Deletes are sorted based on the order of the existing document.\n            return this.getComparator()(this.docMap.get(name1), this.docMap.get(name2));\n        });\n        changeSet.deletes.forEach(name => {\n            const change = this.deleteDoc(name);\n            appliedChanges.push(change);\n        });\n        changeSet.adds.sort(this.getComparator());\n        changeSet.adds.forEach(snapshot => {\n            const change = this.addDoc(snapshot);\n            appliedChanges.push(change);\n        });\n        changeSet.updates.sort(this.getComparator());\n        changeSet.updates.forEach(snapshot => {\n            const change = this.modifyDoc(snapshot);\n            if (change) {\n                appliedChanges.push(change);\n            }\n        });\n        assert(this.docTree.length === this.docMap.size, 'The update document ' +\n            'tree and document map should have the same number of entries.');\n        return appliedChanges;\n    }\n    /**\n     * Determines whether a watch error is considered permanent and should not be\n     * retried. Errors that don't provide a GRPC error code are always considered\n     * transient in this context.\n     *\n     * @private\n     * @internal\n     * @param error An error object.\n     * @return Whether the error is permanent.\n     */\n    isPermanentWatchError(error) {\n        if (error.code === undefined) {\n            (0, logger_1.logger)('Watch.isPermanentError', this.requestTag, 'Unable to determine error code: ', error);\n            return false;\n        }\n        switch (error.code) {\n            case google_gax_1.Status.ABORTED:\n            case google_gax_1.Status.CANCELLED:\n            case google_gax_1.Status.UNKNOWN:\n            case google_gax_1.Status.DEADLINE_EXCEEDED:\n            case google_gax_1.Status.RESOURCE_EXHAUSTED:\n            case google_gax_1.Status.INTERNAL:\n            case google_gax_1.Status.UNAVAILABLE:\n            case google_gax_1.Status.UNAUTHENTICATED:\n                return false;\n            default:\n                return true;\n        }\n    }\n    /**\n     * Determines whether we need to initiate a longer backoff due to system\n     * overload.\n     *\n     * @private\n     * @internal\n     * @param error A GRPC Error object that exposes an error code.\n     * @return Whether we need to back off our retries.\n     */\n    isResourceExhaustedError(error) {\n        return error.code === google_gax_1.Status.RESOURCE_EXHAUSTED;\n    }\n    /** Closes the stream and clears all timeouts. */\n    shutdown() {\n        var _a;\n        if (this.isActive) {\n            this.isActive = false;\n            if (this.idleTimeoutHandle) {\n                clearTimeout(this.idleTimeoutHandle);\n                this.idleTimeoutHandle = undefined;\n            }\n            this.firestore.unregisterListener();\n        }\n        (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n        this.currentStream = null;\n    }\n}\n/**\n * Creates a new Watch instance to listen on DocumentReferences.\n *\n * @private\n * @internal\n */\nclass DocumentWatch extends Watch {\n    constructor(firestore, ref) {\n        super(firestore, ref._converter);\n        this.ref = ref;\n    }\n    getComparator() {\n        return DOCUMENT_WATCH_COMPARATOR;\n    }\n    getTarget(resumeToken) {\n        const formattedName = this.ref.formattedName;\n        return {\n            documents: {\n                documents: [formattedName],\n            },\n            targetId: WATCH_TARGET_ID,\n            resumeToken,\n        };\n    }\n}\nexports.DocumentWatch = DocumentWatch;\n/**\n * Creates a new Watch instance to listen on Queries.\n *\n * @private\n * @internal\n */\nclass QueryWatch extends Watch {\n    constructor(firestore, query, converter) {\n        super(firestore, converter);\n        this.query = query;\n        this.comparator = query.comparator();\n    }\n    getComparator() {\n        return this.query.comparator();\n    }\n    getTarget(resumeToken) {\n        const query = this.query.toProto();\n        return { query, targetId: WATCH_TARGET_ID, resumeToken };\n    }\n}\nexports.QueryWatch = QueryWatch;\n//# sourceMappingURL=watch.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}