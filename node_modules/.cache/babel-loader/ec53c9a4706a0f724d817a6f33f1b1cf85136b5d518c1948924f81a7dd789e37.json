{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retryable = retryable;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst timeout_1 = require(\"./timeout\");\n/**\n * Creates a function equivalent to func, but that retries on certain\n * exceptions.\n *\n * @private\n *\n * @param {GRPCCall} func - A function.\n * @param {RetryOptions} retry - Configures the exceptions upon which the\n *   function eshould retry, and the parameters to the exponential backoff retry\n *   algorithm.\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\n * @return {SimpleCallbackFunction} A function that will retry.\n */\nfunction retryable(func, retry, otherArgs, apiName) {\n  const delayMult = retry.backoffSettings.retryDelayMultiplier;\n  const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n  const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n  const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n  let delay = retry.backoffSettings.initialRetryDelayMillis;\n  let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n  /**\n   * Equivalent to ``func``, but retries upon transient failure.\n   *\n   * Retrying is done through an exponential backoff algorithm configured\n   * by the options in ``retry``.\n   * @param {RequestType} argument The request object.\n   * @param {APICallback} callback The callback.\n   * @return {GRPCCall}\n   */\n  return (argument, callback) => {\n    let canceller;\n    let timeoutId;\n    let now = new Date();\n    let deadline;\n    if (retry.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n    }\n    let retries = 0;\n    const maxRetries = retry.backoffSettings.maxRetries;\n    // TODO: define A/B testing values for retry behaviors.\n    /** Repeat the API call as long as necessary. */\n    function repeat() {\n      timeoutId = null;\n      if (deadline && now.getTime() >= deadline) {\n        const error = new googleError_1.GoogleError(`Total timeout of API ${apiName} exceeded ${retry.backoffSettings.totalTimeoutMillis} milliseconds before any response was received.`);\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n      if (retries && retries >= maxRetries) {\n        const error = new googleError_1.GoogleError('Exceeded maximum number of retries before any ' + 'response was received');\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n      retries++;\n      const toCall = (0, timeout_1.addTimeoutArg)(func, timeout, otherArgs);\n      canceller = toCall(argument, (err, response, next, rawResponse) => {\n        if (!err) {\n          callback(null, response, next, rawResponse);\n          return;\n        }\n        canceller = null;\n        if (retry.retryCodes.length > 0 && retry.retryCodes.indexOf(err.code) < 0) {\n          err.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n          callback(err);\n        } else {\n          const toSleep = Math.random() * delay;\n          timeoutId = setTimeout(() => {\n            now = new Date();\n            delay = Math.min(delay * delayMult, maxDelay);\n            const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n            const rpcTimeout = maxTimeout ? maxTimeout : 0;\n            const newDeadline = deadline ? deadline - now.getTime() : 0;\n            timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n            repeat();\n          }, toSleep);\n        }\n      });\n      if (canceller instanceof Promise) {\n        canceller.catch(err => {\n          callback(new googleError_1.GoogleError(err));\n        });\n      }\n    }\n    if (maxRetries && deadline) {\n      const error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.');\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n    } else {\n      repeat();\n    }\n    return {\n      cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        if (canceller) {\n          canceller.cancel();\n        } else {\n          const error = new googleError_1.GoogleError('cancelled');\n          error.code = status_1.Status.CANCELLED;\n          callback(error);\n        }\n      }\n    };\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","retryable","status_1","require","googleError_1","timeout_1","func","retry","otherArgs","apiName","delayMult","backoffSettings","retryDelayMultiplier","maxDelay","maxRetryDelayMillis","timeoutMult","rpcTimeoutMultiplier","maxTimeout","maxRpcTimeoutMillis","delay","initialRetryDelayMillis","timeout","initialRpcTimeoutMillis","argument","callback","canceller","timeoutId","now","Date","deadline","totalTimeoutMillis","getTime","retries","maxRetries","repeat","error","GoogleError","code","Status","DEADLINE_EXCEEDED","toCall","addTimeoutArg","err","response","next","rawResponse","retryCodes","length","indexOf","note","toSleep","Math","random","setTimeout","min","timeoutCal","rpcTimeout","newDeadline","Promise","catch","INVALID_ARGUMENT","cancel","clearTimeout","CANCELLED"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/google-gax/build/src/normalCalls/retries.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.retryable = retryable;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst timeout_1 = require(\"./timeout\");\n/**\n * Creates a function equivalent to func, but that retries on certain\n * exceptions.\n *\n * @private\n *\n * @param {GRPCCall} func - A function.\n * @param {RetryOptions} retry - Configures the exceptions upon which the\n *   function eshould retry, and the parameters to the exponential backoff retry\n *   algorithm.\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\n * @return {SimpleCallbackFunction} A function that will retry.\n */\nfunction retryable(func, retry, otherArgs, apiName) {\n    const delayMult = retry.backoffSettings.retryDelayMultiplier;\n    const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n    const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n    const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n    let delay = retry.backoffSettings.initialRetryDelayMillis;\n    let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n    /**\n     * Equivalent to ``func``, but retries upon transient failure.\n     *\n     * Retrying is done through an exponential backoff algorithm configured\n     * by the options in ``retry``.\n     * @param {RequestType} argument The request object.\n     * @param {APICallback} callback The callback.\n     * @return {GRPCCall}\n     */\n    return (argument, callback) => {\n        let canceller;\n        let timeoutId;\n        let now = new Date();\n        let deadline;\n        if (retry.backoffSettings.totalTimeoutMillis) {\n            deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n        }\n        let retries = 0;\n        const maxRetries = retry.backoffSettings.maxRetries;\n        // TODO: define A/B testing values for retry behaviors.\n        /** Repeat the API call as long as necessary. */\n        function repeat() {\n            timeoutId = null;\n            if (deadline && now.getTime() >= deadline) {\n                const error = new googleError_1.GoogleError(`Total timeout of API ${apiName} exceeded ${retry.backoffSettings.totalTimeoutMillis} milliseconds before any response was received.`);\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\n                callback(error);\n                return;\n            }\n            if (retries && retries >= maxRetries) {\n                const error = new googleError_1.GoogleError('Exceeded maximum number of retries before any ' +\n                    'response was received');\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\n                callback(error);\n                return;\n            }\n            retries++;\n            const toCall = (0, timeout_1.addTimeoutArg)(func, timeout, otherArgs);\n            canceller = toCall(argument, (err, response, next, rawResponse) => {\n                if (!err) {\n                    callback(null, response, next, rawResponse);\n                    return;\n                }\n                canceller = null;\n                if (retry.retryCodes.length > 0 &&\n                    retry.retryCodes.indexOf(err.code) < 0) {\n                    err.note =\n                        'Exception occurred in retry method that was ' +\n                            'not classified as transient';\n                    callback(err);\n                }\n                else {\n                    const toSleep = Math.random() * delay;\n                    timeoutId = setTimeout(() => {\n                        now = new Date();\n                        delay = Math.min(delay * delayMult, maxDelay);\n                        const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n                        const rpcTimeout = maxTimeout ? maxTimeout : 0;\n                        const newDeadline = deadline ? deadline - now.getTime() : 0;\n                        timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n                        repeat();\n                    }, toSleep);\n                }\n            });\n            if (canceller instanceof Promise) {\n                canceller.catch(err => {\n                    callback(new googleError_1.GoogleError(err));\n                });\n            }\n        }\n        if (maxRetries && deadline) {\n            const error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' +\n                'in backoffSettings.');\n            error.code = status_1.Status.INVALID_ARGUMENT;\n            callback(error);\n        }\n        else {\n            repeat();\n        }\n        return {\n            cancel() {\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n                if (canceller) {\n                    canceller.cancel();\n                }\n                else {\n                    const error = new googleError_1.GoogleError('cancelled');\n                    error.code = status_1.Status.CANCELLED;\n                    callback(error);\n                }\n            },\n        };\n    };\n}\n//# sourceMappingURL=retries.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}