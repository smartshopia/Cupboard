{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Serializer = void 0;\nexports.validateUserInput = validateUserInput;\nconst field_value_1 = require(\"./field-value\");\nconst convert_1 = require(\"./convert\");\nconst geo_point_1 = require(\"./geo-point\");\nconst index_1 = require(\"./index\");\nconst path_1 = require(\"./path\");\nconst timestamp_1 = require(\"./timestamp\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst map_type_1 = require(\"./map-type\");\n/**\n * The maximum depth of a Firestore object.\n *\n * @private\n * @internal\n */\nconst MAX_DEPTH = 20;\n/**\n * Serializer that is used to convert between JavaScript types and their\n * Firestore Protobuf representation.\n *\n * @private\n * @internal\n */\nclass Serializer {\n  constructor(firestore) {\n    // Instead of storing the `firestore` object, we store just a reference to\n    // its `.doc()` method. This avoid a circular reference, which breaks\n    // JSON.stringify().\n    this.createReference = path => firestore.doc(path);\n    this.createInteger = n => firestore._settings.useBigInt ? BigInt(n) : Number(n);\n    this.allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n  }\n  /**\n   * Encodes a JavaScript object into the Firestore 'Fields' representation.\n   *\n   * @private\n   * @internal\n   * @param obj The object to encode.\n   * @returns The Firestore 'Fields' representation\n   */\n  encodeFields(obj) {\n    const fields = {};\n    for (const prop of Object.keys(obj)) {\n      const val = this.encodeValue(obj[prop]);\n      if (val) {\n        fields[prop] = val;\n      }\n    }\n    return fields;\n  }\n  /**\n   * Encodes a JavaScript value into the Firestore 'Value' representation.\n   *\n   * @private\n   * @internal\n   * @param val The object to encode\n   * @returns The Firestore Proto or null if we are deleting a field.\n   */\n  encodeValue(val) {\n    if (val instanceof field_value_1.FieldTransform) {\n      return null;\n    }\n    if (typeof val === 'string') {\n      return {\n        stringValue: val\n      };\n    }\n    if (typeof val === 'boolean') {\n      return {\n        booleanValue: val\n      };\n    }\n    if (typeof val === 'number') {\n      const isNegativeZero = val === 0 && 1 / val === 1 / -0;\n      if (Number.isSafeInteger(val) && !isNegativeZero) {\n        return {\n          integerValue: val\n        };\n      } else {\n        return {\n          doubleValue: val\n        };\n      }\n    }\n    if (typeof val === 'bigint') {\n      return {\n        integerValue: val.toString()\n      };\n    }\n    if (val instanceof Date) {\n      const timestamp = timestamp_1.Timestamp.fromDate(val);\n      return {\n        timestampValue: {\n          seconds: timestamp.seconds,\n          nanos: timestamp.nanoseconds\n        }\n      };\n    }\n    if (isMomentJsType(val)) {\n      const timestamp = timestamp_1.Timestamp.fromDate(val.toDate());\n      return {\n        timestampValue: {\n          seconds: timestamp.seconds,\n          nanos: timestamp.nanoseconds\n        }\n      };\n    }\n    if (val === null) {\n      return {\n        nullValue: 'NULL_VALUE'\n      };\n    }\n    if (val instanceof Buffer || val instanceof Uint8Array) {\n      return {\n        bytesValue: val\n      };\n    }\n    if (val instanceof field_value_1.VectorValue) {\n      return val._toProto(this);\n    }\n    if ((0, util_1.isObject)(val)) {\n      const toProto = val['toProto'];\n      if (typeof toProto === 'function') {\n        return toProto.bind(val)();\n      }\n    }\n    if (Array.isArray(val)) {\n      const array = {\n        arrayValue: {}\n      };\n      if (val.length > 0) {\n        array.arrayValue.values = [];\n        for (let i = 0; i < val.length; ++i) {\n          const enc = this.encodeValue(val[i]);\n          if (enc) {\n            array.arrayValue.values.push(enc);\n          }\n        }\n      }\n      return array;\n    }\n    if (typeof val === 'object' && (0, util_1.isPlainObject)(val)) {\n      const map = {\n        mapValue: {}\n      };\n      // If we encounter an empty object, we always need to send it to make sure\n      // the server creates a map entry.\n      if (!(0, util_1.isEmpty)(val)) {\n        map.mapValue.fields = this.encodeFields(val);\n        if ((0, util_1.isEmpty)(map.mapValue.fields)) {\n          return null;\n        }\n      }\n      return map;\n    }\n    if (val === undefined && this.allowUndefined) {\n      return null;\n    }\n    throw new Error(`Cannot encode value: ${val}`);\n  }\n  /**\n   * @private\n   */\n  encodeVector(rawVector) {\n    // A Firestore Vector is a map with reserved key/value pairs.\n    return {\n      mapValue: {\n        fields: {\n          [map_type_1.RESERVED_MAP_KEY]: {\n            stringValue: map_type_1.RESERVED_MAP_KEY_VECTOR_VALUE\n          },\n          [map_type_1.VECTOR_MAP_VECTORS_KEY]: {\n            arrayValue: {\n              values: rawVector.map(value => {\n                return {\n                  doubleValue: value\n                };\n              })\n            }\n          }\n        }\n      }\n    };\n  }\n  /**\n   * Decodes a single Firestore 'Value' Protobuf.\n   *\n   * @private\n   * @internal\n   * @param proto A Firestore 'Value' Protobuf.\n   * @returns The converted JS type.\n   */\n  decodeValue(proto) {\n    const valueType = (0, convert_1.detectValueType)(proto);\n    switch (valueType) {\n      case 'stringValue':\n        {\n          return proto.stringValue;\n        }\n      case 'booleanValue':\n        {\n          return proto.booleanValue;\n        }\n      case 'integerValue':\n        {\n          return this.createInteger(proto.integerValue);\n        }\n      case 'doubleValue':\n        {\n          return proto.doubleValue;\n        }\n      case 'timestampValue':\n        {\n          return timestamp_1.Timestamp.fromProto(proto.timestampValue);\n        }\n      case 'referenceValue':\n        {\n          const resourcePath = path_1.QualifiedResourcePath.fromSlashSeparatedString(proto.referenceValue);\n          return this.createReference(resourcePath.relativeName);\n        }\n      case 'arrayValue':\n        {\n          const array = [];\n          if (Array.isArray(proto.arrayValue.values)) {\n            for (const value of proto.arrayValue.values) {\n              array.push(this.decodeValue(value));\n            }\n          }\n          return array;\n        }\n      case 'nullValue':\n        {\n          return null;\n        }\n      case 'mapValue':\n        {\n          const fields = proto.mapValue.fields;\n          if (fields) {\n            const obj = {};\n            for (const prop of Object.keys(fields)) {\n              obj[prop] = this.decodeValue(fields[prop]);\n            }\n            return obj;\n          } else {\n            return {};\n          }\n        }\n      case 'vectorValue':\n        {\n          const fields = proto.mapValue.fields;\n          return field_value_1.VectorValue._fromProto(fields[map_type_1.VECTOR_MAP_VECTORS_KEY]);\n        }\n      case 'geoPointValue':\n        {\n          return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);\n        }\n      case 'bytesValue':\n        {\n          return proto.bytesValue;\n        }\n      default:\n        {\n          throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));\n        }\n    }\n  }\n  /**\n   * Decodes a google.protobuf.Value\n   *\n   * @private\n   * @internal\n   * @param proto A Google Protobuf 'Value'.\n   * @returns The converted JS type.\n   */\n  decodeGoogleProtobufValue(proto) {\n    switch ((0, convert_1.detectGoogleProtobufValueType)(proto)) {\n      case 'nullValue':\n        {\n          return null;\n        }\n      case 'numberValue':\n        {\n          return proto.numberValue;\n        }\n      case 'stringValue':\n        {\n          return proto.stringValue;\n        }\n      case 'boolValue':\n        {\n          return proto.boolValue;\n        }\n      case 'listValue':\n        {\n          return this.decodeGoogleProtobufList(proto.listValue);\n        }\n      case 'structValue':\n        {\n          return this.decodeGoogleProtobufStruct(proto.structValue);\n        }\n      default:\n        {\n          throw new Error('Cannot decode type from google.protobuf.Value: ' + JSON.stringify(proto));\n        }\n    }\n  }\n  /**\n   * Decodes a google.protobuf.ListValue\n   *\n   * @private\n   * @internal\n   * @param proto A Google Protobuf 'ListValue'.\n   * @returns The converted JS type.\n   */\n  decodeGoogleProtobufList(proto) {\n    const result = [];\n    if (proto && proto.values && Array.isArray(proto.values)) {\n      for (const value of proto.values) {\n        result.push(this.decodeGoogleProtobufValue(value));\n      }\n    }\n    return result;\n  }\n  /**\n   * Decodes a google.protobuf.Struct\n   *\n   * @private\n   * @internal\n   * @param proto A Google Protobuf 'Struct'.\n   * @returns The converted JS type.\n   */\n  decodeGoogleProtobufStruct(proto) {\n    const result = {};\n    if (proto && proto.fields) {\n      for (const prop of Object.keys(proto.fields)) {\n        result[prop] = this.decodeGoogleProtobufValue(proto.fields[prop]);\n      }\n    }\n    return result;\n  }\n}\nexports.Serializer = Serializer;\n/**\n * Validates a JavaScript value for usage as a Firestore value.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value JavaScript value to validate.\n * @param desc A description of the expected type.\n * @param path The field path to validate.\n * @param options Validation options\n * @param level The current depth of the traversal. This is used to decide\n * whether undefined values or deletes are allowed.\n * @param inArray Whether we are inside an array.\n * @throws when the object is invalid.\n */\nfunction validateUserInput(arg, value, desc, options, path, level, inArray) {\n  if (path && path.size - 1 > MAX_DEPTH) {\n    throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} Input object is deeper than ${MAX_DEPTH} levels or contains a cycle.`);\n  }\n  level = level || 0;\n  inArray = inArray || false;\n  const fieldPathMessage = path ? ` (found in field \"${path}\")` : '';\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; ++i) {\n      validateUserInput(arg, value[i], desc, options, path ? path.append(String(i)) : new path_1.FieldPath(String(i)), level + 1, /* inArray= */true);\n    }\n  } else if ((0, util_1.isPlainObject)(value)) {\n    for (const prop of Object.keys(value)) {\n      validateUserInput(arg, value[prop], desc, options, path ? path.append(new path_1.FieldPath(prop)) : new path_1.FieldPath(prop), level + 1, inArray);\n    }\n  } else if (value === undefined) {\n    if (options.allowUndefined && level === 0) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} \"undefined\" values are only ignored inside of objects.`);\n    } else if (!options.allowUndefined) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} Cannot use \"undefined\" as a Firestore value${fieldPathMessage}. ` + 'If you want to ignore undefined values, enable `ignoreUndefinedProperties`.');\n    }\n  } else if (value instanceof field_value_1.VectorValue) {\n    // OK\n  } else if (value instanceof field_value_1.DeleteTransform) {\n    if (inArray) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() cannot be used inside of an array${fieldPathMessage}.`);\n    } else if (options.allowDeletes === 'none') {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() must appear at the top-level and can only be used in update() ` + `or set() with {merge:true}${fieldPathMessage}.`);\n    } else if (options.allowDeletes === 'root') {\n      if (level === 0) {\n        // Ok (update() with UpdateData).\n      } else if (level === 1 && (path === null || path === void 0 ? void 0 : path.size) === 1) {\n        // Ok (update with varargs).\n      } else {\n        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() must appear at the top-level and can only be used in update() ` + `or set() with {merge:true}${fieldPathMessage}.`);\n      }\n    }\n  } else if (value instanceof field_value_1.FieldTransform) {\n    if (inArray) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() cannot be used inside of an array${fieldPathMessage}.`);\n    } else if (!options.allowTransforms) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() can only be used in set(), create() or update()${fieldPathMessage}.`);\n    }\n  } else if (value instanceof path_1.FieldPath) {\n    throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} Cannot use object of type \"FieldPath\" as a Firestore value${fieldPathMessage}.`);\n  } else if (value instanceof index_1.DocumentReference) {\n    // Ok.\n  } else if (value instanceof geo_point_1.GeoPoint) {\n    // Ok.\n  } else if (value instanceof timestamp_1.Timestamp || value instanceof Date) {\n    // Ok.\n  } else if (isMomentJsType(value)) {\n    // Ok.\n  } else if (value instanceof Buffer || value instanceof Uint8Array) {\n    // Ok.\n  } else if (value === null) {\n    // Ok.\n  } else if (typeof value === 'object') {\n    throw new Error((0, validate_1.customObjectMessage)(arg, value, path));\n  }\n}\n/**\n * Returns true if value is a MomentJs date object.\n * @private\n * @internal\n */\nfunction isMomentJsType(value) {\n  return typeof value === 'object' && value !== null && value.constructor && value.constructor.name === 'Moment' && typeof value.toDate === 'function';\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Serializer","validateUserInput","field_value_1","require","convert_1","geo_point_1","index_1","path_1","timestamp_1","util_1","validate_1","map_type_1","MAX_DEPTH","constructor","firestore","createReference","path","doc","createInteger","n","_settings","useBigInt","BigInt","Number","allowUndefined","ignoreUndefinedProperties","encodeFields","obj","fields","prop","keys","val","encodeValue","FieldTransform","stringValue","booleanValue","isNegativeZero","isSafeInteger","integerValue","doubleValue","toString","Date","timestamp","Timestamp","fromDate","timestampValue","seconds","nanos","nanoseconds","isMomentJsType","toDate","nullValue","Buffer","Uint8Array","bytesValue","VectorValue","_toProto","isObject","toProto","bind","Array","isArray","array","arrayValue","length","values","i","enc","push","isPlainObject","map","mapValue","isEmpty","undefined","Error","encodeVector","rawVector","RESERVED_MAP_KEY","RESERVED_MAP_KEY_VECTOR_VALUE","VECTOR_MAP_VECTORS_KEY","decodeValue","proto","valueType","detectValueType","fromProto","resourcePath","QualifiedResourcePath","fromSlashSeparatedString","referenceValue","relativeName","_fromProto","GeoPoint","geoPointValue","JSON","stringify","decodeGoogleProtobufValue","detectGoogleProtobufValueType","numberValue","boolValue","decodeGoogleProtobufList","listValue","decodeGoogleProtobufStruct","structValue","result","arg","desc","options","level","inArray","size","invalidArgumentMessage","fieldPathMessage","append","String","FieldPath","DeleteTransform","methodName","allowDeletes","allowTransforms","DocumentReference","customObjectMessage","name"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@google-cloud/firestore/build/src/serializer.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Serializer = void 0;\nexports.validateUserInput = validateUserInput;\nconst field_value_1 = require(\"./field-value\");\nconst convert_1 = require(\"./convert\");\nconst geo_point_1 = require(\"./geo-point\");\nconst index_1 = require(\"./index\");\nconst path_1 = require(\"./path\");\nconst timestamp_1 = require(\"./timestamp\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst map_type_1 = require(\"./map-type\");\n/**\n * The maximum depth of a Firestore object.\n *\n * @private\n * @internal\n */\nconst MAX_DEPTH = 20;\n/**\n * Serializer that is used to convert between JavaScript types and their\n * Firestore Protobuf representation.\n *\n * @private\n * @internal\n */\nclass Serializer {\n    constructor(firestore) {\n        // Instead of storing the `firestore` object, we store just a reference to\n        // its `.doc()` method. This avoid a circular reference, which breaks\n        // JSON.stringify().\n        this.createReference = path => firestore.doc(path);\n        this.createInteger = n => firestore._settings.useBigInt ? BigInt(n) : Number(n);\n        this.allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n    }\n    /**\n     * Encodes a JavaScript object into the Firestore 'Fields' representation.\n     *\n     * @private\n     * @internal\n     * @param obj The object to encode.\n     * @returns The Firestore 'Fields' representation\n     */\n    encodeFields(obj) {\n        const fields = {};\n        for (const prop of Object.keys(obj)) {\n            const val = this.encodeValue(obj[prop]);\n            if (val) {\n                fields[prop] = val;\n            }\n        }\n        return fields;\n    }\n    /**\n     * Encodes a JavaScript value into the Firestore 'Value' representation.\n     *\n     * @private\n     * @internal\n     * @param val The object to encode\n     * @returns The Firestore Proto or null if we are deleting a field.\n     */\n    encodeValue(val) {\n        if (val instanceof field_value_1.FieldTransform) {\n            return null;\n        }\n        if (typeof val === 'string') {\n            return {\n                stringValue: val,\n            };\n        }\n        if (typeof val === 'boolean') {\n            return {\n                booleanValue: val,\n            };\n        }\n        if (typeof val === 'number') {\n            const isNegativeZero = val === 0 && 1 / val === 1 / -0;\n            if (Number.isSafeInteger(val) && !isNegativeZero) {\n                return {\n                    integerValue: val,\n                };\n            }\n            else {\n                return {\n                    doubleValue: val,\n                };\n            }\n        }\n        if (typeof val === 'bigint') {\n            return {\n                integerValue: val.toString(),\n            };\n        }\n        if (val instanceof Date) {\n            const timestamp = timestamp_1.Timestamp.fromDate(val);\n            return {\n                timestampValue: {\n                    seconds: timestamp.seconds,\n                    nanos: timestamp.nanoseconds,\n                },\n            };\n        }\n        if (isMomentJsType(val)) {\n            const timestamp = timestamp_1.Timestamp.fromDate(val.toDate());\n            return {\n                timestampValue: {\n                    seconds: timestamp.seconds,\n                    nanos: timestamp.nanoseconds,\n                },\n            };\n        }\n        if (val === null) {\n            return {\n                nullValue: 'NULL_VALUE',\n            };\n        }\n        if (val instanceof Buffer || val instanceof Uint8Array) {\n            return {\n                bytesValue: val,\n            };\n        }\n        if (val instanceof field_value_1.VectorValue) {\n            return val._toProto(this);\n        }\n        if ((0, util_1.isObject)(val)) {\n            const toProto = val['toProto'];\n            if (typeof toProto === 'function') {\n                return toProto.bind(val)();\n            }\n        }\n        if (Array.isArray(val)) {\n            const array = {\n                arrayValue: {},\n            };\n            if (val.length > 0) {\n                array.arrayValue.values = [];\n                for (let i = 0; i < val.length; ++i) {\n                    const enc = this.encodeValue(val[i]);\n                    if (enc) {\n                        array.arrayValue.values.push(enc);\n                    }\n                }\n            }\n            return array;\n        }\n        if (typeof val === 'object' && (0, util_1.isPlainObject)(val)) {\n            const map = {\n                mapValue: {},\n            };\n            // If we encounter an empty object, we always need to send it to make sure\n            // the server creates a map entry.\n            if (!(0, util_1.isEmpty)(val)) {\n                map.mapValue.fields = this.encodeFields(val);\n                if ((0, util_1.isEmpty)(map.mapValue.fields)) {\n                    return null;\n                }\n            }\n            return map;\n        }\n        if (val === undefined && this.allowUndefined) {\n            return null;\n        }\n        throw new Error(`Cannot encode value: ${val}`);\n    }\n    /**\n     * @private\n     */\n    encodeVector(rawVector) {\n        // A Firestore Vector is a map with reserved key/value pairs.\n        return {\n            mapValue: {\n                fields: {\n                    [map_type_1.RESERVED_MAP_KEY]: {\n                        stringValue: map_type_1.RESERVED_MAP_KEY_VECTOR_VALUE,\n                    },\n                    [map_type_1.VECTOR_MAP_VECTORS_KEY]: {\n                        arrayValue: {\n                            values: rawVector.map(value => {\n                                return {\n                                    doubleValue: value,\n                                };\n                            }),\n                        },\n                    },\n                },\n            },\n        };\n    }\n    /**\n     * Decodes a single Firestore 'Value' Protobuf.\n     *\n     * @private\n     * @internal\n     * @param proto A Firestore 'Value' Protobuf.\n     * @returns The converted JS type.\n     */\n    decodeValue(proto) {\n        const valueType = (0, convert_1.detectValueType)(proto);\n        switch (valueType) {\n            case 'stringValue': {\n                return proto.stringValue;\n            }\n            case 'booleanValue': {\n                return proto.booleanValue;\n            }\n            case 'integerValue': {\n                return this.createInteger(proto.integerValue);\n            }\n            case 'doubleValue': {\n                return proto.doubleValue;\n            }\n            case 'timestampValue': {\n                return timestamp_1.Timestamp.fromProto(proto.timestampValue);\n            }\n            case 'referenceValue': {\n                const resourcePath = path_1.QualifiedResourcePath.fromSlashSeparatedString(proto.referenceValue);\n                return this.createReference(resourcePath.relativeName);\n            }\n            case 'arrayValue': {\n                const array = [];\n                if (Array.isArray(proto.arrayValue.values)) {\n                    for (const value of proto.arrayValue.values) {\n                        array.push(this.decodeValue(value));\n                    }\n                }\n                return array;\n            }\n            case 'nullValue': {\n                return null;\n            }\n            case 'mapValue': {\n                const fields = proto.mapValue.fields;\n                if (fields) {\n                    const obj = {};\n                    for (const prop of Object.keys(fields)) {\n                        obj[prop] = this.decodeValue(fields[prop]);\n                    }\n                    return obj;\n                }\n                else {\n                    return {};\n                }\n            }\n            case 'vectorValue': {\n                const fields = proto.mapValue.fields;\n                return field_value_1.VectorValue._fromProto(fields[map_type_1.VECTOR_MAP_VECTORS_KEY]);\n            }\n            case 'geoPointValue': {\n                return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);\n            }\n            case 'bytesValue': {\n                return proto.bytesValue;\n            }\n            default: {\n                throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));\n            }\n        }\n    }\n    /**\n     * Decodes a google.protobuf.Value\n     *\n     * @private\n     * @internal\n     * @param proto A Google Protobuf 'Value'.\n     * @returns The converted JS type.\n     */\n    decodeGoogleProtobufValue(proto) {\n        switch ((0, convert_1.detectGoogleProtobufValueType)(proto)) {\n            case 'nullValue': {\n                return null;\n            }\n            case 'numberValue': {\n                return proto.numberValue;\n            }\n            case 'stringValue': {\n                return proto.stringValue;\n            }\n            case 'boolValue': {\n                return proto.boolValue;\n            }\n            case 'listValue': {\n                return this.decodeGoogleProtobufList(proto.listValue);\n            }\n            case 'structValue': {\n                return this.decodeGoogleProtobufStruct(proto.structValue);\n            }\n            default: {\n                throw new Error('Cannot decode type from google.protobuf.Value: ' +\n                    JSON.stringify(proto));\n            }\n        }\n    }\n    /**\n     * Decodes a google.protobuf.ListValue\n     *\n     * @private\n     * @internal\n     * @param proto A Google Protobuf 'ListValue'.\n     * @returns The converted JS type.\n     */\n    decodeGoogleProtobufList(proto) {\n        const result = [];\n        if (proto && proto.values && Array.isArray(proto.values)) {\n            for (const value of proto.values) {\n                result.push(this.decodeGoogleProtobufValue(value));\n            }\n        }\n        return result;\n    }\n    /**\n     * Decodes a google.protobuf.Struct\n     *\n     * @private\n     * @internal\n     * @param proto A Google Protobuf 'Struct'.\n     * @returns The converted JS type.\n     */\n    decodeGoogleProtobufStruct(proto) {\n        const result = {};\n        if (proto && proto.fields) {\n            for (const prop of Object.keys(proto.fields)) {\n                result[prop] = this.decodeGoogleProtobufValue(proto.fields[prop]);\n            }\n        }\n        return result;\n    }\n}\nexports.Serializer = Serializer;\n/**\n * Validates a JavaScript value for usage as a Firestore value.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value JavaScript value to validate.\n * @param desc A description of the expected type.\n * @param path The field path to validate.\n * @param options Validation options\n * @param level The current depth of the traversal. This is used to decide\n * whether undefined values or deletes are allowed.\n * @param inArray Whether we are inside an array.\n * @throws when the object is invalid.\n */\nfunction validateUserInput(arg, value, desc, options, path, level, inArray) {\n    if (path && path.size - 1 > MAX_DEPTH) {\n        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} Input object is deeper than ${MAX_DEPTH} levels or contains a cycle.`);\n    }\n    level = level || 0;\n    inArray = inArray || false;\n    const fieldPathMessage = path ? ` (found in field \"${path}\")` : '';\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; ++i) {\n            validateUserInput(arg, value[i], desc, options, path ? path.append(String(i)) : new path_1.FieldPath(String(i)), level + 1, \n            /* inArray= */ true);\n        }\n    }\n    else if ((0, util_1.isPlainObject)(value)) {\n        for (const prop of Object.keys(value)) {\n            validateUserInput(arg, value[prop], desc, options, path ? path.append(new path_1.FieldPath(prop)) : new path_1.FieldPath(prop), level + 1, inArray);\n        }\n    }\n    else if (value === undefined) {\n        if (options.allowUndefined && level === 0) {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} \"undefined\" values are only ignored inside of objects.`);\n        }\n        else if (!options.allowUndefined) {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} Cannot use \"undefined\" as a Firestore value${fieldPathMessage}. ` +\n                'If you want to ignore undefined values, enable `ignoreUndefinedProperties`.');\n        }\n    }\n    else if (value instanceof field_value_1.VectorValue) {\n        // OK\n    }\n    else if (value instanceof field_value_1.DeleteTransform) {\n        if (inArray) {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() cannot be used inside of an array${fieldPathMessage}.`);\n        }\n        else if (options.allowDeletes === 'none') {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() must appear at the top-level and can only be used in update() ` +\n                `or set() with {merge:true}${fieldPathMessage}.`);\n        }\n        else if (options.allowDeletes === 'root') {\n            if (level === 0) {\n                // Ok (update() with UpdateData).\n            }\n            else if (level === 1 && (path === null || path === void 0 ? void 0 : path.size) === 1) {\n                // Ok (update with varargs).\n            }\n            else {\n                throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() must appear at the top-level and can only be used in update() ` +\n                    `or set() with {merge:true}${fieldPathMessage}.`);\n            }\n        }\n    }\n    else if (value instanceof field_value_1.FieldTransform) {\n        if (inArray) {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() cannot be used inside of an array${fieldPathMessage}.`);\n        }\n        else if (!options.allowTransforms) {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} ${value.methodName}() can only be used in set(), create() or update()${fieldPathMessage}.`);\n        }\n    }\n    else if (value instanceof path_1.FieldPath) {\n        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, desc)} Cannot use object of type \"FieldPath\" as a Firestore value${fieldPathMessage}.`);\n    }\n    else if (value instanceof index_1.DocumentReference) {\n        // Ok.\n    }\n    else if (value instanceof geo_point_1.GeoPoint) {\n        // Ok.\n    }\n    else if (value instanceof timestamp_1.Timestamp || value instanceof Date) {\n        // Ok.\n    }\n    else if (isMomentJsType(value)) {\n        // Ok.\n    }\n    else if (value instanceof Buffer || value instanceof Uint8Array) {\n        // Ok.\n    }\n    else if (value === null) {\n        // Ok.\n    }\n    else if (typeof value === 'object') {\n        throw new Error((0, validate_1.customObjectMessage)(arg, value, path));\n    }\n}\n/**\n * Returns true if value is a MomentJs date object.\n * @private\n * @internal\n */\nfunction isMomentJsType(value) {\n    return (typeof value === 'object' &&\n        value !== null &&\n        value.constructor &&\n        value.constructor.name === 'Moment' &&\n        typeof value.toDate === 'function');\n}\n//# sourceMappingURL=serializer.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}