{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2021 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DocumentReader = void 0;\nconst document_1 = require(\"./document\");\nconst util_1 = require(\"./util\");\nconst logger_1 = require(\"./logger\");\nconst timestamp_1 = require(\"./timestamp\");\n/**\n * A wrapper around BatchGetDocumentsRequest that retries request upon stream\n * failure and returns ordered results.\n *\n * @private\n * @internal\n */\nclass DocumentReader {\n  /**\n   * Creates a new DocumentReader that fetches the provided documents (via\n   * `get()`).\n   *\n   * @param firestore The Firestore instance to use.\n   * @param allDocuments The documents to get.\n   * @param fieldMask An optional field mask to apply to this read\n   * @param transactionOrReadTime An optional transaction ID to use for this\n   * read or options for beginning a new transaction with this read\n   */\n  constructor(firestore, allDocuments, fieldMask, transactionOrReadTime) {\n    this.firestore = firestore;\n    this.allDocuments = allDocuments;\n    this.fieldMask = fieldMask;\n    this.transactionOrReadTime = transactionOrReadTime;\n    this.outstandingDocuments = new Set();\n    this.retrievedDocuments = new Map();\n    for (const docRef of this.allDocuments) {\n      this.outstandingDocuments.add(docRef.formattedName);\n    }\n  }\n  /**\n   * Invokes the BatchGetDocuments RPC and returns the results as an array of\n   * documents.\n   *\n   * @param requestTag A unique client-assigned identifier for this request.\n   */\n  async get(requestTag) {\n    const {\n      result\n    } = await this._get(requestTag);\n    return result;\n  }\n  /**\n   * Invokes the BatchGetDocuments RPC and returns the results with transaction\n   * metadata.\n   *\n   * @param requestTag A unique client-assigned identifier for this request.\n   */\n  async _get(requestTag) {\n    await this.fetchDocuments(requestTag);\n    // BatchGetDocuments doesn't preserve document order. We use the request\n    // order to sort the resulting documents.\n    const orderedDocuments = [];\n    for (const docRef of this.allDocuments) {\n      const document = this.retrievedDocuments.get(docRef.formattedName);\n      if (document !== undefined) {\n        // Recreate the DocumentSnapshot with the DocumentReference\n        // containing the original converter.\n        const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);\n        finalDoc.fieldsProto = document._fieldsProto;\n        finalDoc.readTime = document.readTime;\n        finalDoc.createTime = document.createTime;\n        finalDoc.updateTime = document.updateTime;\n        orderedDocuments.push(finalDoc.build());\n      } else {\n        throw new Error(`Did not receive document for \"${docRef.path}\".`);\n      }\n    }\n    return {\n      result: orderedDocuments,\n      transaction: this.retrievedTransactionId\n    };\n  }\n  async fetchDocuments(requestTag) {\n    var _a;\n    if (!this.outstandingDocuments.size) {\n      return;\n    }\n    const request = {\n      database: this.firestore.formattedName,\n      documents: Array.from(this.outstandingDocuments)\n    };\n    if (this.transactionOrReadTime instanceof Uint8Array) {\n      request.transaction = this.transactionOrReadTime;\n    } else if (this.transactionOrReadTime instanceof timestamp_1.Timestamp) {\n      request.readTime = this.transactionOrReadTime.toProto().timestampValue;\n    } else if (this.transactionOrReadTime) {\n      request.newTransaction = this.transactionOrReadTime;\n    }\n    if (this.fieldMask) {\n      const fieldPaths = this.fieldMask.map(fieldPath => fieldPath.formattedName);\n      request.mask = {\n        fieldPaths\n      };\n    }\n    let resultCount = 0;\n    try {\n      const stream = await this.firestore.requestStream('batchGetDocuments', /* bidirectional= */false, request, requestTag);\n      stream.resume();\n      for await (const response of stream) {\n        // Proto comes with zero-length buffer by default\n        if ((_a = response.transaction) === null || _a === void 0 ? void 0 : _a.length) {\n          this.retrievedTransactionId = response.transaction;\n        }\n        let snapshot;\n        if (response.found) {\n          (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received document: %s', response.found.name);\n          snapshot = this.firestore.snapshot_(response.found, response.readTime);\n        } else if (response.missing) {\n          (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Document missing: %s', response.missing);\n          snapshot = this.firestore.snapshot_(response.missing, response.readTime);\n        }\n        if (snapshot) {\n          const path = snapshot.ref.formattedName;\n          this.outstandingDocuments.delete(path);\n          this.retrievedDocuments.set(path, snapshot);\n          ++resultCount;\n        }\n      }\n    } catch (error) {\n      const shouldRetry =\n      // Transactional reads are retried via the transaction runner.\n      !request.transaction && !request.newTransaction &&\n      // Only retry if we made progress.\n      resultCount > 0 &&\n      // Don't retry permanent errors.\n      error.code !== undefined && !(0, util_1.isPermanentRpcError)(error, 'batchGetDocuments');\n      (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'BatchGetDocuments failed with error: %s. Retrying: %s', error, shouldRetry);\n      if (shouldRetry) {\n        return this.fetchDocuments(requestTag);\n      } else {\n        throw error;\n      }\n    } finally {\n      (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received %d results', resultCount);\n    }\n  }\n}\nexports.DocumentReader = DocumentReader;","map":{"version":3,"names":["Object","defineProperty","exports","value","DocumentReader","document_1","require","util_1","logger_1","timestamp_1","constructor","firestore","allDocuments","fieldMask","transactionOrReadTime","outstandingDocuments","Set","retrievedDocuments","Map","docRef","add","formattedName","get","requestTag","result","_get","fetchDocuments","orderedDocuments","document","undefined","finalDoc","DocumentSnapshotBuilder","fieldsProto","_fieldsProto","readTime","createTime","updateTime","push","build","Error","path","transaction","retrievedTransactionId","_a","size","request","database","documents","Array","from","Uint8Array","Timestamp","toProto","timestampValue","newTransaction","fieldPaths","map","fieldPath","mask","resultCount","stream","requestStream","resume","response","length","snapshot","found","logger","name","snapshot_","missing","ref","delete","set","error","shouldRetry","code","isPermanentRpcError"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@google-cloud/firestore/build/src/document-reader.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2021 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DocumentReader = void 0;\nconst document_1 = require(\"./document\");\nconst util_1 = require(\"./util\");\nconst logger_1 = require(\"./logger\");\nconst timestamp_1 = require(\"./timestamp\");\n/**\n * A wrapper around BatchGetDocumentsRequest that retries request upon stream\n * failure and returns ordered results.\n *\n * @private\n * @internal\n */\nclass DocumentReader {\n    /**\n     * Creates a new DocumentReader that fetches the provided documents (via\n     * `get()`).\n     *\n     * @param firestore The Firestore instance to use.\n     * @param allDocuments The documents to get.\n     * @param fieldMask An optional field mask to apply to this read\n     * @param transactionOrReadTime An optional transaction ID to use for this\n     * read or options for beginning a new transaction with this read\n     */\n    constructor(firestore, allDocuments, fieldMask, transactionOrReadTime) {\n        this.firestore = firestore;\n        this.allDocuments = allDocuments;\n        this.fieldMask = fieldMask;\n        this.transactionOrReadTime = transactionOrReadTime;\n        this.outstandingDocuments = new Set();\n        this.retrievedDocuments = new Map();\n        for (const docRef of this.allDocuments) {\n            this.outstandingDocuments.add(docRef.formattedName);\n        }\n    }\n    /**\n     * Invokes the BatchGetDocuments RPC and returns the results as an array of\n     * documents.\n     *\n     * @param requestTag A unique client-assigned identifier for this request.\n     */\n    async get(requestTag) {\n        const { result } = await this._get(requestTag);\n        return result;\n    }\n    /**\n     * Invokes the BatchGetDocuments RPC and returns the results with transaction\n     * metadata.\n     *\n     * @param requestTag A unique client-assigned identifier for this request.\n     */\n    async _get(requestTag) {\n        await this.fetchDocuments(requestTag);\n        // BatchGetDocuments doesn't preserve document order. We use the request\n        // order to sort the resulting documents.\n        const orderedDocuments = [];\n        for (const docRef of this.allDocuments) {\n            const document = this.retrievedDocuments.get(docRef.formattedName);\n            if (document !== undefined) {\n                // Recreate the DocumentSnapshot with the DocumentReference\n                // containing the original converter.\n                const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);\n                finalDoc.fieldsProto = document._fieldsProto;\n                finalDoc.readTime = document.readTime;\n                finalDoc.createTime = document.createTime;\n                finalDoc.updateTime = document.updateTime;\n                orderedDocuments.push(finalDoc.build());\n            }\n            else {\n                throw new Error(`Did not receive document for \"${docRef.path}\".`);\n            }\n        }\n        return {\n            result: orderedDocuments,\n            transaction: this.retrievedTransactionId,\n        };\n    }\n    async fetchDocuments(requestTag) {\n        var _a;\n        if (!this.outstandingDocuments.size) {\n            return;\n        }\n        const request = {\n            database: this.firestore.formattedName,\n            documents: Array.from(this.outstandingDocuments),\n        };\n        if (this.transactionOrReadTime instanceof Uint8Array) {\n            request.transaction = this.transactionOrReadTime;\n        }\n        else if (this.transactionOrReadTime instanceof timestamp_1.Timestamp) {\n            request.readTime = this.transactionOrReadTime.toProto().timestampValue;\n        }\n        else if (this.transactionOrReadTime) {\n            request.newTransaction = this.transactionOrReadTime;\n        }\n        if (this.fieldMask) {\n            const fieldPaths = this.fieldMask.map(fieldPath => fieldPath.formattedName);\n            request.mask = { fieldPaths };\n        }\n        let resultCount = 0;\n        try {\n            const stream = await this.firestore.requestStream('batchGetDocuments', \n            /* bidirectional= */ false, request, requestTag);\n            stream.resume();\n            for await (const response of stream) {\n                // Proto comes with zero-length buffer by default\n                if ((_a = response.transaction) === null || _a === void 0 ? void 0 : _a.length) {\n                    this.retrievedTransactionId = response.transaction;\n                }\n                let snapshot;\n                if (response.found) {\n                    (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received document: %s', response.found.name);\n                    snapshot = this.firestore.snapshot_(response.found, response.readTime);\n                }\n                else if (response.missing) {\n                    (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Document missing: %s', response.missing);\n                    snapshot = this.firestore.snapshot_(response.missing, response.readTime);\n                }\n                if (snapshot) {\n                    const path = snapshot.ref.formattedName;\n                    this.outstandingDocuments.delete(path);\n                    this.retrievedDocuments.set(path, snapshot);\n                    ++resultCount;\n                }\n            }\n        }\n        catch (error) {\n            const shouldRetry = \n            // Transactional reads are retried via the transaction runner.\n            !request.transaction &&\n                !request.newTransaction &&\n                // Only retry if we made progress.\n                resultCount > 0 &&\n                // Don't retry permanent errors.\n                error.code !== undefined &&\n                !(0, util_1.isPermanentRpcError)(error, 'batchGetDocuments');\n            (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'BatchGetDocuments failed with error: %s. Retrying: %s', error, shouldRetry);\n            if (shouldRetry) {\n                return this.fetchDocuments(requestTag);\n            }\n            else {\n                throw error;\n            }\n        }\n        finally {\n            (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received %d results', resultCount);\n        }\n    }\n}\nexports.DocumentReader = DocumentReader;\n//# sourceMappingURL=document-reader.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}