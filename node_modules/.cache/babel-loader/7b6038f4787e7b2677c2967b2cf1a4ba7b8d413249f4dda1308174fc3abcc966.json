{"ast":null,"code":"\"use strict\";\n\n// Copyright 2023 Google LLC\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.streamingRetryRequest = streamingRetryRequest;\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//     https://www.apache.org/licenses/LICENSE-2.0\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst {\n  PassThrough\n} = require('stream');\nconst DEFAULTS = {\n  /*\n    Max # of retries\n  */\n  maxRetries: 2\n};\n// In retry-request, you could pass parameters to request using the requestOpts parameter\n// when we called retry-request from gax, we always passed null\n// passing null here removes an unnecessary parameter from this implementation\nconst requestOps = null;\nconst objectMode = true; // we don't support objectMode being false\n/**\n * Localized adaptation derived from retry-request\n * @param opts - corresponds to https://github.com/googleapis/retry-request#opts-optional\n * @returns\n */\nfunction streamingRetryRequest(opts) {\n  opts = Object.assign({}, DEFAULTS, opts);\n  if (opts.request === undefined) {\n    throw new Error('A request function must be provided');\n  }\n  let numNoResponseAttempts = 0;\n  let streamResponseHandled = false;\n  let requestStream;\n  let delayStream;\n  const retryStream = new PassThrough({\n    objectMode: objectMode\n  });\n  makeRequest();\n  return retryStream;\n  function makeRequest() {\n    streamResponseHandled = false;\n    delayStream = new PassThrough({\n      objectMode: objectMode\n    });\n    requestStream = opts.request(requestOps);\n    requestStream\n    // gRPC via google-cloud-node can emit an `error` as well as a `response`\n    // Whichever it emits, we run with-- we can't run with both. That's what\n    // is up with the `streamResponseHandled` tracking.\n    .on('error', err => {\n      if (streamResponseHandled) {\n        return;\n      }\n      streamResponseHandled = true;\n      onResponse(err);\n    }).on('response', resp => {\n      if (streamResponseHandled) {\n        return;\n      }\n      streamResponseHandled = true;\n      onResponse(null, resp);\n    });\n    requestStream.pipe(delayStream);\n  }\n  function onResponse(err, response = null) {\n    // An error such as DNS resolution.\n    if (err) {\n      numNoResponseAttempts++;\n      if (numNoResponseAttempts <= opts.maxRetries) {\n        makeRequest();\n      } else {\n        retryStream.emit('error', err);\n      }\n      return;\n    }\n    // No more attempts need to be made, just continue on.\n    retryStream.emit('response', response);\n    delayStream.pipe(retryStream);\n    requestStream.on('error', () => {\n      // retryStream must be destroyed here for the stream handoff part of retries to function properly\n      // but the error event should not be passed - if it emits as part of .destroy()\n      // it will bubble up early to the caller\n      retryStream.destroy();\n    });\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","streamingRetryRequest","PassThrough","require","DEFAULTS","maxRetries","requestOps","objectMode","opts","assign","request","undefined","Error","numNoResponseAttempts","streamResponseHandled","requestStream","delayStream","retryStream","makeRequest","on","err","onResponse","resp","pipe","response","emit","destroy"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/google-gax/build/src/streamingRetryRequest.js"],"sourcesContent":["\"use strict\";\n// Copyright 2023 Google LLC\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.streamingRetryRequest = streamingRetryRequest;\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//     https://www.apache.org/licenses/LICENSE-2.0\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst { PassThrough } = require('stream');\nconst DEFAULTS = {\n    /*\n      Max # of retries\n    */\n    maxRetries: 2,\n};\n// In retry-request, you could pass parameters to request using the requestOpts parameter\n// when we called retry-request from gax, we always passed null\n// passing null here removes an unnecessary parameter from this implementation\nconst requestOps = null;\nconst objectMode = true; // we don't support objectMode being false\n/**\n * Localized adaptation derived from retry-request\n * @param opts - corresponds to https://github.com/googleapis/retry-request#opts-optional\n * @returns\n */\nfunction streamingRetryRequest(opts) {\n    opts = Object.assign({}, DEFAULTS, opts);\n    if (opts.request === undefined) {\n        throw new Error('A request function must be provided');\n    }\n    let numNoResponseAttempts = 0;\n    let streamResponseHandled = false;\n    let requestStream;\n    let delayStream;\n    const retryStream = new PassThrough({ objectMode: objectMode });\n    makeRequest();\n    return retryStream;\n    function makeRequest() {\n        streamResponseHandled = false;\n        delayStream = new PassThrough({ objectMode: objectMode });\n        requestStream = opts.request(requestOps);\n        requestStream\n            // gRPC via google-cloud-node can emit an `error` as well as a `response`\n            // Whichever it emits, we run with-- we can't run with both. That's what\n            // is up with the `streamResponseHandled` tracking.\n            .on('error', (err) => {\n            if (streamResponseHandled) {\n                return;\n            }\n            streamResponseHandled = true;\n            onResponse(err);\n        })\n            .on('response', (resp) => {\n            if (streamResponseHandled) {\n                return;\n            }\n            streamResponseHandled = true;\n            onResponse(null, resp);\n        });\n        requestStream.pipe(delayStream);\n    }\n    function onResponse(err, response = null) {\n        // An error such as DNS resolution.\n        if (err) {\n            numNoResponseAttempts++;\n            if (numNoResponseAttempts <= opts.maxRetries) {\n                makeRequest();\n            }\n            else {\n                retryStream.emit('error', err);\n            }\n            return;\n        }\n        // No more attempts need to be made, just continue on.\n        retryStream.emit('response', response);\n        delayStream.pipe(retryStream);\n        requestStream.on('error', () => {\n            // retryStream must be destroyed here for the stream handoff part of retries to function properly\n            // but the error event should not be passed - if it emits as part of .destroy()\n            // it will bubble up early to the caller\n            retryStream.destroy();\n        });\n    }\n}\n//# sourceMappingURL=streamingRetryRequest.js.map"],"mappings":"AAAA,YAAY;;AACZ;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,qBAAqB,GAAGA,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EAAEC;AAAY,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AACzC,MAAMC,QAAQ,GAAG;EACb;AACJ;AACA;EACIC,UAAU,EAAE;AAChB,CAAC;AACD;AACA;AACA;AACA,MAAMC,UAAU,GAAG,IAAI;AACvB,MAAMC,UAAU,GAAG,IAAI,CAAC,CAAC;AACzB;AACA;AACA;AACA;AACA;AACA,SAASN,qBAAqBA,CAACO,IAAI,EAAE;EACjCA,IAAI,GAAGX,MAAM,CAACY,MAAM,CAAC,CAAC,CAAC,EAAEL,QAAQ,EAAEI,IAAI,CAAC;EACxC,IAAIA,IAAI,CAACE,OAAO,KAAKC,SAAS,EAAE;IAC5B,MAAM,IAAIC,KAAK,CAAC,qCAAqC,CAAC;EAC1D;EACA,IAAIC,qBAAqB,GAAG,CAAC;EAC7B,IAAIC,qBAAqB,GAAG,KAAK;EACjC,IAAIC,aAAa;EACjB,IAAIC,WAAW;EACf,MAAMC,WAAW,GAAG,IAAIf,WAAW,CAAC;IAAEK,UAAU,EAAEA;EAAW,CAAC,CAAC;EAC/DW,WAAW,CAAC,CAAC;EACb,OAAOD,WAAW;EAClB,SAASC,WAAWA,CAAA,EAAG;IACnBJ,qBAAqB,GAAG,KAAK;IAC7BE,WAAW,GAAG,IAAId,WAAW,CAAC;MAAEK,UAAU,EAAEA;IAAW,CAAC,CAAC;IACzDQ,aAAa,GAAGP,IAAI,CAACE,OAAO,CAACJ,UAAU,CAAC;IACxCS;IACI;IACA;IACA;IAAA,CACCI,EAAE,CAAC,OAAO,EAAGC,GAAG,IAAK;MACtB,IAAIN,qBAAqB,EAAE;QACvB;MACJ;MACAA,qBAAqB,GAAG,IAAI;MAC5BO,UAAU,CAACD,GAAG,CAAC;IACnB,CAAC,CAAC,CACGD,EAAE,CAAC,UAAU,EAAGG,IAAI,IAAK;MAC1B,IAAIR,qBAAqB,EAAE;QACvB;MACJ;MACAA,qBAAqB,GAAG,IAAI;MAC5BO,UAAU,CAAC,IAAI,EAAEC,IAAI,CAAC;IAC1B,CAAC,CAAC;IACFP,aAAa,CAACQ,IAAI,CAACP,WAAW,CAAC;EACnC;EACA,SAASK,UAAUA,CAACD,GAAG,EAAEI,QAAQ,GAAG,IAAI,EAAE;IACtC;IACA,IAAIJ,GAAG,EAAE;MACLP,qBAAqB,EAAE;MACvB,IAAIA,qBAAqB,IAAIL,IAAI,CAACH,UAAU,EAAE;QAC1Ca,WAAW,CAAC,CAAC;MACjB,CAAC,MACI;QACDD,WAAW,CAACQ,IAAI,CAAC,OAAO,EAAEL,GAAG,CAAC;MAClC;MACA;IACJ;IACA;IACAH,WAAW,CAACQ,IAAI,CAAC,UAAU,EAAED,QAAQ,CAAC;IACtCR,WAAW,CAACO,IAAI,CAACN,WAAW,CAAC;IAC7BF,aAAa,CAACI,EAAE,CAAC,OAAO,EAAE,MAAM;MAC5B;MACA;MACA;MACAF,WAAW,CAACS,OAAO,CAAC,CAAC;IACzB,CAAC,CAAC;EACN;AACJ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}