{"ast":null,"code":"\"use strict\";\n\n/**\r\n * Wrappers for common types.\r\n * @type {Object.<string,IWrapper>}\r\n * @const\r\n */\nvar wrappers = exports;\nvar Message = require(\"./message\");\n\n/**\r\n * From object converter part of an {@link IWrapper}.\r\n * @typedef WrapperFromObjectConverter\r\n * @type {function}\r\n * @param {Object.<string,*>} object Plain object\r\n * @returns {Message<{}>} Message instance\r\n * @this Type\r\n */\n\n/**\r\n * To object converter part of an {@link IWrapper}.\r\n * @typedef WrapperToObjectConverter\r\n * @type {function}\r\n * @param {Message<{}>} message Message instance\r\n * @param {IConversionOptions} [options] Conversion options\r\n * @returns {Object.<string,*>} Plain object\r\n * @this Type\r\n */\n\n/**\r\n * Common type wrapper part of {@link wrappers}.\r\n * @interface IWrapper\r\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\r\n * @property {WrapperToObjectConverter} [toObject] To object converter\r\n */\n\n// Custom wrapper for Any\nwrappers[\".google.protobuf.Any\"] = {\n  fromObject: function (object) {\n    // unwrap value type if mapped\n    if (object && object[\"@type\"]) {\n      // Only use fully qualified type name after the last '/'\n      var name = object[\"@type\"].substring(object[\"@type\"].lastIndexOf(\"/\") + 1);\n      var type = this.lookup(name);\n      /* istanbul ignore else */\n      if (type) {\n        // type_url does not accept leading \".\"\n        var type_url = object[\"@type\"].charAt(0) === \".\" ? object[\"@type\"].slice(1) : object[\"@type\"];\n        // type_url prefix is optional, but path seperator is required\n        if (type_url.indexOf(\"/\") === -1) {\n          type_url = \"/\" + type_url;\n        }\n        return this.create({\n          type_url: type_url,\n          value: type.encode(type.fromObject(object)).finish()\n        });\n      }\n    }\n    return this.fromObject(object);\n  },\n  toObject: function (message, options) {\n    // Default prefix\n    var googleApi = \"type.googleapis.com/\";\n    var prefix = \"\";\n    var name = \"\";\n\n    // decode value if requested and unmapped\n    if (options && options.json && message.type_url && message.value) {\n      // Only use fully qualified type name after the last '/'\n      name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\n      // Separate the prefix used\n      prefix = message.type_url.substring(0, message.type_url.lastIndexOf(\"/\") + 1);\n      var type = this.lookup(name);\n      /* istanbul ignore else */\n      if (type) message = type.decode(message.value);\n    }\n\n    // wrap value if unmapped\n    if (!(message instanceof this.ctor) && message instanceof Message) {\n      var object = message.$type.toObject(message, options);\n      var messageName = message.$type.fullName[0] === \".\" ? message.$type.fullName.slice(1) : message.$type.fullName;\n      // Default to type.googleapis.com prefix if no prefix is used\n      if (prefix === \"\") {\n        prefix = googleApi;\n      }\n      name = prefix + messageName;\n      object[\"@type\"] = name;\n      return object;\n    }\n    return this.toObject(message, options);\n  }\n};","map":{"version":3,"names":["wrappers","exports","Message","require","fromObject","object","name","substring","lastIndexOf","type","lookup","type_url","charAt","slice","indexOf","create","value","encode","finish","toObject","message","options","googleApi","prefix","json","decode","ctor","$type","messageName","fullName"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/protobufjs/src/wrappers.js"],"sourcesContent":["\"use strict\";\r\n\r\n/**\r\n * Wrappers for common types.\r\n * @type {Object.<string,IWrapper>}\r\n * @const\r\n */\r\nvar wrappers = exports;\r\n\r\nvar Message = require(\"./message\");\r\n\r\n/**\r\n * From object converter part of an {@link IWrapper}.\r\n * @typedef WrapperFromObjectConverter\r\n * @type {function}\r\n * @param {Object.<string,*>} object Plain object\r\n * @returns {Message<{}>} Message instance\r\n * @this Type\r\n */\r\n\r\n/**\r\n * To object converter part of an {@link IWrapper}.\r\n * @typedef WrapperToObjectConverter\r\n * @type {function}\r\n * @param {Message<{}>} message Message instance\r\n * @param {IConversionOptions} [options] Conversion options\r\n * @returns {Object.<string,*>} Plain object\r\n * @this Type\r\n */\r\n\r\n/**\r\n * Common type wrapper part of {@link wrappers}.\r\n * @interface IWrapper\r\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\r\n * @property {WrapperToObjectConverter} [toObject] To object converter\r\n */\r\n\r\n// Custom wrapper for Any\r\nwrappers[\".google.protobuf.Any\"] = {\r\n\r\n    fromObject: function(object) {\r\n\r\n        // unwrap value type if mapped\r\n        if (object && object[\"@type\"]) {\r\n             // Only use fully qualified type name after the last '/'\r\n            var name = object[\"@type\"].substring(object[\"@type\"].lastIndexOf(\"/\") + 1);\r\n            var type = this.lookup(name);\r\n            /* istanbul ignore else */\r\n            if (type) {\r\n                // type_url does not accept leading \".\"\r\n                var type_url = object[\"@type\"].charAt(0) === \".\" ?\r\n                    object[\"@type\"].slice(1) : object[\"@type\"];\r\n                // type_url prefix is optional, but path seperator is required\r\n                if (type_url.indexOf(\"/\") === -1) {\r\n                    type_url = \"/\" + type_url;\r\n                }\r\n                return this.create({\r\n                    type_url: type_url,\r\n                    value: type.encode(type.fromObject(object)).finish()\r\n                });\r\n            }\r\n        }\r\n\r\n        return this.fromObject(object);\r\n    },\r\n\r\n    toObject: function(message, options) {\r\n\r\n        // Default prefix\r\n        var googleApi = \"type.googleapis.com/\";\r\n        var prefix = \"\";\r\n        var name = \"\";\r\n\r\n        // decode value if requested and unmapped\r\n        if (options && options.json && message.type_url && message.value) {\r\n            // Only use fully qualified type name after the last '/'\r\n            name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\r\n            // Separate the prefix used\r\n            prefix = message.type_url.substring(0, message.type_url.lastIndexOf(\"/\") + 1);\r\n            var type = this.lookup(name);\r\n            /* istanbul ignore else */\r\n            if (type)\r\n                message = type.decode(message.value);\r\n        }\r\n\r\n        // wrap value if unmapped\r\n        if (!(message instanceof this.ctor) && message instanceof Message) {\r\n            var object = message.$type.toObject(message, options);\r\n            var messageName = message.$type.fullName[0] === \".\" ?\r\n                message.$type.fullName.slice(1) : message.$type.fullName;\r\n            // Default to type.googleapis.com prefix if no prefix is used\r\n            if (prefix === \"\") {\r\n                prefix = googleApi;\r\n            }\r\n            name = prefix + messageName;\r\n            object[\"@type\"] = name;\r\n            return object;\r\n        }\r\n\r\n        return this.toObject(message, options);\r\n    }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}