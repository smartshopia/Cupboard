{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createApiCall = createApiCall;\n/**\n * Provides function wrappers that implement page streaming and retrying.\n */\nconst apiCaller_1 = require(\"./apiCaller\");\nconst gax_1 = require(\"./gax\");\nconst retries_1 = require(\"./normalCalls/retries\");\nconst timeout_1 = require(\"./normalCalls/timeout\");\nconst streamingApiCaller_1 = require(\"./streamingCalls/streamingApiCaller\");\nconst warnings_1 = require(\"./warnings\");\n/**\n * Converts an rpc call into an API call governed by the settings.\n *\n * In typical usage, `func` will be a promise to a callable used to make an rpc\n * request. This will mostly likely be a bound method from a request stub used\n * to make an rpc call. It is not a direct function but a Promise instance,\n * because of its asynchronism (typically, obtaining the auth information).\n *\n * The result is a function which manages the API call with the given settings\n * and the options on the invocation.\n *\n * @param {Promise<GRPCCall>|GRPCCall} func - is either a promise to be used to make\n *   a bare RPC call, or just a bare RPC call.\n * @param {CallSettings} settings - provides the settings for this call\n * @param {Descriptor} descriptor - optionally specify the descriptor for\n *   the method call.\n * @return {GaxCall} func - a bound method on a request stub used\n *   to make an rpc call.\n */\nfunction createApiCall(func, settings, descriptor,\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n_fallback // unused here, used in fallback.ts implementation\n) {\n  // we want to be able to accept both promise resolving to a function and a\n  // function. Currently client librares are only calling this method with a\n  // promise, but it will change.\n  const funcPromise = typeof func === 'function' ? Promise.resolve(func) : func;\n  // the following apiCaller will be used for all calls of this function...\n  const apiCaller = (0, apiCaller_1.createAPICaller)(settings, descriptor);\n  return (request, callOptions, callback) => {\n    var _a, _b;\n    let currentApiCaller = apiCaller;\n    let thisSettings;\n    if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\n      const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null && _b !== void 0 ? _b : false;\n      // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\n      const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\n      thisSettings = settings.merge(convertedRetryOptions);\n    } else {\n      thisSettings = settings.merge(callOptions);\n    }\n    // special case: if bundling is disabled for this one call,\n    // use default API caller instead\n    if (settings.isBundling && !thisSettings.isBundling) {\n      currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\n    }\n    const ongoingCall = currentApiCaller.init(callback);\n    funcPromise.then(func => {\n      var _a, _b;\n      var _c;\n      // Initially, the function is just what gRPC server stub contains.\n      func = currentApiCaller.wrap(func);\n      const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\n      const retry = thisSettings.retry;\n      if (streaming && retry) {\n        if (retry.retryCodes.length > 0 && retry.shouldRetryFn) {\n          (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\n          retry.retryCodes = [];\n        }\n        if (!currentApiCaller.descriptor.gaxStreamingRetries && retry.getResumptionRequestFn) {\n          throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\n        }\n      }\n      if (!streaming && retry) {\n        if (retry.shouldRetryFn) {\n          throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\n        }\n        if (retry.getResumptionRequestFn) {\n          throw new Error('Resumption strategy can only be used with server streaming retries');\n        }\n        if (retry.retryCodes && retry.retryCodes.length > 0) {\n          (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null && _b !== void 0 ? _b : _c.initialRpcTimeoutMillis = thisSettings.timeout;\n          return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\n        }\n      }\n      return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\n    }).then(apiCall => {\n      // After adding retries / timeouts, the call function becomes simpler:\n      // it only accepts request and callback.\n      currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\n    }).catch(err => {\n      currentApiCaller.fail(ongoingCall, err);\n    });\n    // Calls normally return a \"cancellable promise\" that can be used to `await` for the actual result,\n    // or to cancel the ongoing call.\n    return currentApiCaller.result(ongoingCall);\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","createApiCall","apiCaller_1","require","gax_1","retries_1","timeout_1","streamingApiCaller_1","warnings_1","func","settings","descriptor","_fallback","funcPromise","Promise","resolve","apiCaller","createAPICaller","request","callOptions","callback","_a","_b","currentApiCaller","thisSettings","StreamingApiCaller","gaxStreamingRetries","convertedRetryOptions","convertRetryOptions","merge","isBundling","undefined","ongoingCall","init","then","_c","wrap","streaming","retry","retryCodes","length","shouldRetryFn","warn","getResumptionRequestFn","Error","backoffSettings","initialRpcTimeoutMillis","timeout","retryable","otherArgs","apiName","addTimeoutArg","apiCall","call","catch","err","fail","result"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/google-gax/build/src/createApiCall.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createApiCall = createApiCall;\n/**\n * Provides function wrappers that implement page streaming and retrying.\n */\nconst apiCaller_1 = require(\"./apiCaller\");\nconst gax_1 = require(\"./gax\");\nconst retries_1 = require(\"./normalCalls/retries\");\nconst timeout_1 = require(\"./normalCalls/timeout\");\nconst streamingApiCaller_1 = require(\"./streamingCalls/streamingApiCaller\");\nconst warnings_1 = require(\"./warnings\");\n/**\n * Converts an rpc call into an API call governed by the settings.\n *\n * In typical usage, `func` will be a promise to a callable used to make an rpc\n * request. This will mostly likely be a bound method from a request stub used\n * to make an rpc call. It is not a direct function but a Promise instance,\n * because of its asynchronism (typically, obtaining the auth information).\n *\n * The result is a function which manages the API call with the given settings\n * and the options on the invocation.\n *\n * @param {Promise<GRPCCall>|GRPCCall} func - is either a promise to be used to make\n *   a bare RPC call, or just a bare RPC call.\n * @param {CallSettings} settings - provides the settings for this call\n * @param {Descriptor} descriptor - optionally specify the descriptor for\n *   the method call.\n * @return {GaxCall} func - a bound method on a request stub used\n *   to make an rpc call.\n */\nfunction createApiCall(func, settings, descriptor, \n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n_fallback // unused here, used in fallback.ts implementation\n) {\n    // we want to be able to accept both promise resolving to a function and a\n    // function. Currently client librares are only calling this method with a\n    // promise, but it will change.\n    const funcPromise = typeof func === 'function' ? Promise.resolve(func) : func;\n    // the following apiCaller will be used for all calls of this function...\n    const apiCaller = (0, apiCaller_1.createAPICaller)(settings, descriptor);\n    return (request, callOptions, callback) => {\n        var _a, _b;\n        let currentApiCaller = apiCaller;\n        let thisSettings;\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null && _b !== void 0 ? _b : false;\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\n            thisSettings = settings.merge(convertedRetryOptions);\n        }\n        else {\n            thisSettings = settings.merge(callOptions);\n        }\n        // special case: if bundling is disabled for this one call,\n        // use default API caller instead\n        if (settings.isBundling && !thisSettings.isBundling) {\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\n        }\n        const ongoingCall = currentApiCaller.init(callback);\n        funcPromise\n            .then((func) => {\n            var _a, _b;\n            var _c;\n            // Initially, the function is just what gRPC server stub contains.\n            func = currentApiCaller.wrap(func);\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\n            const retry = thisSettings.retry;\n            if (streaming && retry) {\n                if (retry.retryCodes.length > 0 && retry.shouldRetryFn) {\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\n                    retry.retryCodes = [];\n                }\n                if (!currentApiCaller.descriptor\n                    .gaxStreamingRetries &&\n                    retry.getResumptionRequestFn) {\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\n                }\n            }\n            if (!streaming && retry) {\n                if (retry.shouldRetryFn) {\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\n                }\n                if (retry.getResumptionRequestFn) {\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\n                }\n                if (retry.retryCodes && retry.retryCodes.length > 0) {\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null && _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\n                }\n            }\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\n        })\n            .then((apiCall) => {\n            // After adding retries / timeouts, the call function becomes simpler:\n            // it only accepts request and callback.\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\n        })\n            .catch(err => {\n            currentApiCaller.fail(ongoingCall, err);\n        });\n        // Calls normally return a \"cancellable promise\" that can be used to `await` for the actual result,\n        // or to cancel the ongoing call.\n        return currentApiCaller.result(ongoingCall);\n    };\n}\n//# sourceMappingURL=createApiCall.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}