{"ast":null,"code":"\"use strict\";\n\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toProto3JSON = void 0;\nconst any_1 = require(\"./any\");\nconst bytes_1 = require(\"./bytes\");\nconst util_1 = require(\"./util\");\nconst enum_1 = require(\"./enum\");\nconst value_1 = require(\"./value\");\nconst duration_1 = require(\"./duration\");\nconst timestamp_1 = require(\"./timestamp\");\nconst wrappers_1 = require(\"./wrappers\");\nconst fieldmask_1 = require(\"./fieldmask\");\n// Convert a single value, which might happen to be an instance of Long, to JSONValue\nfunction convertSingleValue(value) {\n  var _a;\n  if (typeof value === 'object') {\n    if (((_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'Long') {\n      return value.toString();\n    }\n    throw new Error(`toProto3JSON: don't know how to convert value ${value}`);\n  }\n  return value;\n}\nfunction toProto3JSON(obj, options) {\n  const objType = obj.$type;\n  if (!objType) {\n    throw new Error('Cannot serialize object to proto3 JSON since its .$type is unknown. Use Type.fromObject(obj) before calling toProto3JSON.');\n  }\n  objType.resolveAll();\n  const typeName = (0, util_1.getFullyQualifiedTypeName)(objType);\n  // Types that require special handling according to\n  // https://developers.google.com/protocol-buffers/docs/proto3#json\n  if (typeName === '.google.protobuf.Any') {\n    return (0, any_1.googleProtobufAnyToProto3JSON)(obj, options);\n  }\n  if (typeName === '.google.protobuf.Value') {\n    return (0, value_1.googleProtobufValueToProto3JSON)(obj);\n  }\n  if (typeName === '.google.protobuf.Struct') {\n    return (0, value_1.googleProtobufStructToProto3JSON)(obj);\n  }\n  if (typeName === '.google.protobuf.ListValue') {\n    return (0, value_1.googleProtobufListValueToProto3JSON)(obj);\n  }\n  if (typeName === '.google.protobuf.Duration') {\n    return (0, duration_1.googleProtobufDurationToProto3JSON)(obj);\n  }\n  if (typeName === '.google.protobuf.Timestamp') {\n    return (0, timestamp_1.googleProtobufTimestampToProto3JSON)(obj);\n  }\n  if (typeName === '.google.protobuf.FieldMask') {\n    return (0, fieldmask_1.googleProtobufFieldMaskToProto3JSON)(obj);\n  }\n  if (util_1.wrapperTypes.has(typeName)) {\n    return (0, wrappers_1.wrapperToProto3JSON)(obj);\n  }\n  const result = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const field = objType.fields[key];\n    const fieldResolvedType = field.resolvedType;\n    const fieldFullyQualifiedTypeName = fieldResolvedType ? (0, util_1.getFullyQualifiedTypeName)(fieldResolvedType) : null;\n    if (value === null) {\n      result[key] = null;\n      continue;\n    }\n    if (Array.isArray(value)) {\n      if (value.length === 0) {\n        // ignore repeated fields with no values\n        continue;\n      }\n      // if the repeated value has a complex type, convert it to proto3 JSON, otherwise use as is\n      result[key] = value.map(fieldResolvedType ? element => {\n        return toProto3JSON(element, options);\n      } : convertSingleValue);\n      continue;\n    }\n    if (field.map) {\n      const map = {};\n      for (const [mapKey, mapValue] of Object.entries(value)) {\n        // if the map value has a complex type, convert it to proto3 JSON, otherwise use as is\n        map[mapKey] = fieldResolvedType ? toProto3JSON(mapValue, options) : convertSingleValue(mapValue);\n      }\n      result[key] = map;\n      continue;\n    }\n    if (fieldFullyQualifiedTypeName === '.google.protobuf.NullValue') {\n      result[key] = null;\n      continue;\n    }\n    if (fieldResolvedType && 'values' in fieldResolvedType && value !== null) {\n      if (options === null || options === void 0 ? void 0 : options.numericEnums) {\n        result[key] = (0, enum_1.resolveEnumValueToNumber)(fieldResolvedType, value);\n      } else {\n        result[key] = (0, enum_1.resolveEnumValueToString)(fieldResolvedType, value);\n      }\n      continue;\n    }\n    if (fieldResolvedType) {\n      result[key] = toProto3JSON(value, options);\n      continue;\n    }\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null) {\n      if (typeof value === 'number' && !Number.isFinite(value)) {\n        result[key] = value.toString();\n        continue;\n      }\n      result[key] = value;\n      continue;\n    }\n    if (Buffer.isBuffer(value) || value instanceof Uint8Array) {\n      result[key] = (0, bytes_1.bytesToProto3JSON)(value);\n      continue;\n    }\n    result[key] = convertSingleValue(value);\n    continue;\n  }\n  return result;\n}\nexports.toProto3JSON = toProto3JSON;","map":{"version":3,"names":["any_1","require","bytes_1","util_1","enum_1","value_1","duration_1","timestamp_1","wrappers_1","fieldmask_1","convertSingleValue","value","_a","constructor","name","toString","Error","toProto3JSON","obj","options","objType","$type","resolveAll","typeName","getFullyQualifiedTypeName","googleProtobufAnyToProto3JSON","googleProtobufValueToProto3JSON","googleProtobufStructToProto3JSON","googleProtobufListValueToProto3JSON","googleProtobufDurationToProto3JSON","googleProtobufTimestampToProto3JSON","googleProtobufFieldMaskToProto3JSON","wrapperTypes","has","wrapperToProto3JSON","result","key","Object","entries","field","fields","fieldResolvedType","resolvedType","fieldFullyQualifiedTypeName","Array","isArray","length","map","element","mapKey","mapValue","numericEnums","resolveEnumValueToNumber","resolveEnumValueToString","Number","isFinite","Buffer","isBuffer","Uint8Array","bytesToProto3JSON","exports"],"sources":["../../typescript/src/toproto3json.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}