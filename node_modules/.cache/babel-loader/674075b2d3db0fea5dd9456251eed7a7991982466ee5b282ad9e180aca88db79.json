{"ast":null,"code":"\"use strict\";\n\nmodule.exports = tokenize;\nvar delimRe = /[\\s{}=;:[\\],'\"()<>]/g,\n  stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\n  stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\nvar setCommentRe = /^ *[*/]+ */,\n  setCommentAltRe = /^\\s*\\*?\\/*/,\n  setCommentSplitRe = /\\n/g,\n  whitespaceRe = /\\s/,\n  unescapeRe = /\\\\(.?)/g;\nvar unescapeMap = {\n  \"0\": \"\\0\",\n  \"r\": \"\\r\",\n  \"n\": \"\\n\",\n  \"t\": \"\\t\"\n};\n\n/**\r\n * Unescapes a string.\r\n * @param {string} str String to unescape\r\n * @returns {string} Unescaped string\r\n * @property {Object.<string,string>} map Special characters map\r\n * @memberof tokenize\r\n */\nfunction unescape(str) {\n  return str.replace(unescapeRe, function ($0, $1) {\n    switch ($1) {\n      case \"\\\\\":\n      case \"\":\n        return $1;\n      default:\n        return unescapeMap[$1] || \"\";\n    }\n  });\n}\ntokenize.unescape = unescape;\n\n/**\r\n * Gets the next token and advances.\r\n * @typedef TokenizerHandleNext\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\n\n/**\r\n * Peeks for the next token.\r\n * @typedef TokenizerHandlePeek\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\n\n/**\r\n * Pushes a token back to the stack.\r\n * @typedef TokenizerHandlePush\r\n * @type {function}\r\n * @param {string} token Token\r\n * @returns {undefined}\r\n */\n\n/**\r\n * Skips the next token.\r\n * @typedef TokenizerHandleSkip\r\n * @type {function}\r\n * @param {string} expected Expected token\r\n * @param {boolean} [optional=false] If optional\r\n * @returns {boolean} Whether the token matched\r\n * @throws {Error} If the token didn't match and is not optional\r\n */\n\n/**\r\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\r\n * @typedef TokenizerHandleCmnt\r\n * @type {function}\r\n * @param {number} [line] Line number\r\n * @returns {string|null} Comment text or `null` if none\r\n */\n\n/**\r\n * Handle object returned from {@link tokenize}.\r\n * @interface ITokenizerHandle\r\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\r\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\r\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\r\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\r\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\r\n * @property {number} line Current line number\r\n */\n\n/**\r\n * Tokenizes the given .proto source and returns an object with useful utility functions.\r\n * @param {string} source Source contents\r\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\r\n * @returns {ITokenizerHandle} Tokenizer handle\r\n */\nfunction tokenize(source, alternateCommentMode) {\n  /* eslint-disable callback-return */\n  source = source.toString();\n  var offset = 0,\n    length = source.length,\n    line = 1,\n    lastCommentLine = 0,\n    comments = {};\n  var stack = [];\n  var stringDelim = null;\n\n  /* istanbul ignore next */\n  /**\r\n   * Creates an error for illegal syntax.\r\n   * @param {string} subject Subject\r\n   * @returns {Error} Error created\r\n   * @inner\r\n   */\n  function illegal(subject) {\n    return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n  }\n\n  /**\r\n   * Reads a string till its end.\r\n   * @returns {string} String read\r\n   * @inner\r\n   */\n  function readString() {\n    var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n    re.lastIndex = offset - 1;\n    var match = re.exec(source);\n    if (!match) throw illegal(\"string\");\n    offset = re.lastIndex;\n    push(stringDelim);\n    stringDelim = null;\n    return unescape(match[1]);\n  }\n\n  /**\r\n   * Gets the character at `pos` within the source.\r\n   * @param {number} pos Position\r\n   * @returns {string} Character\r\n   * @inner\r\n   */\n  function charAt(pos) {\n    return source.charAt(pos);\n  }\n\n  /**\r\n   * Sets the current comment text.\r\n   * @param {number} start Start offset\r\n   * @param {number} end End offset\r\n   * @param {boolean} isLeading set if a leading comment\r\n   * @returns {undefined}\r\n   * @inner\r\n   */\n  function setComment(start, end, isLeading) {\n    var comment = {\n      type: source.charAt(start++),\n      lineEmpty: false,\n      leading: isLeading\n    };\n    var lookback;\n    if (alternateCommentMode) {\n      lookback = 2; // alternate comment parsing: \"//\" or \"/*\"\n    } else {\n      lookback = 3; // \"///\" or \"/**\"\n    }\n    var commentOffset = start - lookback,\n      c;\n    do {\n      if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === \"\\n\") {\n        comment.lineEmpty = true;\n        break;\n      }\n    } while (c === \" \" || c === \"\\t\");\n    var lines = source.substring(start, end).split(setCommentSplitRe);\n    for (var i = 0; i < lines.length; ++i) lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\").trim();\n    comment.text = lines.join(\"\\n\").trim();\n    comments[line] = comment;\n    lastCommentLine = line;\n  }\n  function isDoubleSlashCommentLine(startOffset) {\n    var endOffset = findEndOfLine(startOffset);\n\n    // see if remaining line matches comment pattern\n    var lineText = source.substring(startOffset, endOffset);\n    var isComment = /^\\s*\\/\\//.test(lineText);\n    return isComment;\n  }\n  function findEndOfLine(cursor) {\n    // find end of cursor's line\n    var endOffset = cursor;\n    while (endOffset < length && charAt(endOffset) !== \"\\n\") {\n      endOffset++;\n    }\n    return endOffset;\n  }\n\n  /**\r\n   * Obtains the next token.\r\n   * @returns {string|null} Next token or `null` on eof\r\n   * @inner\r\n   */\n  function next() {\n    if (stack.length > 0) return stack.shift();\n    if (stringDelim) return readString();\n    var repeat,\n      prev,\n      curr,\n      start,\n      isDoc,\n      isLeadingComment = offset === 0;\n    do {\n      if (offset === length) return null;\n      repeat = false;\n      while (whitespaceRe.test(curr = charAt(offset))) {\n        if (curr === \"\\n\") {\n          isLeadingComment = true;\n          ++line;\n        }\n        if (++offset === length) return null;\n      }\n      if (charAt(offset) === \"/\") {\n        if (++offset === length) {\n          throw illegal(\"comment\");\n        }\n        if (charAt(offset) === \"/\") {\n          // Line\n          if (!alternateCommentMode) {\n            // check for triple-slash comment\n            isDoc = charAt(start = offset + 1) === \"/\";\n            while (charAt(++offset) !== \"\\n\") {\n              if (offset === length) {\n                return null;\n              }\n            }\n            ++offset;\n            if (isDoc) {\n              setComment(start, offset - 1, isLeadingComment);\n              // Trailing comment cannot not be multi-line,\n              // so leading comment state should be reset to handle potential next comments\n              isLeadingComment = true;\n            }\n            ++line;\n            repeat = true;\n          } else {\n            // check for double-slash comments, consolidating consecutive lines\n            start = offset;\n            isDoc = false;\n            if (isDoubleSlashCommentLine(offset - 1)) {\n              isDoc = true;\n              do {\n                offset = findEndOfLine(offset);\n                if (offset === length) {\n                  break;\n                }\n                offset++;\n                if (!isLeadingComment) {\n                  // Trailing comment cannot not be multi-line\n                  break;\n                }\n              } while (isDoubleSlashCommentLine(offset));\n            } else {\n              offset = Math.min(length, findEndOfLine(offset) + 1);\n            }\n            if (isDoc) {\n              setComment(start, offset, isLeadingComment);\n              isLeadingComment = true;\n            }\n            line++;\n            repeat = true;\n          }\n        } else if ((curr = charAt(offset)) === \"*\") {\n          /* Block */\n          // check for /** (regular comment mode) or /* (alternate comment mode)\n          start = offset + 1;\n          isDoc = alternateCommentMode || charAt(start) === \"*\";\n          do {\n            if (curr === \"\\n\") {\n              ++line;\n            }\n            if (++offset === length) {\n              throw illegal(\"comment\");\n            }\n            prev = curr;\n            curr = charAt(offset);\n          } while (prev !== \"*\" || curr !== \"/\");\n          ++offset;\n          if (isDoc) {\n            setComment(start, offset - 2, isLeadingComment);\n            isLeadingComment = true;\n          }\n          repeat = true;\n        } else {\n          return \"/\";\n        }\n      }\n    } while (repeat);\n\n    // offset !== length if we got here\n\n    var end = offset;\n    delimRe.lastIndex = 0;\n    var delim = delimRe.test(charAt(end++));\n    if (!delim) while (end < length && !delimRe.test(charAt(end))) ++end;\n    var token = source.substring(offset, offset = end);\n    if (token === \"\\\"\" || token === \"'\") stringDelim = token;\n    return token;\n  }\n\n  /**\r\n   * Pushes a token back to the stack.\r\n   * @param {string} token Token\r\n   * @returns {undefined}\r\n   * @inner\r\n   */\n  function push(token) {\n    stack.push(token);\n  }\n\n  /**\r\n   * Peeks for the next token.\r\n   * @returns {string|null} Token or `null` on eof\r\n   * @inner\r\n   */\n  function peek() {\n    if (!stack.length) {\n      var token = next();\n      if (token === null) return null;\n      push(token);\n    }\n    return stack[0];\n  }\n\n  /**\r\n   * Skips a token.\r\n   * @param {string} expected Expected token\r\n   * @param {boolean} [optional=false] Whether the token is optional\r\n   * @returns {boolean} `true` when skipped, `false` if not\r\n   * @throws {Error} When a required token is not present\r\n   * @inner\r\n   */\n  function skip(expected, optional) {\n    var actual = peek(),\n      equals = actual === expected;\n    if (equals) {\n      next();\n      return true;\n    }\n    if (!optional) throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n    return false;\n  }\n\n  /**\r\n   * Gets a comment.\r\n   * @param {number} [trailingLine] Line number if looking for a trailing comment\r\n   * @returns {string|null} Comment text\r\n   * @inner\r\n   */\n  function cmnt(trailingLine) {\n    var ret = null;\n    var comment;\n    if (trailingLine === undefined) {\n      comment = comments[line - 1];\n      delete comments[line - 1];\n      if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\n        ret = comment.leading ? comment.text : null;\n      }\n    } else {\n      /* istanbul ignore else */\n      if (lastCommentLine < trailingLine) {\n        peek();\n      }\n      comment = comments[trailingLine];\n      delete comments[trailingLine];\n      if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\n        ret = comment.leading ? null : comment.text;\n      }\n    }\n    return ret;\n  }\n  return Object.defineProperty({\n    next: next,\n    peek: peek,\n    push: push,\n    skip: skip,\n    cmnt: cmnt\n  }, \"line\", {\n    get: function () {\n      return line;\n    }\n  });\n  /* eslint-enable callback-return */\n}","map":{"version":3,"names":["module","exports","tokenize","delimRe","stringDoubleRe","stringSingleRe","setCommentRe","setCommentAltRe","setCommentSplitRe","whitespaceRe","unescapeRe","unescapeMap","unescape","str","replace","$0","$1","source","alternateCommentMode","toString","offset","length","line","lastCommentLine","comments","stack","stringDelim","illegal","subject","Error","readString","re","lastIndex","match","exec","push","charAt","pos","setComment","start","end","isLeading","comment","type","lineEmpty","leading","lookback","commentOffset","c","lines","substring","split","i","trim","text","join","isDoubleSlashCommentLine","startOffset","endOffset","findEndOfLine","lineText","isComment","test","cursor","next","shift","repeat","prev","curr","isDoc","isLeadingComment","Math","min","delim","token","peek","skip","expected","optional","actual","equals","cmnt","trailingLine","ret","undefined","Object","defineProperty","get"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/protobufjs/src/tokenize.js"],"sourcesContent":["\"use strict\";\r\nmodule.exports = tokenize;\r\n\r\nvar delimRe        = /[\\s{}=;:[\\],'\"()<>]/g,\r\n    stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\r\n    stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\r\n\r\nvar setCommentRe = /^ *[*/]+ */,\r\n    setCommentAltRe = /^\\s*\\*?\\/*/,\r\n    setCommentSplitRe = /\\n/g,\r\n    whitespaceRe = /\\s/,\r\n    unescapeRe = /\\\\(.?)/g;\r\n\r\nvar unescapeMap = {\r\n    \"0\": \"\\0\",\r\n    \"r\": \"\\r\",\r\n    \"n\": \"\\n\",\r\n    \"t\": \"\\t\"\r\n};\r\n\r\n/**\r\n * Unescapes a string.\r\n * @param {string} str String to unescape\r\n * @returns {string} Unescaped string\r\n * @property {Object.<string,string>} map Special characters map\r\n * @memberof tokenize\r\n */\r\nfunction unescape(str) {\r\n    return str.replace(unescapeRe, function($0, $1) {\r\n        switch ($1) {\r\n            case \"\\\\\":\r\n            case \"\":\r\n                return $1;\r\n            default:\r\n                return unescapeMap[$1] || \"\";\r\n        }\r\n    });\r\n}\r\n\r\ntokenize.unescape = unescape;\r\n\r\n/**\r\n * Gets the next token and advances.\r\n * @typedef TokenizerHandleNext\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\r\n\r\n/**\r\n * Peeks for the next token.\r\n * @typedef TokenizerHandlePeek\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\r\n\r\n/**\r\n * Pushes a token back to the stack.\r\n * @typedef TokenizerHandlePush\r\n * @type {function}\r\n * @param {string} token Token\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Skips the next token.\r\n * @typedef TokenizerHandleSkip\r\n * @type {function}\r\n * @param {string} expected Expected token\r\n * @param {boolean} [optional=false] If optional\r\n * @returns {boolean} Whether the token matched\r\n * @throws {Error} If the token didn't match and is not optional\r\n */\r\n\r\n/**\r\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\r\n * @typedef TokenizerHandleCmnt\r\n * @type {function}\r\n * @param {number} [line] Line number\r\n * @returns {string|null} Comment text or `null` if none\r\n */\r\n\r\n/**\r\n * Handle object returned from {@link tokenize}.\r\n * @interface ITokenizerHandle\r\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\r\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\r\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\r\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\r\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\r\n * @property {number} line Current line number\r\n */\r\n\r\n/**\r\n * Tokenizes the given .proto source and returns an object with useful utility functions.\r\n * @param {string} source Source contents\r\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\r\n * @returns {ITokenizerHandle} Tokenizer handle\r\n */\r\nfunction tokenize(source, alternateCommentMode) {\r\n    /* eslint-disable callback-return */\r\n    source = source.toString();\r\n\r\n    var offset = 0,\r\n        length = source.length,\r\n        line = 1,\r\n        lastCommentLine = 0,\r\n        comments = {};\r\n\r\n    var stack = [];\r\n\r\n    var stringDelim = null;\r\n\r\n    /* istanbul ignore next */\r\n    /**\r\n     * Creates an error for illegal syntax.\r\n     * @param {string} subject Subject\r\n     * @returns {Error} Error created\r\n     * @inner\r\n     */\r\n    function illegal(subject) {\r\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\r\n    }\r\n\r\n    /**\r\n     * Reads a string till its end.\r\n     * @returns {string} String read\r\n     * @inner\r\n     */\r\n    function readString() {\r\n        var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\r\n        re.lastIndex = offset - 1;\r\n        var match = re.exec(source);\r\n        if (!match)\r\n            throw illegal(\"string\");\r\n        offset = re.lastIndex;\r\n        push(stringDelim);\r\n        stringDelim = null;\r\n        return unescape(match[1]);\r\n    }\r\n\r\n    /**\r\n     * Gets the character at `pos` within the source.\r\n     * @param {number} pos Position\r\n     * @returns {string} Character\r\n     * @inner\r\n     */\r\n    function charAt(pos) {\r\n        return source.charAt(pos);\r\n    }\r\n\r\n    /**\r\n     * Sets the current comment text.\r\n     * @param {number} start Start offset\r\n     * @param {number} end End offset\r\n     * @param {boolean} isLeading set if a leading comment\r\n     * @returns {undefined}\r\n     * @inner\r\n     */\r\n    function setComment(start, end, isLeading) {\r\n        var comment = {\r\n            type: source.charAt(start++),\r\n            lineEmpty: false,\r\n            leading: isLeading,\r\n        };\r\n        var lookback;\r\n        if (alternateCommentMode) {\r\n            lookback = 2;  // alternate comment parsing: \"//\" or \"/*\"\r\n        } else {\r\n            lookback = 3;  // \"///\" or \"/**\"\r\n        }\r\n        var commentOffset = start - lookback,\r\n            c;\r\n        do {\r\n            if (--commentOffset < 0 ||\r\n                    (c = source.charAt(commentOffset)) === \"\\n\") {\r\n                comment.lineEmpty = true;\r\n                break;\r\n            }\r\n        } while (c === \" \" || c === \"\\t\");\r\n        var lines = source\r\n            .substring(start, end)\r\n            .split(setCommentSplitRe);\r\n        for (var i = 0; i < lines.length; ++i)\r\n            lines[i] = lines[i]\r\n                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\")\r\n                .trim();\r\n        comment.text = lines\r\n            .join(\"\\n\")\r\n            .trim();\r\n\r\n        comments[line] = comment;\r\n        lastCommentLine = line;\r\n    }\r\n\r\n    function isDoubleSlashCommentLine(startOffset) {\r\n        var endOffset = findEndOfLine(startOffset);\r\n\r\n        // see if remaining line matches comment pattern\r\n        var lineText = source.substring(startOffset, endOffset);\r\n        var isComment = /^\\s*\\/\\//.test(lineText);\r\n        return isComment;\r\n    }\r\n\r\n    function findEndOfLine(cursor) {\r\n        // find end of cursor's line\r\n        var endOffset = cursor;\r\n        while (endOffset < length && charAt(endOffset) !== \"\\n\") {\r\n            endOffset++;\r\n        }\r\n        return endOffset;\r\n    }\r\n\r\n    /**\r\n     * Obtains the next token.\r\n     * @returns {string|null} Next token or `null` on eof\r\n     * @inner\r\n     */\r\n    function next() {\r\n        if (stack.length > 0)\r\n            return stack.shift();\r\n        if (stringDelim)\r\n            return readString();\r\n        var repeat,\r\n            prev,\r\n            curr,\r\n            start,\r\n            isDoc,\r\n            isLeadingComment = offset === 0;\r\n        do {\r\n            if (offset === length)\r\n                return null;\r\n            repeat = false;\r\n            while (whitespaceRe.test(curr = charAt(offset))) {\r\n                if (curr === \"\\n\") {\r\n                    isLeadingComment = true;\r\n                    ++line;\r\n                }\r\n                if (++offset === length)\r\n                    return null;\r\n            }\r\n\r\n            if (charAt(offset) === \"/\") {\r\n                if (++offset === length) {\r\n                    throw illegal(\"comment\");\r\n                }\r\n                if (charAt(offset) === \"/\") { // Line\r\n                    if (!alternateCommentMode) {\r\n                        // check for triple-slash comment\r\n                        isDoc = charAt(start = offset + 1) === \"/\";\r\n\r\n                        while (charAt(++offset) !== \"\\n\") {\r\n                            if (offset === length) {\r\n                                return null;\r\n                            }\r\n                        }\r\n                        ++offset;\r\n                        if (isDoc) {\r\n                            setComment(start, offset - 1, isLeadingComment);\r\n                            // Trailing comment cannot not be multi-line,\r\n                            // so leading comment state should be reset to handle potential next comments\r\n                            isLeadingComment = true;\r\n                        }\r\n                        ++line;\r\n                        repeat = true;\r\n                    } else {\r\n                        // check for double-slash comments, consolidating consecutive lines\r\n                        start = offset;\r\n                        isDoc = false;\r\n                        if (isDoubleSlashCommentLine(offset - 1)) {\r\n                            isDoc = true;\r\n                            do {\r\n                                offset = findEndOfLine(offset);\r\n                                if (offset === length) {\r\n                                    break;\r\n                                }\r\n                                offset++;\r\n                                if (!isLeadingComment) {\r\n                                    // Trailing comment cannot not be multi-line\r\n                                    break;\r\n                                }\r\n                            } while (isDoubleSlashCommentLine(offset));\r\n                        } else {\r\n                            offset = Math.min(length, findEndOfLine(offset) + 1);\r\n                        }\r\n                        if (isDoc) {\r\n                            setComment(start, offset, isLeadingComment);\r\n                            isLeadingComment = true;\r\n                        }\r\n                        line++;\r\n                        repeat = true;\r\n                    }\r\n                } else if ((curr = charAt(offset)) === \"*\") { /* Block */\r\n                    // check for /** (regular comment mode) or /* (alternate comment mode)\r\n                    start = offset + 1;\r\n                    isDoc = alternateCommentMode || charAt(start) === \"*\";\r\n                    do {\r\n                        if (curr === \"\\n\") {\r\n                            ++line;\r\n                        }\r\n                        if (++offset === length) {\r\n                            throw illegal(\"comment\");\r\n                        }\r\n                        prev = curr;\r\n                        curr = charAt(offset);\r\n                    } while (prev !== \"*\" || curr !== \"/\");\r\n                    ++offset;\r\n                    if (isDoc) {\r\n                        setComment(start, offset - 2, isLeadingComment);\r\n                        isLeadingComment = true;\r\n                    }\r\n                    repeat = true;\r\n                } else {\r\n                    return \"/\";\r\n                }\r\n            }\r\n        } while (repeat);\r\n\r\n        // offset !== length if we got here\r\n\r\n        var end = offset;\r\n        delimRe.lastIndex = 0;\r\n        var delim = delimRe.test(charAt(end++));\r\n        if (!delim)\r\n            while (end < length && !delimRe.test(charAt(end)))\r\n                ++end;\r\n        var token = source.substring(offset, offset = end);\r\n        if (token === \"\\\"\" || token === \"'\")\r\n            stringDelim = token;\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Pushes a token back to the stack.\r\n     * @param {string} token Token\r\n     * @returns {undefined}\r\n     * @inner\r\n     */\r\n    function push(token) {\r\n        stack.push(token);\r\n    }\r\n\r\n    /**\r\n     * Peeks for the next token.\r\n     * @returns {string|null} Token or `null` on eof\r\n     * @inner\r\n     */\r\n    function peek() {\r\n        if (!stack.length) {\r\n            var token = next();\r\n            if (token === null)\r\n                return null;\r\n            push(token);\r\n        }\r\n        return stack[0];\r\n    }\r\n\r\n    /**\r\n     * Skips a token.\r\n     * @param {string} expected Expected token\r\n     * @param {boolean} [optional=false] Whether the token is optional\r\n     * @returns {boolean} `true` when skipped, `false` if not\r\n     * @throws {Error} When a required token is not present\r\n     * @inner\r\n     */\r\n    function skip(expected, optional) {\r\n        var actual = peek(),\r\n            equals = actual === expected;\r\n        if (equals) {\r\n            next();\r\n            return true;\r\n        }\r\n        if (!optional)\r\n            throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a comment.\r\n     * @param {number} [trailingLine] Line number if looking for a trailing comment\r\n     * @returns {string|null} Comment text\r\n     * @inner\r\n     */\r\n    function cmnt(trailingLine) {\r\n        var ret = null;\r\n        var comment;\r\n        if (trailingLine === undefined) {\r\n            comment = comments[line - 1];\r\n            delete comments[line - 1];\r\n            if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\r\n                ret = comment.leading ? comment.text : null;\r\n            }\r\n        } else {\r\n            /* istanbul ignore else */\r\n            if (lastCommentLine < trailingLine) {\r\n                peek();\r\n            }\r\n            comment = comments[trailingLine];\r\n            delete comments[trailingLine];\r\n            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\r\n                ret = comment.leading ? null : comment.text;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    return Object.defineProperty({\r\n        next: next,\r\n        peek: peek,\r\n        push: push,\r\n        skip: skip,\r\n        cmnt: cmnt\r\n    }, \"line\", {\r\n        get: function() { return line; }\r\n    });\r\n    /* eslint-enable callback-return */\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}