{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClientPool = exports.CLIENT_TERMINATED_ERROR_MSG = void 0;\nconst assert = require(\"assert\");\nconst logger_1 = require(\"./logger\");\nconst util_1 = require(\"./util\");\nexports.CLIENT_TERMINATED_ERROR_MSG = 'The client has already been terminated';\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n * @internal\n */\nclass ClientPool {\n  /**\n   * @param concurrentOperationLimit The number of operations that each client\n   * can handle.\n   * @param maxIdleClients The maximum number of idle clients to keep before\n   * garbage collecting.\n   * @param clientFactory A factory function called as needed when new clients\n   * are required.\n   * @param clientDestructor A cleanup function that is called when a client is\n   * disposed of.\n   */\n  constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = () => Promise.resolve()) {\n    this.concurrentOperationLimit = concurrentOperationLimit;\n    this.maxIdleClients = maxIdleClients;\n    this.clientFactory = clientFactory;\n    this.clientDestructor = clientDestructor;\n    this.grpcEnabled = false;\n    /**\n     * Stores each active clients and how many operations it has outstanding.\n     */\n    this.activeClients = new Map();\n    /**\n     * A set of clients that have seen RST_STREAM errors (see\n     * https://github.com/googleapis/nodejs-firestore/issues/1023) and should\n     * no longer be used.\n     */\n    this.failedClients = new Set();\n    /**\n     * Whether the Firestore instance has been terminated. Once terminated, the\n     * ClientPool can longer schedule new operations.\n     */\n    this.terminated = false;\n    /**\n     * Deferred promise that is resolved when there are no active operations on\n     * the client pool after terminate() has been called.\n     */\n    this.terminateDeferred = new util_1.Deferred();\n  }\n  /**\n   * Returns an already existing client if it has less than the maximum number\n   * of concurrent operations or initializes and returns a new client.\n   *\n   * @private\n   * @internal\n   */\n  acquire(requestTag, requiresGrpc) {\n    let selectedClient = null;\n    let selectedClientRequestCount = -1;\n    // Transition to grpc when we see the first operation that requires grpc.\n    this.grpcEnabled = this.grpcEnabled || requiresGrpc;\n    // Require a grpc client for this operation if we have transitioned to grpc.\n    requiresGrpc = requiresGrpc || this.grpcEnabled;\n    for (const [client, metadata] of this.activeClients) {\n      // Use the \"most-full\" client that can still accommodate the request\n      // in order to maximize the number of idle clients as operations start to\n      // complete.\n      if (!this.failedClients.has(client) && metadata.activeRequestCount > selectedClientRequestCount && metadata.activeRequestCount < this.concurrentOperationLimit && (metadata.grpcEnabled || !requiresGrpc)) {\n        selectedClient = client;\n        selectedClientRequestCount = metadata.activeRequestCount;\n      }\n    }\n    if (selectedClient) {\n      (0, logger_1.logger)('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - selectedClientRequestCount);\n    } else {\n      (0, logger_1.logger)('ClientPool.acquire', requestTag, 'Creating a new client (requiresGrpc: %s)', requiresGrpc);\n      selectedClient = this.clientFactory(requiresGrpc);\n      selectedClientRequestCount = 0;\n      assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n    }\n    this.activeClients.set(selectedClient, {\n      grpcEnabled: requiresGrpc,\n      activeRequestCount: selectedClientRequestCount + 1\n    });\n    return selectedClient;\n  }\n  /**\n   * Reduces the number of operations for the provided client, potentially\n   * removing it from the pool of active clients.\n   * @private\n   * @internal\n   */\n  async release(requestTag, client) {\n    const metadata = this.activeClients.get(client);\n    assert(metadata && metadata.activeRequestCount > 0, 'No active requests');\n    this.activeClients.set(client, {\n      grpcEnabled: metadata.grpcEnabled,\n      activeRequestCount: metadata.activeRequestCount - 1\n    });\n    if (this.terminated && this.opCount === 0) {\n      this.terminateDeferred.resolve();\n    }\n    if (this.shouldGarbageCollectClient(client)) {\n      this.activeClients.delete(client);\n      this.failedClients.delete(client);\n      await this.clientDestructor(client);\n      (0, logger_1.logger)('ClientPool.release', requestTag, 'Garbage collected 1 client');\n    }\n  }\n  /**\n   * Given the current operation counts, determines if the given client should\n   * be garbage collected.\n   * @private\n   * @internal\n   */\n  shouldGarbageCollectClient(client) {\n    const clientMetadata = this.activeClients.get(client);\n    if (clientMetadata.activeRequestCount !== 0) {\n      // Don't garbage collect clients that have active requests.\n      return false;\n    }\n    if (this.grpcEnabled !== clientMetadata.grpcEnabled) {\n      // We are transitioning to GRPC. Garbage collect REST clients.\n      return true;\n    }\n    // Idle clients that have received RST_STREAM errors are always garbage\n    // collected.\n    if (this.failedClients.has(client)) {\n      return true;\n    }\n    // Otherwise, only garbage collect if we have too much idle capacity (e.g.\n    // more than 100 idle capacity with default settings).\n    let idleCapacityCount = 0;\n    for (const [, metadata] of this.activeClients) {\n      idleCapacityCount += this.concurrentOperationLimit - metadata.activeRequestCount;\n    }\n    return idleCapacityCount > this.maxIdleClients * this.concurrentOperationLimit;\n  }\n  /**\n   * The number of currently registered clients.\n   *\n   * @return Number of currently registered clients.\n   * @private\n   * @internal\n   */\n  // Visible for testing.\n  get size() {\n    return this.activeClients.size;\n  }\n  /**\n   * The number of currently active operations.\n   *\n   * @return Number of currently active operations.\n   * @private\n   * @internal\n   */\n  // Visible for testing.\n  get opCount() {\n    let activeOperationCount = 0;\n    this.activeClients.forEach(metadata => activeOperationCount += metadata.activeRequestCount);\n    return activeOperationCount;\n  }\n  /**\n   * The currently active clients.\n   *\n   * @return The currently active clients.\n   * @private\n   * @internal\n   */\n  // Visible for testing.\n  get _activeClients() {\n    return this.activeClients;\n  }\n  /**\n   * Runs the provided operation in this pool. This function may create an\n   * additional client if all existing clients already operate at the concurrent\n   * operation limit.\n   *\n   * @param requestTag A unique client-assigned identifier for this operation.\n   * @param op A callback function that returns a Promise. The client T will\n   * be returned to the pool when callback finishes.\n   * @return A Promise that resolves with the result of `op`.\n   * @private\n   * @internal\n   */\n  run(requestTag, requiresGrpc, op) {\n    if (this.terminated) {\n      return Promise.reject(new Error(exports.CLIENT_TERMINATED_ERROR_MSG));\n    }\n    const client = this.acquire(requestTag, requiresGrpc);\n    return op(client).catch(async err => {\n      var _a;\n      if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.match(/RST_STREAM/)) {\n        // Once a client has seen a RST_STREAM error, the GRPC channel can\n        // no longer be used. We mark the client as failed, which ensures that\n        // we open a new GRPC channel for the next request.\n        this.failedClients.add(client);\n      }\n      await this.release(requestTag, client);\n      return Promise.reject(err);\n    }).then(async res => {\n      await this.release(requestTag, client);\n      return res;\n    });\n  }\n  async terminate() {\n    this.terminated = true;\n    // Wait for all pending operations to complete before terminating.\n    if (this.opCount > 0) {\n      (0, logger_1.logger)('ClientPool.terminate', /* requestTag= */null, 'Waiting for %s pending operations to complete before terminating', this.opCount);\n      await this.terminateDeferred.promise;\n    }\n    for (const [client] of this.activeClients) {\n      this.activeClients.delete(client);\n      await this.clientDestructor(client);\n    }\n  }\n}\nexports.ClientPool = ClientPool;","map":{"version":3,"names":["Object","defineProperty","exports","value","ClientPool","CLIENT_TERMINATED_ERROR_MSG","assert","require","logger_1","util_1","constructor","concurrentOperationLimit","maxIdleClients","clientFactory","clientDestructor","Promise","resolve","grpcEnabled","activeClients","Map","failedClients","Set","terminated","terminateDeferred","Deferred","acquire","requestTag","requiresGrpc","selectedClient","selectedClientRequestCount","client","metadata","has","activeRequestCount","logger","set","release","get","opCount","shouldGarbageCollectClient","delete","clientMetadata","idleCapacityCount","size","activeOperationCount","forEach","_activeClients","run","op","reject","Error","catch","err","_a","message","match","add","then","res","terminate","promise"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@google-cloud/firestore/build/src/pool.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientPool = exports.CLIENT_TERMINATED_ERROR_MSG = void 0;\nconst assert = require(\"assert\");\nconst logger_1 = require(\"./logger\");\nconst util_1 = require(\"./util\");\nexports.CLIENT_TERMINATED_ERROR_MSG = 'The client has already been terminated';\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n * @internal\n */\nclass ClientPool {\n    /**\n     * @param concurrentOperationLimit The number of operations that each client\n     * can handle.\n     * @param maxIdleClients The maximum number of idle clients to keep before\n     * garbage collecting.\n     * @param clientFactory A factory function called as needed when new clients\n     * are required.\n     * @param clientDestructor A cleanup function that is called when a client is\n     * disposed of.\n     */\n    constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = () => Promise.resolve()) {\n        this.concurrentOperationLimit = concurrentOperationLimit;\n        this.maxIdleClients = maxIdleClients;\n        this.clientFactory = clientFactory;\n        this.clientDestructor = clientDestructor;\n        this.grpcEnabled = false;\n        /**\n         * Stores each active clients and how many operations it has outstanding.\n         */\n        this.activeClients = new Map();\n        /**\n         * A set of clients that have seen RST_STREAM errors (see\n         * https://github.com/googleapis/nodejs-firestore/issues/1023) and should\n         * no longer be used.\n         */\n        this.failedClients = new Set();\n        /**\n         * Whether the Firestore instance has been terminated. Once terminated, the\n         * ClientPool can longer schedule new operations.\n         */\n        this.terminated = false;\n        /**\n         * Deferred promise that is resolved when there are no active operations on\n         * the client pool after terminate() has been called.\n         */\n        this.terminateDeferred = new util_1.Deferred();\n    }\n    /**\n     * Returns an already existing client if it has less than the maximum number\n     * of concurrent operations or initializes and returns a new client.\n     *\n     * @private\n     * @internal\n     */\n    acquire(requestTag, requiresGrpc) {\n        let selectedClient = null;\n        let selectedClientRequestCount = -1;\n        // Transition to grpc when we see the first operation that requires grpc.\n        this.grpcEnabled = this.grpcEnabled || requiresGrpc;\n        // Require a grpc client for this operation if we have transitioned to grpc.\n        requiresGrpc = requiresGrpc || this.grpcEnabled;\n        for (const [client, metadata] of this.activeClients) {\n            // Use the \"most-full\" client that can still accommodate the request\n            // in order to maximize the number of idle clients as operations start to\n            // complete.\n            if (!this.failedClients.has(client) &&\n                metadata.activeRequestCount > selectedClientRequestCount &&\n                metadata.activeRequestCount < this.concurrentOperationLimit &&\n                (metadata.grpcEnabled || !requiresGrpc)) {\n                selectedClient = client;\n                selectedClientRequestCount = metadata.activeRequestCount;\n            }\n        }\n        if (selectedClient) {\n            (0, logger_1.logger)('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - selectedClientRequestCount);\n        }\n        else {\n            (0, logger_1.logger)('ClientPool.acquire', requestTag, 'Creating a new client (requiresGrpc: %s)', requiresGrpc);\n            selectedClient = this.clientFactory(requiresGrpc);\n            selectedClientRequestCount = 0;\n            assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n        }\n        this.activeClients.set(selectedClient, {\n            grpcEnabled: requiresGrpc,\n            activeRequestCount: selectedClientRequestCount + 1,\n        });\n        return selectedClient;\n    }\n    /**\n     * Reduces the number of operations for the provided client, potentially\n     * removing it from the pool of active clients.\n     * @private\n     * @internal\n     */\n    async release(requestTag, client) {\n        const metadata = this.activeClients.get(client);\n        assert(metadata && metadata.activeRequestCount > 0, 'No active requests');\n        this.activeClients.set(client, {\n            grpcEnabled: metadata.grpcEnabled,\n            activeRequestCount: metadata.activeRequestCount - 1,\n        });\n        if (this.terminated && this.opCount === 0) {\n            this.terminateDeferred.resolve();\n        }\n        if (this.shouldGarbageCollectClient(client)) {\n            this.activeClients.delete(client);\n            this.failedClients.delete(client);\n            await this.clientDestructor(client);\n            (0, logger_1.logger)('ClientPool.release', requestTag, 'Garbage collected 1 client');\n        }\n    }\n    /**\n     * Given the current operation counts, determines if the given client should\n     * be garbage collected.\n     * @private\n     * @internal\n     */\n    shouldGarbageCollectClient(client) {\n        const clientMetadata = this.activeClients.get(client);\n        if (clientMetadata.activeRequestCount !== 0) {\n            // Don't garbage collect clients that have active requests.\n            return false;\n        }\n        if (this.grpcEnabled !== clientMetadata.grpcEnabled) {\n            // We are transitioning to GRPC. Garbage collect REST clients.\n            return true;\n        }\n        // Idle clients that have received RST_STREAM errors are always garbage\n        // collected.\n        if (this.failedClients.has(client)) {\n            return true;\n        }\n        // Otherwise, only garbage collect if we have too much idle capacity (e.g.\n        // more than 100 idle capacity with default settings).\n        let idleCapacityCount = 0;\n        for (const [, metadata] of this.activeClients) {\n            idleCapacityCount +=\n                this.concurrentOperationLimit - metadata.activeRequestCount;\n        }\n        return (idleCapacityCount > this.maxIdleClients * this.concurrentOperationLimit);\n    }\n    /**\n     * The number of currently registered clients.\n     *\n     * @return Number of currently registered clients.\n     * @private\n     * @internal\n     */\n    // Visible for testing.\n    get size() {\n        return this.activeClients.size;\n    }\n    /**\n     * The number of currently active operations.\n     *\n     * @return Number of currently active operations.\n     * @private\n     * @internal\n     */\n    // Visible for testing.\n    get opCount() {\n        let activeOperationCount = 0;\n        this.activeClients.forEach(metadata => (activeOperationCount += metadata.activeRequestCount));\n        return activeOperationCount;\n    }\n    /**\n     * The currently active clients.\n     *\n     * @return The currently active clients.\n     * @private\n     * @internal\n     */\n    // Visible for testing.\n    get _activeClients() {\n        return this.activeClients;\n    }\n    /**\n     * Runs the provided operation in this pool. This function may create an\n     * additional client if all existing clients already operate at the concurrent\n     * operation limit.\n     *\n     * @param requestTag A unique client-assigned identifier for this operation.\n     * @param op A callback function that returns a Promise. The client T will\n     * be returned to the pool when callback finishes.\n     * @return A Promise that resolves with the result of `op`.\n     * @private\n     * @internal\n     */\n    run(requestTag, requiresGrpc, op) {\n        if (this.terminated) {\n            return Promise.reject(new Error(exports.CLIENT_TERMINATED_ERROR_MSG));\n        }\n        const client = this.acquire(requestTag, requiresGrpc);\n        return op(client)\n            .catch(async (err) => {\n            var _a;\n            if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.match(/RST_STREAM/)) {\n                // Once a client has seen a RST_STREAM error, the GRPC channel can\n                // no longer be used. We mark the client as failed, which ensures that\n                // we open a new GRPC channel for the next request.\n                this.failedClients.add(client);\n            }\n            await this.release(requestTag, client);\n            return Promise.reject(err);\n        })\n            .then(async (res) => {\n            await this.release(requestTag, client);\n            return res;\n        });\n    }\n    async terminate() {\n        this.terminated = true;\n        // Wait for all pending operations to complete before terminating.\n        if (this.opCount > 0) {\n            (0, logger_1.logger)('ClientPool.terminate', \n            /* requestTag= */ null, 'Waiting for %s pending operations to complete before terminating', this.opCount);\n            await this.terminateDeferred.promise;\n        }\n        for (const [client] of this.activeClients) {\n            this.activeClients.delete(client);\n            await this.clientDestructor(client);\n        }\n    }\n}\nexports.ClientPool = ClientPool;\n//# sourceMappingURL=pool.js.map"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,UAAU,GAAGF,OAAO,CAACG,2BAA2B,GAAG,KAAK,CAAC;AACjE,MAAMC,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMC,QAAQ,GAAGD,OAAO,CAAC,UAAU,CAAC;AACpC,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAChCL,OAAO,CAACG,2BAA2B,GAAG,wCAAwC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,UAAU,CAAC;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIM,WAAWA,CAACC,wBAAwB,EAAEC,cAAc,EAAEC,aAAa,EAAEC,gBAAgB,GAAGA,CAAA,KAAMC,OAAO,CAACC,OAAO,CAAC,CAAC,EAAE;IAC7G,IAAI,CAACL,wBAAwB,GAAGA,wBAAwB;IACxD,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACG,WAAW,GAAG,KAAK;IACxB;AACR;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC9B;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC9B;AACR;AACA;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB;AACR;AACA;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAG,IAAId,MAAM,CAACe,QAAQ,CAAC,CAAC;EAClD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,OAAOA,CAACC,UAAU,EAAEC,YAAY,EAAE;IAC9B,IAAIC,cAAc,GAAG,IAAI;IACzB,IAAIC,0BAA0B,GAAG,CAAC,CAAC;IACnC;IACA,IAAI,CAACZ,WAAW,GAAG,IAAI,CAACA,WAAW,IAAIU,YAAY;IACnD;IACAA,YAAY,GAAGA,YAAY,IAAI,IAAI,CAACV,WAAW;IAC/C,KAAK,MAAM,CAACa,MAAM,EAAEC,QAAQ,CAAC,IAAI,IAAI,CAACb,aAAa,EAAE;MACjD;MACA;MACA;MACA,IAAI,CAAC,IAAI,CAACE,aAAa,CAACY,GAAG,CAACF,MAAM,CAAC,IAC/BC,QAAQ,CAACE,kBAAkB,GAAGJ,0BAA0B,IACxDE,QAAQ,CAACE,kBAAkB,GAAG,IAAI,CAACtB,wBAAwB,KAC1DoB,QAAQ,CAACd,WAAW,IAAI,CAACU,YAAY,CAAC,EAAE;QACzCC,cAAc,GAAGE,MAAM;QACvBD,0BAA0B,GAAGE,QAAQ,CAACE,kBAAkB;MAC5D;IACJ;IACA,IAAIL,cAAc,EAAE;MAChB,CAAC,CAAC,EAAEpB,QAAQ,CAAC0B,MAAM,EAAE,oBAAoB,EAAER,UAAU,EAAE,uDAAuD,EAAE,IAAI,CAACf,wBAAwB,GAAGkB,0BAA0B,CAAC;IAC/K,CAAC,MACI;MACD,CAAC,CAAC,EAAErB,QAAQ,CAAC0B,MAAM,EAAE,oBAAoB,EAAER,UAAU,EAAE,0CAA0C,EAAEC,YAAY,CAAC;MAChHC,cAAc,GAAG,IAAI,CAACf,aAAa,CAACc,YAAY,CAAC;MACjDE,0BAA0B,GAAG,CAAC;MAC9BvB,MAAM,CAAC,CAAC,IAAI,CAACY,aAAa,CAACc,GAAG,CAACJ,cAAc,CAAC,EAAE,2DAA2D,CAAC;IAChH;IACA,IAAI,CAACV,aAAa,CAACiB,GAAG,CAACP,cAAc,EAAE;MACnCX,WAAW,EAAEU,YAAY;MACzBM,kBAAkB,EAAEJ,0BAA0B,GAAG;IACrD,CAAC,CAAC;IACF,OAAOD,cAAc;EACzB;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMQ,OAAOA,CAACV,UAAU,EAAEI,MAAM,EAAE;IAC9B,MAAMC,QAAQ,GAAG,IAAI,CAACb,aAAa,CAACmB,GAAG,CAACP,MAAM,CAAC;IAC/CxB,MAAM,CAACyB,QAAQ,IAAIA,QAAQ,CAACE,kBAAkB,GAAG,CAAC,EAAE,oBAAoB,CAAC;IACzE,IAAI,CAACf,aAAa,CAACiB,GAAG,CAACL,MAAM,EAAE;MAC3Bb,WAAW,EAAEc,QAAQ,CAACd,WAAW;MACjCgB,kBAAkB,EAAEF,QAAQ,CAACE,kBAAkB,GAAG;IACtD,CAAC,CAAC;IACF,IAAI,IAAI,CAACX,UAAU,IAAI,IAAI,CAACgB,OAAO,KAAK,CAAC,EAAE;MACvC,IAAI,CAACf,iBAAiB,CAACP,OAAO,CAAC,CAAC;IACpC;IACA,IAAI,IAAI,CAACuB,0BAA0B,CAACT,MAAM,CAAC,EAAE;MACzC,IAAI,CAACZ,aAAa,CAACsB,MAAM,CAACV,MAAM,CAAC;MACjC,IAAI,CAACV,aAAa,CAACoB,MAAM,CAACV,MAAM,CAAC;MACjC,MAAM,IAAI,CAAChB,gBAAgB,CAACgB,MAAM,CAAC;MACnC,CAAC,CAAC,EAAEtB,QAAQ,CAAC0B,MAAM,EAAE,oBAAoB,EAAER,UAAU,EAAE,4BAA4B,CAAC;IACxF;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACIa,0BAA0BA,CAACT,MAAM,EAAE;IAC/B,MAAMW,cAAc,GAAG,IAAI,CAACvB,aAAa,CAACmB,GAAG,CAACP,MAAM,CAAC;IACrD,IAAIW,cAAc,CAACR,kBAAkB,KAAK,CAAC,EAAE;MACzC;MACA,OAAO,KAAK;IAChB;IACA,IAAI,IAAI,CAAChB,WAAW,KAAKwB,cAAc,CAACxB,WAAW,EAAE;MACjD;MACA,OAAO,IAAI;IACf;IACA;IACA;IACA,IAAI,IAAI,CAACG,aAAa,CAACY,GAAG,CAACF,MAAM,CAAC,EAAE;MAChC,OAAO,IAAI;IACf;IACA;IACA;IACA,IAAIY,iBAAiB,GAAG,CAAC;IACzB,KAAK,MAAM,GAAGX,QAAQ,CAAC,IAAI,IAAI,CAACb,aAAa,EAAE;MAC3CwB,iBAAiB,IACb,IAAI,CAAC/B,wBAAwB,GAAGoB,QAAQ,CAACE,kBAAkB;IACnE;IACA,OAAQS,iBAAiB,GAAG,IAAI,CAAC9B,cAAc,GAAG,IAAI,CAACD,wBAAwB;EACnF;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI;EACA,IAAIgC,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACzB,aAAa,CAACyB,IAAI;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI;EACA,IAAIL,OAAOA,CAAA,EAAG;IACV,IAAIM,oBAAoB,GAAG,CAAC;IAC5B,IAAI,CAAC1B,aAAa,CAAC2B,OAAO,CAACd,QAAQ,IAAKa,oBAAoB,IAAIb,QAAQ,CAACE,kBAAmB,CAAC;IAC7F,OAAOW,oBAAoB;EAC/B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI;EACA,IAAIE,cAAcA,CAAA,EAAG;IACjB,OAAO,IAAI,CAAC5B,aAAa;EAC7B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI6B,GAAGA,CAACrB,UAAU,EAAEC,YAAY,EAAEqB,EAAE,EAAE;IAC9B,IAAI,IAAI,CAAC1B,UAAU,EAAE;MACjB,OAAOP,OAAO,CAACkC,MAAM,CAAC,IAAIC,KAAK,CAAChD,OAAO,CAACG,2BAA2B,CAAC,CAAC;IACzE;IACA,MAAMyB,MAAM,GAAG,IAAI,CAACL,OAAO,CAACC,UAAU,EAAEC,YAAY,CAAC;IACrD,OAAOqB,EAAE,CAAClB,MAAM,CAAC,CACZqB,KAAK,CAAC,MAAOC,GAAG,IAAK;MACtB,IAAIC,EAAE;MACN,IAAI,CAACA,EAAE,GAAGD,GAAG,CAACE,OAAO,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,KAAK,CAAC,YAAY,CAAC,EAAE;QAChF;QACA;QACA;QACA,IAAI,CAACnC,aAAa,CAACoC,GAAG,CAAC1B,MAAM,CAAC;MAClC;MACA,MAAM,IAAI,CAACM,OAAO,CAACV,UAAU,EAAEI,MAAM,CAAC;MACtC,OAAOf,OAAO,CAACkC,MAAM,CAACG,GAAG,CAAC;IAC9B,CAAC,CAAC,CACGK,IAAI,CAAC,MAAOC,GAAG,IAAK;MACrB,MAAM,IAAI,CAACtB,OAAO,CAACV,UAAU,EAAEI,MAAM,CAAC;MACtC,OAAO4B,GAAG;IACd,CAAC,CAAC;EACN;EACA,MAAMC,SAASA,CAAA,EAAG;IACd,IAAI,CAACrC,UAAU,GAAG,IAAI;IACtB;IACA,IAAI,IAAI,CAACgB,OAAO,GAAG,CAAC,EAAE;MAClB,CAAC,CAAC,EAAE9B,QAAQ,CAAC0B,MAAM,EAAE,sBAAsB,EAC3C,iBAAkB,IAAI,EAAE,kEAAkE,EAAE,IAAI,CAACI,OAAO,CAAC;MACzG,MAAM,IAAI,CAACf,iBAAiB,CAACqC,OAAO;IACxC;IACA,KAAK,MAAM,CAAC9B,MAAM,CAAC,IAAI,IAAI,CAACZ,aAAa,EAAE;MACvC,IAAI,CAACA,aAAa,CAACsB,MAAM,CAACV,MAAM,CAAC;MACjC,MAAM,IAAI,CAAChB,gBAAgB,CAACgB,MAAM,CAAC;IACvC;EACJ;AACJ;AACA5B,OAAO,CAACE,UAAU,GAAGA,UAAU","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}