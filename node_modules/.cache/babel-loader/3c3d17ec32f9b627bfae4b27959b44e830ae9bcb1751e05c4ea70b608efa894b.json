{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Namespace;\n\n// extends ReflectionObject\nvar ReflectionObject = require(\"./object\");\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\nvar Field = require(\"./field\"),\n  util = require(\"./util\"),\n  OneOf = require(\"./oneof\");\nvar Type,\n  // cyclic\n  Service, Enum;\n\n/**\r\n * Constructs a new namespace instance.\r\n * @name Namespace\r\n * @classdesc Reflected namespace.\r\n * @extends NamespaceBase\r\n * @constructor\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} [options] Declared options\r\n */\n\n/**\r\n * Constructs a namespace from JSON.\r\n * @memberof Namespace\r\n * @function\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} json JSON object\r\n * @returns {Namespace} Created namespace\r\n * @throws {TypeError} If arguments are invalid\r\n */\nNamespace.fromJSON = function fromJSON(name, json) {\n  return new Namespace(name, json.options).addJSON(json.nested);\n};\n\n/**\r\n * Converts an array of reflection objects to JSON.\r\n * @memberof Namespace\r\n * @param {ReflectionObject[]} array Object array\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\r\n */\nfunction arrayToJSON(array, toJSONOptions) {\n  if (!(array && array.length)) return undefined;\n  var obj = {};\n  for (var i = 0; i < array.length; ++i) obj[array[i].name] = array[i].toJSON(toJSONOptions);\n  return obj;\n}\nNamespace.arrayToJSON = arrayToJSON;\n\n/**\r\n * Tests if the specified id is reserved.\r\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\r\n * @param {number} id Id to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\nNamespace.isReservedId = function isReservedId(reserved, id) {\n  if (reserved) for (var i = 0; i < reserved.length; ++i) if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id) return true;\n  return false;\n};\n\n/**\r\n * Tests if the specified name is reserved.\r\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\r\n * @param {string} name Name to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\nNamespace.isReservedName = function isReservedName(reserved, name) {\n  if (reserved) for (var i = 0; i < reserved.length; ++i) if (reserved[i] === name) return true;\n  return false;\n};\n\n/**\r\n * Not an actual constructor. Use {@link Namespace} instead.\r\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\r\n * @exports NamespaceBase\r\n * @extends ReflectionObject\r\n * @abstract\r\n * @constructor\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @see {@link Namespace}\r\n */\nfunction Namespace(name, options) {\n  ReflectionObject.call(this, name, options);\n\n  /**\r\n   * Nested objects by name.\r\n   * @type {Object.<string,ReflectionObject>|undefined}\r\n   */\n  this.nested = undefined; // toJSON\n\n  /**\r\n   * Cached nested objects as an array.\r\n   * @type {ReflectionObject[]|null}\r\n   * @private\r\n   */\n  this._nestedArray = null;\n}\nfunction clearCache(namespace) {\n  namespace._nestedArray = null;\n  return namespace;\n}\n\n/**\r\n * Nested objects of this namespace as an array for iteration.\r\n * @name NamespaceBase#nestedArray\r\n * @type {ReflectionObject[]}\r\n * @readonly\r\n */\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n  get: function () {\n    return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n  }\n});\n\n/**\r\n * Namespace descriptor.\r\n * @interface INamespace\r\n * @property {Object.<string,*>} [options] Namespace options\r\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\r\n */\n\n/**\r\n * Any extension field descriptor.\r\n * @typedef AnyExtensionField\r\n * @type {IExtensionField|IExtensionMapField}\r\n */\n\n/**\r\n * Any nested object descriptor.\r\n * @typedef AnyNestedObject\r\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\r\n */\n\n/**\r\n * Converts this namespace to a namespace descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {INamespace} Namespace descriptor\r\n */\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n  return util.toObject([\"options\", this.options, \"nested\", arrayToJSON(this.nestedArray, toJSONOptions)]);\n};\n\n/**\r\n * Adds nested objects to this namespace from nested object descriptors.\r\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\r\n * @returns {Namespace} `this`\r\n */\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n  var ns = this;\n  /* istanbul ignore else */\n  if (nestedJson) {\n    for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n      nested = nestedJson[names[i]];\n      ns.add(\n      // most to least likely\n      (nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : nested.id !== undefined ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));\n    }\n  }\n  return this;\n};\n\n/**\r\n * Gets the nested object of the specified name.\r\n * @param {string} name Nested object name\r\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\r\n */\nNamespace.prototype.get = function get(name) {\n  return this.nested && this.nested[name] || null;\n};\n\n/**\r\n * Gets the values of the nested {@link Enum|enum} of the specified name.\r\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\r\n * @param {string} name Nested enum name\r\n * @returns {Object.<string,number>} Enum values\r\n * @throws {Error} If there is no such enum\r\n */\nNamespace.prototype.getEnum = function getEnum(name) {\n  if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;\n  throw Error(\"no such enum: \" + name);\n};\n\n/**\r\n * Adds a nested object to this namespace.\r\n * @param {ReflectionObject} object Nested object to add\r\n * @returns {Namespace} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If there is already a nested object with this name\r\n */\nNamespace.prototype.add = function add(object) {\n  if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace)) throw TypeError(\"object must be a valid nested object\");\n  if (!this.nested) this.nested = {};else {\n    var prev = this.get(object.name);\n    if (prev) {\n      if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n        // replace plain namespace but keep existing nested elements and options\n        var nested = prev.nestedArray;\n        for (var i = 0; i < nested.length; ++i) object.add(nested[i]);\n        this.remove(prev);\n        if (!this.nested) this.nested = {};\n        object.setOptions(prev.options, true);\n      } else throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n    }\n  }\n  this.nested[object.name] = object;\n  object.onAdd(this);\n  return clearCache(this);\n};\n\n/**\r\n * Removes a nested object from this namespace.\r\n * @param {ReflectionObject} object Nested object to remove\r\n * @returns {Namespace} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If `object` is not a member of this namespace\r\n */\nNamespace.prototype.remove = function remove(object) {\n  if (!(object instanceof ReflectionObject)) throw TypeError(\"object must be a ReflectionObject\");\n  if (object.parent !== this) throw Error(object + \" is not a member of \" + this);\n  delete this.nested[object.name];\n  if (!Object.keys(this.nested).length) this.nested = undefined;\n  object.onRemove(this);\n  return clearCache(this);\n};\n\n/**\r\n * Defines additial namespaces within this one if not yet existing.\r\n * @param {string|string[]} path Path to create\r\n * @param {*} [json] Nested types to create from JSON\r\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\r\n */\nNamespace.prototype.define = function define(path, json) {\n  if (util.isString(path)) path = path.split(\".\");else if (!Array.isArray(path)) throw TypeError(\"illegal path\");\n  if (path && path.length && path[0] === \"\") throw Error(\"path must be relative\");\n  var ptr = this;\n  while (path.length > 0) {\n    var part = path.shift();\n    if (ptr.nested && ptr.nested[part]) {\n      ptr = ptr.nested[part];\n      if (!(ptr instanceof Namespace)) throw Error(\"path conflicts with non-namespace objects\");\n    } else ptr.add(ptr = new Namespace(part));\n  }\n  if (json) ptr.addJSON(json);\n  return ptr;\n};\n\n/**\r\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\r\n * @returns {Namespace} `this`\r\n */\nNamespace.prototype.resolveAll = function resolveAll() {\n  var nested = this.nestedArray,\n    i = 0;\n  while (i < nested.length) if (nested[i] instanceof Namespace) nested[i++].resolveAll();else nested[i++].resolve();\n  return this.resolve();\n};\n\n/**\r\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\r\n * @param {string|string[]} path Path to look up\r\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\r\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\r\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\r\n */\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n  /* istanbul ignore next */\n  if (typeof filterTypes === \"boolean\") {\n    parentAlreadyChecked = filterTypes;\n    filterTypes = undefined;\n  } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [filterTypes];\n  if (util.isString(path) && path.length) {\n    if (path === \".\") return this.root;\n    path = path.split(\".\");\n  } else if (!path.length) return this;\n\n  // Start at root if path is absolute\n  if (path[0] === \"\") return this.root.lookup(path.slice(1), filterTypes);\n\n  // Test if the first part matches any nested object, and if so, traverse if path contains more\n  var found = this.get(path[0]);\n  if (found) {\n    if (path.length === 1) {\n      if (!filterTypes || filterTypes.indexOf(found.constructor) > -1) return found;\n    } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true))) return found;\n\n    // Otherwise try each nested namespace\n  } else for (var i = 0; i < this.nestedArray.length; ++i) if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true))) return found;\n\n  // If there hasn't been a match, try again at the parent\n  if (this.parent === null || parentAlreadyChecked) return null;\n  return this.parent.lookup(path, filterTypes);\n};\n\n/**\r\n * Looks up the reflection object at the specified path, relative to this namespace.\r\n * @name NamespaceBase#lookup\r\n * @function\r\n * @param {string|string[]} path Path to look up\r\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\r\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\r\n * @variation 2\r\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\r\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Type} Looked up type\r\n * @throws {Error} If `path` does not point to a type\r\n */\nNamespace.prototype.lookupType = function lookupType(path) {\n  var found = this.lookup(path, [Type]);\n  if (!found) throw Error(\"no such type: \" + path);\n  return found;\n};\n\n/**\r\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Enum} Looked up enum\r\n * @throws {Error} If `path` does not point to an enum\r\n */\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n  var found = this.lookup(path, [Enum]);\n  if (!found) throw Error(\"no such Enum '\" + path + \"' in \" + this);\n  return found;\n};\n\n/**\r\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Type} Looked up type or enum\r\n * @throws {Error} If `path` does not point to a type or enum\r\n */\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n  var found = this.lookup(path, [Type, Enum]);\n  if (!found) throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n  return found;\n};\n\n/**\r\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Service} Looked up service\r\n * @throws {Error} If `path` does not point to a service\r\n */\nNamespace.prototype.lookupService = function lookupService(path) {\n  var found = this.lookup(path, [Service]);\n  if (!found) throw Error(\"no such Service '\" + path + \"' in \" + this);\n  return found;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function (Type_, Service_, Enum_) {\n  Type = Type_;\n  Service = Service_;\n  Enum = Enum_;\n};","map":{"version":3,"names":["module","exports","Namespace","ReflectionObject","require","prototype","Object","create","constructor","className","Field","util","OneOf","Type","Service","Enum","fromJSON","name","json","options","addJSON","nested","arrayToJSON","array","toJSONOptions","length","undefined","obj","i","toJSON","isReservedId","reserved","id","isReservedName","call","_nestedArray","clearCache","namespace","defineProperty","get","toArray","toObject","nestedArray","nestedJson","ns","names","keys","add","fields","values","methods","getEnum","Error","object","extend","TypeError","prev","remove","setOptions","onAdd","parent","onRemove","define","path","isString","split","Array","isArray","ptr","part","shift","resolveAll","resolve","lookup","filterTypes","parentAlreadyChecked","root","slice","found","indexOf","lookupType","lookupEnum","lookupTypeOrEnum","lookupService","_configure","Type_","Service_","Enum_"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/protobufjs/src/namespace.js"],"sourcesContent":["\"use strict\";\r\nmodule.exports = Namespace;\r\n\r\n// extends ReflectionObject\r\nvar ReflectionObject = require(\"./object\");\r\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\r\n\r\nvar Field    = require(\"./field\"),\r\n    util     = require(\"./util\"),\r\n    OneOf    = require(\"./oneof\");\r\n\r\nvar Type,    // cyclic\r\n    Service,\r\n    Enum;\r\n\r\n/**\r\n * Constructs a new namespace instance.\r\n * @name Namespace\r\n * @classdesc Reflected namespace.\r\n * @extends NamespaceBase\r\n * @constructor\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} [options] Declared options\r\n */\r\n\r\n/**\r\n * Constructs a namespace from JSON.\r\n * @memberof Namespace\r\n * @function\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} json JSON object\r\n * @returns {Namespace} Created namespace\r\n * @throws {TypeError} If arguments are invalid\r\n */\r\nNamespace.fromJSON = function fromJSON(name, json) {\r\n    return new Namespace(name, json.options).addJSON(json.nested);\r\n};\r\n\r\n/**\r\n * Converts an array of reflection objects to JSON.\r\n * @memberof Namespace\r\n * @param {ReflectionObject[]} array Object array\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\r\n */\r\nfunction arrayToJSON(array, toJSONOptions) {\r\n    if (!(array && array.length))\r\n        return undefined;\r\n    var obj = {};\r\n    for (var i = 0; i < array.length; ++i)\r\n        obj[array[i].name] = array[i].toJSON(toJSONOptions);\r\n    return obj;\r\n}\r\n\r\nNamespace.arrayToJSON = arrayToJSON;\r\n\r\n/**\r\n * Tests if the specified id is reserved.\r\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\r\n * @param {number} id Id to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\r\nNamespace.isReservedId = function isReservedId(reserved, id) {\r\n    if (reserved)\r\n        for (var i = 0; i < reserved.length; ++i)\r\n            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id)\r\n                return true;\r\n    return false;\r\n};\r\n\r\n/**\r\n * Tests if the specified name is reserved.\r\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\r\n * @param {string} name Name to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\r\nNamespace.isReservedName = function isReservedName(reserved, name) {\r\n    if (reserved)\r\n        for (var i = 0; i < reserved.length; ++i)\r\n            if (reserved[i] === name)\r\n                return true;\r\n    return false;\r\n};\r\n\r\n/**\r\n * Not an actual constructor. Use {@link Namespace} instead.\r\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\r\n * @exports NamespaceBase\r\n * @extends ReflectionObject\r\n * @abstract\r\n * @constructor\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @see {@link Namespace}\r\n */\r\nfunction Namespace(name, options) {\r\n    ReflectionObject.call(this, name, options);\r\n\r\n    /**\r\n     * Nested objects by name.\r\n     * @type {Object.<string,ReflectionObject>|undefined}\r\n     */\r\n    this.nested = undefined; // toJSON\r\n\r\n    /**\r\n     * Cached nested objects as an array.\r\n     * @type {ReflectionObject[]|null}\r\n     * @private\r\n     */\r\n    this._nestedArray = null;\r\n}\r\n\r\nfunction clearCache(namespace) {\r\n    namespace._nestedArray = null;\r\n    return namespace;\r\n}\r\n\r\n/**\r\n * Nested objects of this namespace as an array for iteration.\r\n * @name NamespaceBase#nestedArray\r\n * @type {ReflectionObject[]}\r\n * @readonly\r\n */\r\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\r\n    get: function() {\r\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\r\n    }\r\n});\r\n\r\n/**\r\n * Namespace descriptor.\r\n * @interface INamespace\r\n * @property {Object.<string,*>} [options] Namespace options\r\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\r\n */\r\n\r\n/**\r\n * Any extension field descriptor.\r\n * @typedef AnyExtensionField\r\n * @type {IExtensionField|IExtensionMapField}\r\n */\r\n\r\n/**\r\n * Any nested object descriptor.\r\n * @typedef AnyNestedObject\r\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\r\n */\r\n\r\n/**\r\n * Converts this namespace to a namespace descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {INamespace} Namespace descriptor\r\n */\r\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\r\n    return util.toObject([\r\n        \"options\" , this.options,\r\n        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\r\n    ]);\r\n};\r\n\r\n/**\r\n * Adds nested objects to this namespace from nested object descriptors.\r\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\r\n * @returns {Namespace} `this`\r\n */\r\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\r\n    var ns = this;\r\n    /* istanbul ignore else */\r\n    if (nestedJson) {\r\n        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\r\n            nested = nestedJson[names[i]];\r\n            ns.add( // most to least likely\r\n                ( nested.fields !== undefined\r\n                ? Type.fromJSON\r\n                : nested.values !== undefined\r\n                ? Enum.fromJSON\r\n                : nested.methods !== undefined\r\n                ? Service.fromJSON\r\n                : nested.id !== undefined\r\n                ? Field.fromJSON\r\n                : Namespace.fromJSON )(names[i], nested)\r\n            );\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Gets the nested object of the specified name.\r\n * @param {string} name Nested object name\r\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\r\n */\r\nNamespace.prototype.get = function get(name) {\r\n    return this.nested && this.nested[name]\r\n        || null;\r\n};\r\n\r\n/**\r\n * Gets the values of the nested {@link Enum|enum} of the specified name.\r\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\r\n * @param {string} name Nested enum name\r\n * @returns {Object.<string,number>} Enum values\r\n * @throws {Error} If there is no such enum\r\n */\r\nNamespace.prototype.getEnum = function getEnum(name) {\r\n    if (this.nested && this.nested[name] instanceof Enum)\r\n        return this.nested[name].values;\r\n    throw Error(\"no such enum: \" + name);\r\n};\r\n\r\n/**\r\n * Adds a nested object to this namespace.\r\n * @param {ReflectionObject} object Nested object to add\r\n * @returns {Namespace} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If there is already a nested object with this name\r\n */\r\nNamespace.prototype.add = function add(object) {\r\n\r\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))\r\n        throw TypeError(\"object must be a valid nested object\");\r\n\r\n    if (!this.nested)\r\n        this.nested = {};\r\n    else {\r\n        var prev = this.get(object.name);\r\n        if (prev) {\r\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\r\n                // replace plain namespace but keep existing nested elements and options\r\n                var nested = prev.nestedArray;\r\n                for (var i = 0; i < nested.length; ++i)\r\n                    object.add(nested[i]);\r\n                this.remove(prev);\r\n                if (!this.nested)\r\n                    this.nested = {};\r\n                object.setOptions(prev.options, true);\r\n\r\n            } else\r\n                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\r\n        }\r\n    }\r\n    this.nested[object.name] = object;\r\n    object.onAdd(this);\r\n    return clearCache(this);\r\n};\r\n\r\n/**\r\n * Removes a nested object from this namespace.\r\n * @param {ReflectionObject} object Nested object to remove\r\n * @returns {Namespace} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If `object` is not a member of this namespace\r\n */\r\nNamespace.prototype.remove = function remove(object) {\r\n\r\n    if (!(object instanceof ReflectionObject))\r\n        throw TypeError(\"object must be a ReflectionObject\");\r\n    if (object.parent !== this)\r\n        throw Error(object + \" is not a member of \" + this);\r\n\r\n    delete this.nested[object.name];\r\n    if (!Object.keys(this.nested).length)\r\n        this.nested = undefined;\r\n\r\n    object.onRemove(this);\r\n    return clearCache(this);\r\n};\r\n\r\n/**\r\n * Defines additial namespaces within this one if not yet existing.\r\n * @param {string|string[]} path Path to create\r\n * @param {*} [json] Nested types to create from JSON\r\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\r\n */\r\nNamespace.prototype.define = function define(path, json) {\r\n\r\n    if (util.isString(path))\r\n        path = path.split(\".\");\r\n    else if (!Array.isArray(path))\r\n        throw TypeError(\"illegal path\");\r\n    if (path && path.length && path[0] === \"\")\r\n        throw Error(\"path must be relative\");\r\n\r\n    var ptr = this;\r\n    while (path.length > 0) {\r\n        var part = path.shift();\r\n        if (ptr.nested && ptr.nested[part]) {\r\n            ptr = ptr.nested[part];\r\n            if (!(ptr instanceof Namespace))\r\n                throw Error(\"path conflicts with non-namespace objects\");\r\n        } else\r\n            ptr.add(ptr = new Namespace(part));\r\n    }\r\n    if (json)\r\n        ptr.addJSON(json);\r\n    return ptr;\r\n};\r\n\r\n/**\r\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\r\n * @returns {Namespace} `this`\r\n */\r\nNamespace.prototype.resolveAll = function resolveAll() {\r\n    var nested = this.nestedArray, i = 0;\r\n    while (i < nested.length)\r\n        if (nested[i] instanceof Namespace)\r\n            nested[i++].resolveAll();\r\n        else\r\n            nested[i++].resolve();\r\n    return this.resolve();\r\n};\r\n\r\n/**\r\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\r\n * @param {string|string[]} path Path to look up\r\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\r\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\r\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\r\n */\r\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\r\n\r\n    /* istanbul ignore next */\r\n    if (typeof filterTypes === \"boolean\") {\r\n        parentAlreadyChecked = filterTypes;\r\n        filterTypes = undefined;\r\n    } else if (filterTypes && !Array.isArray(filterTypes))\r\n        filterTypes = [ filterTypes ];\r\n\r\n    if (util.isString(path) && path.length) {\r\n        if (path === \".\")\r\n            return this.root;\r\n        path = path.split(\".\");\r\n    } else if (!path.length)\r\n        return this;\r\n\r\n    // Start at root if path is absolute\r\n    if (path[0] === \"\")\r\n        return this.root.lookup(path.slice(1), filterTypes);\r\n\r\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\r\n    var found = this.get(path[0]);\r\n    if (found) {\r\n        if (path.length === 1) {\r\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)\r\n                return found;\r\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))\r\n            return found;\r\n\r\n    // Otherwise try each nested namespace\r\n    } else\r\n        for (var i = 0; i < this.nestedArray.length; ++i)\r\n            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))\r\n                return found;\r\n\r\n    // If there hasn't been a match, try again at the parent\r\n    if (this.parent === null || parentAlreadyChecked)\r\n        return null;\r\n    return this.parent.lookup(path, filterTypes);\r\n};\r\n\r\n/**\r\n * Looks up the reflection object at the specified path, relative to this namespace.\r\n * @name NamespaceBase#lookup\r\n * @function\r\n * @param {string|string[]} path Path to look up\r\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\r\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\r\n * @variation 2\r\n */\r\n// lookup(path: string, [parentAlreadyChecked: boolean])\r\n\r\n/**\r\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Type} Looked up type\r\n * @throws {Error} If `path` does not point to a type\r\n */\r\nNamespace.prototype.lookupType = function lookupType(path) {\r\n    var found = this.lookup(path, [ Type ]);\r\n    if (!found)\r\n        throw Error(\"no such type: \" + path);\r\n    return found;\r\n};\r\n\r\n/**\r\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Enum} Looked up enum\r\n * @throws {Error} If `path` does not point to an enum\r\n */\r\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\r\n    var found = this.lookup(path, [ Enum ]);\r\n    if (!found)\r\n        throw Error(\"no such Enum '\" + path + \"' in \" + this);\r\n    return found;\r\n};\r\n\r\n/**\r\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Type} Looked up type or enum\r\n * @throws {Error} If `path` does not point to a type or enum\r\n */\r\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\r\n    var found = this.lookup(path, [ Type, Enum ]);\r\n    if (!found)\r\n        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\r\n    return found;\r\n};\r\n\r\n/**\r\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Service} Looked up service\r\n * @throws {Error} If `path` does not point to a service\r\n */\r\nNamespace.prototype.lookupService = function lookupService(path) {\r\n    var found = this.lookup(path, [ Service ]);\r\n    if (!found)\r\n        throw Error(\"no such Service '\" + path + \"' in \" + this);\r\n    return found;\r\n};\r\n\r\n// Sets up cyclic dependencies (called in index-light)\r\nNamespace._configure = function(Type_, Service_, Enum_) {\r\n    Type    = Type_;\r\n    Service = Service_;\r\n    Enum    = Enum_;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}