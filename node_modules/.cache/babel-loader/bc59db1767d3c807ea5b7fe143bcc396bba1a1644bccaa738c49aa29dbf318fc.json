{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RecursiveDelete = exports.RECURSIVE_DELETE_MIN_PENDING_OPS = exports.RECURSIVE_DELETE_MAX_PENDING_OPS = exports.REFERENCE_NAME_MIN_ID = void 0;\nconst assert = require(\"assert\");\nconst _1 = require(\".\");\nconst util_1 = require(\"./util\");\nconst query_options_1 = require(\"./reference/query-options\");\n/*!\n * Datastore allowed numeric IDs where Firestore only allows strings. Numeric\n * IDs are exposed to Firestore as __idNUM__, so this is the lowest possible\n * negative numeric value expressed in that format.\n *\n * This constant is used to specify startAt/endAt values when querying for all\n * descendants in a single collection.\n */\nexports.REFERENCE_NAME_MIN_ID = '__id-9223372036854775808__';\n/*!\n * The query limit used for recursive deletes when fetching all descendants of\n * the specified reference to delete. This is done to prevent the query stream\n * from streaming documents faster than Firestore can delete.\n */\n// Visible for testing.\nexports.RECURSIVE_DELETE_MAX_PENDING_OPS = 5000;\n/*!\n * The number of pending BulkWriter operations at which RecursiveDelete\n * starts the next limit query to fetch descendants. By starting the query\n * while there are pending operations, Firestore can improve BulkWriter\n * throughput. This helps prevent BulkWriter from idling while Firestore\n * fetches the next query.\n */\nexports.RECURSIVE_DELETE_MIN_PENDING_OPS = 1000;\n/**\n * Class used to store state required for running a recursive delete operation.\n * Each recursive delete call should use a new instance of the class.\n * @private\n * @internal\n */\nclass RecursiveDelete {\n  /**\n   *\n   * @param firestore The Firestore instance to use.\n   * @param writer The BulkWriter instance to use for delete operations.\n   * @param ref The document or collection reference to recursively delete.\n   * @param maxLimit The query limit to use when fetching descendants\n   * @param minLimit The number of pending BulkWriter operations at which\n   * RecursiveDelete starts the next limit query to fetch descendants.\n   */\n  constructor(firestore, writer, ref, maxLimit, minLimit) {\n    this.firestore = firestore;\n    this.writer = writer;\n    this.ref = ref;\n    this.maxLimit = maxLimit;\n    this.minLimit = minLimit;\n    /**\n     * The number of deletes that failed with a permanent error.\n     * @private\n     * @internal\n     */\n    this.errorCount = 0;\n    /**\n     * Whether there are still documents to delete that still need to be fetched.\n     * @private\n     * @internal\n     */\n    this.documentsPending = true;\n    /**\n     * Whether run() has been called.\n     * @private\n     * @internal\n     */\n    this.started = false;\n    /**\n     * A deferred promise that resolves when the recursive delete operation\n     * is completed.\n     * @private\n     * @internal\n     */\n    this.completionDeferred = new util_1.Deferred();\n    /**\n     * Whether a query stream is currently in progress. Only one stream can be\n     * run at a time.\n     * @private\n     * @internal\n     */\n    this.streamInProgress = false;\n    /**\n     * The number of pending BulkWriter operations. Used to determine when the\n     * next query can be run.\n     * @private\n     * @internal\n     */\n    this.pendingOpsCount = 0;\n    this.errorStack = '';\n    this.maxPendingOps = maxLimit;\n    this.minPendingOps = minLimit;\n  }\n  /**\n   * Recursively deletes the reference provided in the class constructor.\n   * Returns a promise that resolves when all descendants have been deleted, or\n   * if an error occurs.\n   */\n  run() {\n    assert(!this.started, 'RecursiveDelete.run() should only be called once.');\n    // Capture the error stack to preserve stack tracing across async calls.\n    this.errorStack = Error().stack;\n    this.writer._verifyNotClosed();\n    this.setupStream();\n    return this.completionDeferred.promise;\n  }\n  /**\n   * Creates a query stream and attaches event handlers to it.\n   * @private\n   * @internal\n   */\n  setupStream() {\n    const stream = this.getAllDescendants(this.ref instanceof _1.CollectionReference ? this.ref : this.ref);\n    this.streamInProgress = true;\n    let streamedDocsCount = 0;\n    stream.on('error', err => {\n      err.code = 14 /* StatusCode.UNAVAILABLE */;\n      err.stack = 'Failed to fetch children documents: ' + err.stack;\n      this.lastError = err;\n      this.onQueryEnd();\n    }).on('data', snap => {\n      streamedDocsCount++;\n      this.lastDocumentSnap = snap;\n      this.deleteRef(snap.ref);\n    }).on('end', () => {\n      this.streamInProgress = false;\n      // If there are fewer than the number of documents specified in the\n      // limit() field, we know that the query is complete.\n      if (streamedDocsCount < this.minPendingOps) {\n        this.onQueryEnd();\n      } else if (this.pendingOpsCount === 0) {\n        this.setupStream();\n      }\n    });\n  }\n  /**\n   * Retrieves all descendant documents nested under the provided reference.\n   * @param ref The reference to fetch all descendants for.\n   * @private\n   * @internal\n   * @return {Stream<QueryDocumentSnapshot>} Stream of descendant documents.\n   */\n  getAllDescendants(ref) {\n    // The parent is the closest ancestor document to the location we're\n    // deleting. If we are deleting a document, the parent is the path of that\n    // document. If we are deleting a collection, the parent is the path of the\n    // document containing that collection (or the database root, if it is a\n    // root collection).\n    let parentPath = ref._resourcePath;\n    if (ref instanceof _1.CollectionReference) {\n      parentPath = parentPath.popLast();\n    }\n    const collectionId = ref instanceof _1.CollectionReference ? ref.id : ref.parent.id;\n    let query = new _1.Query(this.firestore, query_options_1.QueryOptions.forKindlessAllDescendants(parentPath, collectionId, /* requireConsistency= */false));\n    // Query for names only to fetch empty snapshots.\n    query = query.select(_1.FieldPath.documentId()).limit(this.maxPendingOps);\n    if (ref instanceof _1.CollectionReference) {\n      // To find all descendants of a collection reference, we need to use a\n      // composite filter that captures all documents that start with the\n      // collection prefix. The MIN_KEY constant represents the minimum key in\n      // this collection, and a null byte + the MIN_KEY represents the minimum\n      // key is the next possible collection.\n      const nullChar = String.fromCharCode(0);\n      const startAt = collectionId + '/' + exports.REFERENCE_NAME_MIN_ID;\n      const endAt = collectionId + nullChar + '/' + exports.REFERENCE_NAME_MIN_ID;\n      query = query.where(_1.FieldPath.documentId(), '>=', startAt).where(_1.FieldPath.documentId(), '<', endAt);\n    }\n    if (this.lastDocumentSnap) {\n      query = query.startAfter(this.lastDocumentSnap);\n    }\n    return query.stream();\n  }\n  /**\n   * Called when all descendants of the provided reference have been streamed\n   * or if a permanent error occurs during the stream. Deletes the developer\n   * provided reference and wraps any errors that occurred.\n   * @private\n   * @internal\n   */\n  onQueryEnd() {\n    this.documentsPending = false;\n    if (this.ref instanceof _1.DocumentReference) {\n      this.writer.delete(this.ref).catch(err => this.incrementErrorCount(err));\n    }\n    this.writer.flush().then(async () => {\n      var _a;\n      if (this.lastError === undefined) {\n        this.completionDeferred.resolve();\n      } else {\n        let error = new (require('google-gax/build/src/fallback').GoogleError)(`${this.errorCount} ` + `${this.errorCount !== 1 ? 'deletes' : 'delete'} ` + 'failed. The last delete failed with: ');\n        if (this.lastError.code !== undefined) {\n          error.code = this.lastError.code;\n        }\n        error = (0, util_1.wrapError)(error, this.errorStack);\n        // Wrap the BulkWriter error last to provide the full stack trace.\n        this.completionDeferred.reject(this.lastError.stack ? (0, util_1.wrapError)(error, (_a = this.lastError.stack) !== null && _a !== void 0 ? _a : '') : error);\n      }\n    });\n  }\n  /**\n   * Deletes the provided reference and starts the next stream if conditions\n   * are met.\n   * @private\n   * @internal\n   */\n  deleteRef(docRef) {\n    this.pendingOpsCount++;\n    this.writer.delete(docRef).catch(err => {\n      this.incrementErrorCount(err);\n    }).then(() => {\n      this.pendingOpsCount--;\n      // We wait until the previous stream has ended in order to sure the\n      // startAfter document is correct. Starting the next stream while\n      // there are pending operations allows Firestore to maximize\n      // BulkWriter throughput.\n      if (this.documentsPending && !this.streamInProgress && this.pendingOpsCount < this.minPendingOps) {\n        this.setupStream();\n      }\n    });\n  }\n  incrementErrorCount(err) {\n    this.errorCount++;\n    this.lastError = err;\n  }\n}\nexports.RecursiveDelete = RecursiveDelete;","map":{"version":3,"names":["Object","defineProperty","exports","value","RecursiveDelete","RECURSIVE_DELETE_MIN_PENDING_OPS","RECURSIVE_DELETE_MAX_PENDING_OPS","REFERENCE_NAME_MIN_ID","assert","require","_1","util_1","query_options_1","constructor","firestore","writer","ref","maxLimit","minLimit","errorCount","documentsPending","started","completionDeferred","Deferred","streamInProgress","pendingOpsCount","errorStack","maxPendingOps","minPendingOps","run","Error","stack","_verifyNotClosed","setupStream","promise","stream","getAllDescendants","CollectionReference","streamedDocsCount","on","err","code","lastError","onQueryEnd","snap","lastDocumentSnap","deleteRef","parentPath","_resourcePath","popLast","collectionId","id","parent","query","Query","QueryOptions","forKindlessAllDescendants","select","FieldPath","documentId","limit","nullChar","String","fromCharCode","startAt","endAt","where","startAfter","DocumentReference","delete","catch","incrementErrorCount","flush","then","_a","undefined","resolve","error","GoogleError","wrapError","reject","docRef"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@google-cloud/firestore/build/src/recursive-delete.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RecursiveDelete = exports.RECURSIVE_DELETE_MIN_PENDING_OPS = exports.RECURSIVE_DELETE_MAX_PENDING_OPS = exports.REFERENCE_NAME_MIN_ID = void 0;\nconst assert = require(\"assert\");\nconst _1 = require(\".\");\nconst util_1 = require(\"./util\");\nconst query_options_1 = require(\"./reference/query-options\");\n/*!\n * Datastore allowed numeric IDs where Firestore only allows strings. Numeric\n * IDs are exposed to Firestore as __idNUM__, so this is the lowest possible\n * negative numeric value expressed in that format.\n *\n * This constant is used to specify startAt/endAt values when querying for all\n * descendants in a single collection.\n */\nexports.REFERENCE_NAME_MIN_ID = '__id-9223372036854775808__';\n/*!\n * The query limit used for recursive deletes when fetching all descendants of\n * the specified reference to delete. This is done to prevent the query stream\n * from streaming documents faster than Firestore can delete.\n */\n// Visible for testing.\nexports.RECURSIVE_DELETE_MAX_PENDING_OPS = 5000;\n/*!\n * The number of pending BulkWriter operations at which RecursiveDelete\n * starts the next limit query to fetch descendants. By starting the query\n * while there are pending operations, Firestore can improve BulkWriter\n * throughput. This helps prevent BulkWriter from idling while Firestore\n * fetches the next query.\n */\nexports.RECURSIVE_DELETE_MIN_PENDING_OPS = 1000;\n/**\n * Class used to store state required for running a recursive delete operation.\n * Each recursive delete call should use a new instance of the class.\n * @private\n * @internal\n */\nclass RecursiveDelete {\n    /**\n     *\n     * @param firestore The Firestore instance to use.\n     * @param writer The BulkWriter instance to use for delete operations.\n     * @param ref The document or collection reference to recursively delete.\n     * @param maxLimit The query limit to use when fetching descendants\n     * @param minLimit The number of pending BulkWriter operations at which\n     * RecursiveDelete starts the next limit query to fetch descendants.\n     */\n    constructor(firestore, writer, ref, maxLimit, minLimit) {\n        this.firestore = firestore;\n        this.writer = writer;\n        this.ref = ref;\n        this.maxLimit = maxLimit;\n        this.minLimit = minLimit;\n        /**\n         * The number of deletes that failed with a permanent error.\n         * @private\n         * @internal\n         */\n        this.errorCount = 0;\n        /**\n         * Whether there are still documents to delete that still need to be fetched.\n         * @private\n         * @internal\n         */\n        this.documentsPending = true;\n        /**\n         * Whether run() has been called.\n         * @private\n         * @internal\n         */\n        this.started = false;\n        /**\n         * A deferred promise that resolves when the recursive delete operation\n         * is completed.\n         * @private\n         * @internal\n         */\n        this.completionDeferred = new util_1.Deferred();\n        /**\n         * Whether a query stream is currently in progress. Only one stream can be\n         * run at a time.\n         * @private\n         * @internal\n         */\n        this.streamInProgress = false;\n        /**\n         * The number of pending BulkWriter operations. Used to determine when the\n         * next query can be run.\n         * @private\n         * @internal\n         */\n        this.pendingOpsCount = 0;\n        this.errorStack = '';\n        this.maxPendingOps = maxLimit;\n        this.minPendingOps = minLimit;\n    }\n    /**\n     * Recursively deletes the reference provided in the class constructor.\n     * Returns a promise that resolves when all descendants have been deleted, or\n     * if an error occurs.\n     */\n    run() {\n        assert(!this.started, 'RecursiveDelete.run() should only be called once.');\n        // Capture the error stack to preserve stack tracing across async calls.\n        this.errorStack = Error().stack;\n        this.writer._verifyNotClosed();\n        this.setupStream();\n        return this.completionDeferred.promise;\n    }\n    /**\n     * Creates a query stream and attaches event handlers to it.\n     * @private\n     * @internal\n     */\n    setupStream() {\n        const stream = this.getAllDescendants(this.ref instanceof _1.CollectionReference\n            ? this.ref\n            : this.ref);\n        this.streamInProgress = true;\n        let streamedDocsCount = 0;\n        stream\n            .on('error', err => {\n            err.code = 14 /* StatusCode.UNAVAILABLE */;\n            err.stack = 'Failed to fetch children documents: ' + err.stack;\n            this.lastError = err;\n            this.onQueryEnd();\n        })\n            .on('data', (snap) => {\n            streamedDocsCount++;\n            this.lastDocumentSnap = snap;\n            this.deleteRef(snap.ref);\n        })\n            .on('end', () => {\n            this.streamInProgress = false;\n            // If there are fewer than the number of documents specified in the\n            // limit() field, we know that the query is complete.\n            if (streamedDocsCount < this.minPendingOps) {\n                this.onQueryEnd();\n            }\n            else if (this.pendingOpsCount === 0) {\n                this.setupStream();\n            }\n        });\n    }\n    /**\n     * Retrieves all descendant documents nested under the provided reference.\n     * @param ref The reference to fetch all descendants for.\n     * @private\n     * @internal\n     * @return {Stream<QueryDocumentSnapshot>} Stream of descendant documents.\n     */\n    getAllDescendants(ref) {\n        // The parent is the closest ancestor document to the location we're\n        // deleting. If we are deleting a document, the parent is the path of that\n        // document. If we are deleting a collection, the parent is the path of the\n        // document containing that collection (or the database root, if it is a\n        // root collection).\n        let parentPath = ref._resourcePath;\n        if (ref instanceof _1.CollectionReference) {\n            parentPath = parentPath.popLast();\n        }\n        const collectionId = ref instanceof _1.CollectionReference\n            ? ref.id\n            : ref.parent.id;\n        let query = new _1.Query(this.firestore, query_options_1.QueryOptions.forKindlessAllDescendants(parentPath, collectionId, \n        /* requireConsistency= */ false));\n        // Query for names only to fetch empty snapshots.\n        query = query.select(_1.FieldPath.documentId()).limit(this.maxPendingOps);\n        if (ref instanceof _1.CollectionReference) {\n            // To find all descendants of a collection reference, we need to use a\n            // composite filter that captures all documents that start with the\n            // collection prefix. The MIN_KEY constant represents the minimum key in\n            // this collection, and a null byte + the MIN_KEY represents the minimum\n            // key is the next possible collection.\n            const nullChar = String.fromCharCode(0);\n            const startAt = collectionId + '/' + exports.REFERENCE_NAME_MIN_ID;\n            const endAt = collectionId + nullChar + '/' + exports.REFERENCE_NAME_MIN_ID;\n            query = query\n                .where(_1.FieldPath.documentId(), '>=', startAt)\n                .where(_1.FieldPath.documentId(), '<', endAt);\n        }\n        if (this.lastDocumentSnap) {\n            query = query.startAfter(this.lastDocumentSnap);\n        }\n        return query.stream();\n    }\n    /**\n     * Called when all descendants of the provided reference have been streamed\n     * or if a permanent error occurs during the stream. Deletes the developer\n     * provided reference and wraps any errors that occurred.\n     * @private\n     * @internal\n     */\n    onQueryEnd() {\n        this.documentsPending = false;\n        if (this.ref instanceof _1.DocumentReference) {\n            this.writer.delete(this.ref).catch(err => this.incrementErrorCount(err));\n        }\n        this.writer.flush().then(async () => {\n            var _a;\n            if (this.lastError === undefined) {\n                this.completionDeferred.resolve();\n            }\n            else {\n                let error = new (require('google-gax/build/src/fallback').GoogleError)(`${this.errorCount} ` +\n                    `${this.errorCount !== 1 ? 'deletes' : 'delete'} ` +\n                    'failed. The last delete failed with: ');\n                if (this.lastError.code !== undefined) {\n                    error.code = this.lastError.code;\n                }\n                error = (0, util_1.wrapError)(error, this.errorStack);\n                // Wrap the BulkWriter error last to provide the full stack trace.\n                this.completionDeferred.reject(this.lastError.stack\n                    ? (0, util_1.wrapError)(error, (_a = this.lastError.stack) !== null && _a !== void 0 ? _a : '')\n                    : error);\n            }\n        });\n    }\n    /**\n     * Deletes the provided reference and starts the next stream if conditions\n     * are met.\n     * @private\n     * @internal\n     */\n    deleteRef(docRef) {\n        this.pendingOpsCount++;\n        this.writer\n            .delete(docRef)\n            .catch(err => {\n            this.incrementErrorCount(err);\n        })\n            .then(() => {\n            this.pendingOpsCount--;\n            // We wait until the previous stream has ended in order to sure the\n            // startAfter document is correct. Starting the next stream while\n            // there are pending operations allows Firestore to maximize\n            // BulkWriter throughput.\n            if (this.documentsPending &&\n                !this.streamInProgress &&\n                this.pendingOpsCount < this.minPendingOps) {\n                this.setupStream();\n            }\n        });\n    }\n    incrementErrorCount(err) {\n        this.errorCount++;\n        this.lastError = err;\n    }\n}\nexports.RecursiveDelete = RecursiveDelete;\n//# sourceMappingURL=recursive-delete.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}