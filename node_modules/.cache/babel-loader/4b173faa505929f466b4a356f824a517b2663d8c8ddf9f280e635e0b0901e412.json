{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DocumentReference = void 0;\nconst index_1 = require(\"../index\");\nconst path_1 = require(\"../path\");\nconst types_1 = require(\"../types\");\nconst collection_reference_1 = require(\"./collection-reference\");\nconst util_1 = require(\"../util\");\nconst validate_1 = require(\"../validate\");\nconst document_1 = require(\"../document\");\n/**\n * A DocumentReference refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist. A DocumentReference can\n * also be used to create a\n * [CollectionReference]{@link CollectionReference} to a\n * subcollection.\n *\n * @class DocumentReference\n */\nclass DocumentReference {\n  /**\n   * @private\n   * @internal\n   * @param _firestore The Firestore Database client.\n   * @param _path The Path of this reference.\n   * @param _converter The converter to use when serializing data.\n   */\n  constructor(_firestore,\n  /**\n   * @private\n   * @internal\n   **/\n  _path,\n  /**\n   * @internal\n   * @private\n   **/\n  _converter = (0, types_1.defaultConverter)()) {\n    this._firestore = _firestore;\n    this._path = _path;\n    this._converter = _converter;\n  }\n  /**\n   * The string representation of the DocumentReference's location.\n   * @private\n   * @internal\n   * @type {string}\n   * @name DocumentReference#formattedName\n   */\n  get formattedName() {\n    const projectId = this.firestore.projectId;\n    const databaseId = this.firestore.databaseId;\n    return this._path.toQualifiedResourcePath(projectId, databaseId).formattedName;\n  }\n  /**\n   * The [Firestore]{@link Firestore} instance for the Firestore\n   * database (useful for performing transactions, etc.).\n   *\n   * @type {Firestore}\n   * @name DocumentReference#firestore\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   let firestore = documentReference.firestore;\n   *   console.log(`Root location for document is ${firestore.formattedName}`);\n   * });\n   * ```\n   */\n  get firestore() {\n    return this._firestore;\n  }\n  /**\n   * A string representing the path of the referenced document (relative\n   * to the root of the database).\n   *\n   * @type {string}\n   * @name DocumentReference#path\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document at '${documentReference.path}'`);\n   * });\n   * ```\n   */\n  get path() {\n    return this._path.relativeName;\n  }\n  /**\n   * The last path element of the referenced document.\n   *\n   * @type {string}\n   * @name DocumentReference#id\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document with name '${documentReference.id}'`);\n   * });\n   * ```\n   */\n  get id() {\n    return this._path.id;\n  }\n  /**\n   * Returns a resource path for this document.\n   * @private\n   * @internal\n   */\n  get _resourcePath() {\n    return this._path;\n  }\n  /**\n   * A reference to the collection to which this DocumentReference belongs.\n   *\n   * @name DocumentReference#parent\n   * @type {CollectionReference}\n   * @readonly\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   * let collectionRef = documentRef.parent;\n   *\n   * collectionRef.where('foo', '==', 'bar').get().then(results => {\n   *   console.log(`Found ${results.size} matches in parent collection`);\n   * }):\n   * ```\n   */\n  get parent() {\n    return new collection_reference_1.CollectionReference(this._firestore, this._path.parent(), this._converter);\n  }\n  /**\n   * Reads the document referred to by this DocumentReference.\n   *\n   * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\n   * DocumentSnapshot for the retrieved document on success. For missing\n   * documents, DocumentSnapshot.exists will be false. If the get() fails for\n   * other reasons, the Promise will be rejected.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     console.log('Document retrieved successfully.');\n   *   }\n   * });\n   * ```\n   */\n  get() {\n    return this._firestore.getAll(this).then(([result]) => result);\n  }\n  /**\n   * Gets a [CollectionReference]{@link CollectionReference} instance\n   * that refers to the collection at the specified path.\n   *\n   * @param {string} collectionPath A slash-separated path to a collection.\n   * @returns {CollectionReference} A reference to the new\n   * subcollection.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   * let subcollection = documentRef.collection('subcollection');\n   * console.log(`Path to subcollection: ${subcollection.path}`);\n   * ```\n   */\n  collection(collectionPath) {\n    (0, path_1.validateResourcePath)('collectionPath', collectionPath);\n    const path = this._path.append(collectionPath);\n    if (!path.isCollection) {\n      throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\n    }\n    return new collection_reference_1.CollectionReference(this._firestore, path);\n  }\n  /**\n   * Fetches the subcollections that are direct children of this document.\n   *\n   * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n   * with an array of CollectionReferences.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.listCollections().then(collections => {\n   *   for (let collection of collections) {\n   *     console.log(`Found subcollection with id: ${collection.id}`);\n   *   }\n   * });\n   * ```\n   */\n  listCollections() {\n    const tag = (0, util_1.requestTag)();\n    return this.firestore.initializeIfNeeded(tag).then(() => {\n      const request = {\n        parent: this.formattedName,\n        // Setting `pageSize` to an arbitrarily large value lets the backend cap\n        // the page size (currently to 300). Note that the backend rejects\n        // MAX_INT32 (b/146883794).\n        pageSize: Math.pow(2, 16) - 1\n      };\n      return this._firestore.request('listCollectionIds', request, tag).then(collectionIds => {\n        const collections = [];\n        // We can just sort this list using the default comparator since it\n        // will only contain collection ids.\n        collectionIds.sort();\n        for (const collectionId of collectionIds) {\n          collections.push(this.collection(collectionId));\n        }\n        return collections;\n      });\n    });\n  }\n  /**\n   * Create a document with the provided object values. This will fail the write\n   * if a document exists at its location.\n   *\n   * @param {DocumentData} data An object that contains the fields and data to\n   * serialize as the document.\n   * @throws {Error} If the provided input is not a valid Firestore document or if the document already exists.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * write time of this create.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * documentRef.create({foo: 'bar'}).then((res) => {\n   *   console.log(`Document created at ${res.updateTime}`);\n   * }).catch((err) => {\n   *   console.log(`Failed to create document: ${err}`);\n   * });\n   * ```\n   */\n  create(data) {\n    const writeBatch = new index_1.WriteBatch(this._firestore);\n    return writeBatch.create(this, data).commit().then(([writeResult]) => writeResult);\n  }\n  /**\n   * Deletes the document referred to by this `DocumentReference`.\n   *\n   * A delete for a non-existing document is treated as a success (unless\n   * lastUptimeTime is provided).\n   *\n   * @param {Precondition=} precondition A precondition to enforce for this\n   * delete.\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n   * document was last updated at lastUpdateTime. Fails the delete if the\n   * document was last updated at a different time.\n   * @param {boolean=} precondition.exists If set, enforces that the target\n   * document must or must not exist.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * delete time.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.delete().then(() => {\n   *   console.log('Document successfully deleted.');\n   * });\n   * ```\n   */\n  delete(precondition) {\n    const writeBatch = new index_1.WriteBatch(this._firestore);\n    return writeBatch.delete(this, precondition).commit().then(([writeResult]) => writeResult);\n  }\n  /**\n   * Writes to the document referred to by this DocumentReference. If the\n   * document does not yet exist, it will be created. If you pass\n   * [SetOptions]{@link SetOptions}, the provided data can be merged into an\n   * existing document.\n   *\n   * @param {T|Partial<AppModelType>} data A map of the fields and values for\n   * the document.\n   * @param {SetOptions=} options An object to configure the set behavior.\n   * @param {boolean=} options.merge If true, set() merges the values specified\n   * in its data argument. Fields omitted from this set() call remain untouched.\n   * If your input sets any field to an empty map, all nested fields are\n   * overwritten.\n   * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\n   * set() only replaces the specified field paths. Any field path that is not\n   * specified is ignored and remains untouched. If your input sets any field to\n   * an empty map, all nested fields are overwritten.\n   * @throws {Error} If the provided input is not a valid Firestore document.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * write time of this set.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({foo: 'bar'}).then(res => {\n   *   console.log(`Document written at ${res.updateTime}`);\n   * });\n   * ```\n   */\n  set(data, options) {\n    let writeBatch = new index_1.WriteBatch(this._firestore);\n    if (options) {\n      writeBatch = writeBatch.set(this, data, options);\n    } else {\n      writeBatch = writeBatch.set(this, data);\n    }\n    return writeBatch.commit().then(([writeResult]) => writeResult);\n  }\n  /**\n   * Updates fields in the document referred to by this DocumentReference.\n   * If the document doesn't yet exist, the update fails and the returned\n   * Promise will be rejected.\n   *\n   * The update() method accepts either an object with field paths encoded as\n   * keys and field values encoded as values, or a variable number of arguments\n   * that alternate between field paths and field values.\n   *\n   * A Precondition restricting this update can be specified as the last\n   * argument.\n   *\n   * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n   * fields and values with which to update the document or the path of the\n   * first field to update.\n   * @param {\n   * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\n   * list of field paths and values to update or a Precondition to restrict\n   * this update.\n   * @throws {Error} If the provided input is not valid Firestore data.\n   * @returns {Promise.<WriteResult>} A Promise that resolves once the\n   * data has been successfully written to the backend.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.update({foo: 'bar'}).then(res => {\n   *   console.log(`Document updated at ${res.updateTime}`);\n   * });\n   * ```\n   */\n  update(dataOrField, ...preconditionOrValues) {\n    // eslint-disable-next-line prefer-rest-params\n    (0, validate_1.validateMinNumberOfArguments)('DocumentReference.update', arguments, 1);\n    const writeBatch = new index_1.WriteBatch(this._firestore);\n    return writeBatch.update(this, dataOrField, ...preconditionOrValues).commit().then(([writeResult]) => writeResult);\n  }\n  /**\n   * Attaches a listener for DocumentSnapshot events.\n   *\n   * @param {documentSnapshotCallback} onNext A callback to be called every\n   * time a new `DocumentSnapshot` is available.\n   * @param {errorCallback=} onError A callback to be called if the listen fails\n   * or is cancelled. No further callbacks will occur. If unset, errors will be\n   * logged to the console.\n   *\n   * @returns {function()} An unsubscribe function that can be called to cancel\n   * the snapshot listener.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(documentSnapshot.data());\n   *   }\n   * }, err => {\n   *   console.log(`Encountered error: ${err}`);\n   * });\n   *\n   * // Remove this listener.\n   * unsubscribe();\n   * ```\n   */\n  onSnapshot(onNext, onError) {\n    (0, validate_1.validateFunction)('onNext', onNext);\n    (0, validate_1.validateFunction)('onError', onError, {\n      optional: true\n    });\n    const watch = new (require('../watch').DocumentWatch)(this.firestore, this);\n    return watch.onSnapshot((readTime, size, docs) => {\n      for (const document of docs()) {\n        if (document.ref.path === this.path) {\n          onNext(document);\n          return;\n        }\n      }\n      // The document is missing.\n      const ref = new DocumentReference(this._firestore, this._path, this._converter);\n      const document = new document_1.DocumentSnapshotBuilder(ref);\n      document.readTime = readTime;\n      onNext(document.build());\n    }, onError || console.error);\n  }\n  /**\n   * Returns true if this `DocumentReference` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `DocumentReference` is equal to the provided\n   * value.\n   */\n  isEqual(other) {\n    return this === other || other instanceof DocumentReference && this._firestore === other._firestore && this._path.isEqual(other._path) && this._converter === other._converter;\n  }\n  /**\n   * Converts this DocumentReference to the Firestore Proto representation.\n   *\n   * @private\n   * @internal\n   */\n  toProto() {\n    return {\n      referenceValue: this.formattedName\n    };\n  }\n  /**\n   * Applies a custom data converter to this DocumentReference, allowing you to\n   * use your own custom model objects with Firestore. When you call set(),\n   * get(), etc. on the returned DocumentReference instance, the provided\n   * converter will convert between Firestore data of type `NewDbModelType` and\n   * your custom type `NewAppModelType`.\n   *\n   * Using the converter allows you to specify generic type arguments when\n   * storing and retrieving objects from Firestore.\n   *\n   * Passing in `null` as the converter parameter removes the current\n   * converter.\n   *\n   * @example\n   * ```\n   * class Post {\n   *   constructor(readonly title: string, readonly author: string) {}\n   *\n   *   toString(): string {\n   *     return this.title + ', by ' + this.author;\n   *   }\n   * }\n   *\n   * const postConverter = {\n   *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n   *     return {title: post.title, author: post.author};\n   *   },\n   *   fromFirestore(\n   *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\n   *   ): Post {\n   *     const data = snapshot.data();\n   *     return new Post(data.title, data.author);\n   *   }\n   * };\n   *\n   * const postSnap = await Firestore()\n   *   .collection('posts')\n   *   .withConverter(postConverter)\n   *   .doc().get();\n   * const post = postSnap.data();\n   * if (post !== undefined) {\n   *   post.title; // string\n   *   post.toString(); // Should be defined\n   *   post.someNonExistentProperty; // TS error\n   * }\n   *\n   * ```\n   * @param {FirestoreDataConverter | null} converter Converts objects to and\n   * from Firestore. Passing in `null` removes the current converter.\n   * @return A DocumentReference that uses the provided converter.\n   */\n  withConverter(converter) {\n    return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());\n  }\n}\nexports.DocumentReference = DocumentReference;","map":{"version":3,"names":["Object","defineProperty","exports","value","DocumentReference","index_1","require","path_1","types_1","collection_reference_1","util_1","validate_1","document_1","constructor","_firestore","_path","_converter","defaultConverter","formattedName","projectId","firestore","databaseId","toQualifiedResourcePath","path","relativeName","id","_resourcePath","parent","CollectionReference","get","getAll","then","result","collection","collectionPath","validateResourcePath","append","isCollection","Error","listCollections","tag","requestTag","initializeIfNeeded","request","pageSize","Math","pow","collectionIds","collections","sort","collectionId","push","create","data","writeBatch","WriteBatch","commit","writeResult","delete","precondition","set","options","update","dataOrField","preconditionOrValues","validateMinNumberOfArguments","arguments","onSnapshot","onNext","onError","validateFunction","optional","watch","DocumentWatch","readTime","size","docs","document","ref","DocumentSnapshotBuilder","build","console","error","isEqual","other","toProto","referenceValue","withConverter","converter"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@google-cloud/firestore/build/src/reference/document-reference.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DocumentReference = void 0;\nconst index_1 = require(\"../index\");\nconst path_1 = require(\"../path\");\nconst types_1 = require(\"../types\");\nconst collection_reference_1 = require(\"./collection-reference\");\nconst util_1 = require(\"../util\");\nconst validate_1 = require(\"../validate\");\nconst document_1 = require(\"../document\");\n/**\n * A DocumentReference refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist. A DocumentReference can\n * also be used to create a\n * [CollectionReference]{@link CollectionReference} to a\n * subcollection.\n *\n * @class DocumentReference\n */\nclass DocumentReference {\n    /**\n     * @private\n     * @internal\n     * @param _firestore The Firestore Database client.\n     * @param _path The Path of this reference.\n     * @param _converter The converter to use when serializing data.\n     */\n    constructor(_firestore, \n    /**\n     * @private\n     * @internal\n     **/\n    _path, \n    /**\n     * @internal\n     * @private\n     **/\n    _converter = (0, types_1.defaultConverter)()) {\n        this._firestore = _firestore;\n        this._path = _path;\n        this._converter = _converter;\n    }\n    /**\n     * The string representation of the DocumentReference's location.\n     * @private\n     * @internal\n     * @type {string}\n     * @name DocumentReference#formattedName\n     */\n    get formattedName() {\n        const projectId = this.firestore.projectId;\n        const databaseId = this.firestore.databaseId;\n        return this._path.toQualifiedResourcePath(projectId, databaseId)\n            .formattedName;\n    }\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name DocumentReference#firestore\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     * ```\n     */\n    get firestore() {\n        return this._firestore;\n    }\n    /**\n     * A string representing the path of the referenced document (relative\n     * to the root of the database).\n     *\n     * @type {string}\n     * @name DocumentReference#path\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document at '${documentReference.path}'`);\n     * });\n     * ```\n     */\n    get path() {\n        return this._path.relativeName;\n    }\n    /**\n     * The last path element of the referenced document.\n     *\n     * @type {string}\n     * @name DocumentReference#id\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document with name '${documentReference.id}'`);\n     * });\n     * ```\n     */\n    get id() {\n        return this._path.id;\n    }\n    /**\n     * Returns a resource path for this document.\n     * @private\n     * @internal\n     */\n    get _resourcePath() {\n        return this._path;\n    }\n    /**\n     * A reference to the collection to which this DocumentReference belongs.\n     *\n     * @name DocumentReference#parent\n     * @type {CollectionReference}\n     * @readonly\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     * let collectionRef = documentRef.parent;\n     *\n     * collectionRef.where('foo', '==', 'bar').get().then(results => {\n     *   console.log(`Found ${results.size} matches in parent collection`);\n     * }):\n     * ```\n     */\n    get parent() {\n        return new collection_reference_1.CollectionReference(this._firestore, this._path.parent(), this._converter);\n    }\n    /**\n     * Reads the document referred to by this DocumentReference.\n     *\n     * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\n     * DocumentSnapshot for the retrieved document on success. For missing\n     * documents, DocumentSnapshot.exists will be false. If the get() fails for\n     * other reasons, the Promise will be rejected.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log('Document retrieved successfully.');\n     *   }\n     * });\n     * ```\n     */\n    get() {\n        return this._firestore.getAll(this).then(([result]) => result);\n    }\n    /**\n     * Gets a [CollectionReference]{@link CollectionReference} instance\n     * that refers to the collection at the specified path.\n     *\n     * @param {string} collectionPath A slash-separated path to a collection.\n     * @returns {CollectionReference} A reference to the new\n     * subcollection.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     * let subcollection = documentRef.collection('subcollection');\n     * console.log(`Path to subcollection: ${subcollection.path}`);\n     * ```\n     */\n    collection(collectionPath) {\n        (0, path_1.validateResourcePath)('collectionPath', collectionPath);\n        const path = this._path.append(collectionPath);\n        if (!path.isCollection) {\n            throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\n        }\n        return new collection_reference_1.CollectionReference(this._firestore, path);\n    }\n    /**\n     * Fetches the subcollections that are direct children of this document.\n     *\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n     * with an array of CollectionReferences.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.listCollections().then(collections => {\n     *   for (let collection of collections) {\n     *     console.log(`Found subcollection with id: ${collection.id}`);\n     *   }\n     * });\n     * ```\n     */\n    listCollections() {\n        const tag = (0, util_1.requestTag)();\n        return this.firestore.initializeIfNeeded(tag).then(() => {\n            const request = {\n                parent: this.formattedName,\n                // Setting `pageSize` to an arbitrarily large value lets the backend cap\n                // the page size (currently to 300). Note that the backend rejects\n                // MAX_INT32 (b/146883794).\n                pageSize: Math.pow(2, 16) - 1,\n            };\n            return this._firestore\n                .request('listCollectionIds', request, tag)\n                .then(collectionIds => {\n                const collections = [];\n                // We can just sort this list using the default comparator since it\n                // will only contain collection ids.\n                collectionIds.sort();\n                for (const collectionId of collectionIds) {\n                    collections.push(this.collection(collectionId));\n                }\n                return collections;\n            });\n        });\n    }\n    /**\n     * Create a document with the provided object values. This will fail the write\n     * if a document exists at its location.\n     *\n     * @param {DocumentData} data An object that contains the fields and data to\n     * serialize as the document.\n     * @throws {Error} If the provided input is not a valid Firestore document or if the document already exists.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this create.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * documentRef.create({foo: 'bar'}).then((res) => {\n     *   console.log(`Document created at ${res.updateTime}`);\n     * }).catch((err) => {\n     *   console.log(`Failed to create document: ${err}`);\n     * });\n     * ```\n     */\n    create(data) {\n        const writeBatch = new index_1.WriteBatch(this._firestore);\n        return writeBatch\n            .create(this, data)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Deletes the document referred to by this `DocumentReference`.\n     *\n     * A delete for a non-existing document is treated as a success (unless\n     * lastUptimeTime is provided).\n     *\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the delete if the\n     * document was last updated at a different time.\n     * @param {boolean=} precondition.exists If set, enforces that the target\n     * document must or must not exist.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * delete time.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.delete().then(() => {\n     *   console.log('Document successfully deleted.');\n     * });\n     * ```\n     */\n    delete(precondition) {\n        const writeBatch = new index_1.WriteBatch(this._firestore);\n        return writeBatch\n            .delete(this, precondition)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Writes to the document referred to by this DocumentReference. If the\n     * document does not yet exist, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into an\n     * existing document.\n     *\n     * @param {T|Partial<AppModelType>} data A map of the fields and values for\n     * the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge If true, set() merges the values specified\n     * in its data argument. Fields omitted from this set() call remain untouched.\n     * If your input sets any field to an empty map, all nested fields are\n     * overwritten.\n     * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched. If your input sets any field to\n     * an empty map, all nested fields are overwritten.\n     * @throws {Error} If the provided input is not a valid Firestore document.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this set.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({foo: 'bar'}).then(res => {\n     *   console.log(`Document written at ${res.updateTime}`);\n     * });\n     * ```\n     */\n    set(data, options) {\n        let writeBatch = new index_1.WriteBatch(this._firestore);\n        if (options) {\n            writeBatch = writeBatch.set(this, data, options);\n        }\n        else {\n            writeBatch = writeBatch.set(this, data);\n        }\n        return writeBatch.commit().then(([writeResult]) => writeResult);\n    }\n    /**\n     * Updates fields in the document referred to by this DocumentReference.\n     * If the document doesn't yet exist, the update fails and the returned\n     * Promise will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {\n     * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\n     * list of field paths and values to update or a Precondition to restrict\n     * this update.\n     * @throws {Error} If the provided input is not valid Firestore data.\n     * @returns {Promise.<WriteResult>} A Promise that resolves once the\n     * data has been successfully written to the backend.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.update({foo: 'bar'}).then(res => {\n     *   console.log(`Document updated at ${res.updateTime}`);\n     * });\n     * ```\n     */\n    update(dataOrField, ...preconditionOrValues) {\n        // eslint-disable-next-line prefer-rest-params\n        (0, validate_1.validateMinNumberOfArguments)('DocumentReference.update', arguments, 1);\n        const writeBatch = new index_1.WriteBatch(this._firestore);\n        return writeBatch\n            .update(this, dataOrField, ...preconditionOrValues)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Attaches a listener for DocumentSnapshot events.\n     *\n     * @param {documentSnapshotCallback} onNext A callback to be called every\n     * time a new `DocumentSnapshot` is available.\n     * @param {errorCallback=} onError A callback to be called if the listen fails\n     * or is cancelled. No further callbacks will occur. If unset, errors will be\n     * logged to the console.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(documentSnapshot.data());\n     *   }\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     * ```\n     */\n    onSnapshot(onNext, onError) {\n        (0, validate_1.validateFunction)('onNext', onNext);\n        (0, validate_1.validateFunction)('onError', onError, { optional: true });\n        const watch = new (require('../watch').DocumentWatch)(this.firestore, this);\n        return watch.onSnapshot((readTime, size, docs) => {\n            for (const document of docs()) {\n                if (document.ref.path === this.path) {\n                    onNext(document);\n                    return;\n                }\n            }\n            // The document is missing.\n            const ref = new DocumentReference(this._firestore, this._path, this._converter);\n            const document = new document_1.DocumentSnapshotBuilder(ref);\n            document.readTime = readTime;\n            onNext(document.build());\n        }, onError || console.error);\n    }\n    /**\n     * Returns true if this `DocumentReference` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentReference` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof DocumentReference &&\n                this._firestore === other._firestore &&\n                this._path.isEqual(other._path) &&\n                this._converter === other._converter));\n    }\n    /**\n     * Converts this DocumentReference to the Firestore Proto representation.\n     *\n     * @private\n     * @internal\n     */\n    toProto() {\n        return { referenceValue: this.formattedName };\n    }\n    /**\n     * Applies a custom data converter to this DocumentReference, allowing you to\n     * use your own custom model objects with Firestore. When you call set(),\n     * get(), etc. on the returned DocumentReference instance, the provided\n     * converter will convert between Firestore data of type `NewDbModelType` and\n     * your custom type `NewAppModelType`.\n     *\n     * Using the converter allows you to specify generic type arguments when\n     * storing and retrieving objects from Firestore.\n     *\n     * Passing in `null` as the converter parameter removes the current\n     * converter.\n     *\n     * @example\n     * ```\n     * class Post {\n     *   constructor(readonly title: string, readonly author: string) {}\n     *\n     *   toString(): string {\n     *     return this.title + ', by ' + this.author;\n     *   }\n     * }\n     *\n     * const postConverter = {\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n     *     return {title: post.title, author: post.author};\n     *   },\n     *   fromFirestore(\n     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\n     *   ): Post {\n     *     const data = snapshot.data();\n     *     return new Post(data.title, data.author);\n     *   }\n     * };\n     *\n     * const postSnap = await Firestore()\n     *   .collection('posts')\n     *   .withConverter(postConverter)\n     *   .doc().get();\n     * const post = postSnap.data();\n     * if (post !== undefined) {\n     *   post.title; // string\n     *   post.toString(); // Should be defined\n     *   post.someNonExistentProperty; // TS error\n     * }\n     *\n     * ```\n     * @param {FirestoreDataConverter | null} converter Converts objects to and\n     * from Firestore. Passing in `null` removes the current converter.\n     * @return A DocumentReference that uses the provided converter.\n     */\n    withConverter(converter) {\n        return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());\n    }\n}\nexports.DocumentReference = DocumentReference;\n//# sourceMappingURL=document-reference.js.map"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,iBAAiB,GAAG,KAAK,CAAC;AAClC,MAAMC,OAAO,GAAGC,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMC,MAAM,GAAGD,OAAO,CAAC,SAAS,CAAC;AACjC,MAAME,OAAO,GAAGF,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMG,sBAAsB,GAAGH,OAAO,CAAC,wBAAwB,CAAC;AAChE,MAAMI,MAAM,GAAGJ,OAAO,CAAC,SAAS,CAAC;AACjC,MAAMK,UAAU,GAAGL,OAAO,CAAC,aAAa,CAAC;AACzC,MAAMM,UAAU,GAAGN,OAAO,CAAC,aAAa,CAAC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMF,iBAAiB,CAAC;EACpB;AACJ;AACA;AACA;AACA;AACA;AACA;EACIS,WAAWA,CAACC,UAAU;EACtB;AACJ;AACA;AACA;EACIC,KAAK;EACL;AACJ;AACA;AACA;EACIC,UAAU,GAAG,CAAC,CAAC,EAAER,OAAO,CAACS,gBAAgB,EAAE,CAAC,EAAE;IAC1C,IAAI,CAACH,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,UAAU,GAAGA,UAAU;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIE,aAAaA,CAAA,EAAG;IAChB,MAAMC,SAAS,GAAG,IAAI,CAACC,SAAS,CAACD,SAAS;IAC1C,MAAME,UAAU,GAAG,IAAI,CAACD,SAAS,CAACC,UAAU;IAC5C,OAAO,IAAI,CAACN,KAAK,CAACO,uBAAuB,CAACH,SAAS,EAAEE,UAAU,CAAC,CAC3DH,aAAa;EACtB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIE,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACN,UAAU;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIS,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACR,KAAK,CAACS,YAAY;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,EAAEA,CAAA,EAAG;IACL,OAAO,IAAI,CAACV,KAAK,CAACU,EAAE;EACxB;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIC,aAAaA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACX,KAAK;EACrB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIY,MAAMA,CAAA,EAAG;IACT,OAAO,IAAIlB,sBAAsB,CAACmB,mBAAmB,CAAC,IAAI,CAACd,UAAU,EAAE,IAAI,CAACC,KAAK,CAACY,MAAM,CAAC,CAAC,EAAE,IAAI,CAACX,UAAU,CAAC;EAChH;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIa,GAAGA,CAAA,EAAG;IACF,OAAO,IAAI,CAACf,UAAU,CAACgB,MAAM,CAAC,IAAI,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,MAAM,CAAC,KAAKA,MAAM,CAAC;EAClE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,UAAUA,CAACC,cAAc,EAAE;IACvB,CAAC,CAAC,EAAE3B,MAAM,CAAC4B,oBAAoB,EAAE,gBAAgB,EAAED,cAAc,CAAC;IAClE,MAAMX,IAAI,GAAG,IAAI,CAACR,KAAK,CAACqB,MAAM,CAACF,cAAc,CAAC;IAC9C,IAAI,CAACX,IAAI,CAACc,YAAY,EAAE;MACpB,MAAM,IAAIC,KAAK,CAAC,4EAA4EJ,cAAc,4DAA4D,CAAC;IAC3K;IACA,OAAO,IAAIzB,sBAAsB,CAACmB,mBAAmB,CAAC,IAAI,CAACd,UAAU,EAAES,IAAI,CAAC;EAChF;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIgB,eAAeA,CAAA,EAAG;IACd,MAAMC,GAAG,GAAG,CAAC,CAAC,EAAE9B,MAAM,CAAC+B,UAAU,EAAE,CAAC;IACpC,OAAO,IAAI,CAACrB,SAAS,CAACsB,kBAAkB,CAACF,GAAG,CAAC,CAACT,IAAI,CAAC,MAAM;MACrD,MAAMY,OAAO,GAAG;QACZhB,MAAM,EAAE,IAAI,CAACT,aAAa;QAC1B;QACA;QACA;QACA0B,QAAQ,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG;MAChC,CAAC;MACD,OAAO,IAAI,CAAChC,UAAU,CACjB6B,OAAO,CAAC,mBAAmB,EAAEA,OAAO,EAAEH,GAAG,CAAC,CAC1CT,IAAI,CAACgB,aAAa,IAAI;QACvB,MAAMC,WAAW,GAAG,EAAE;QACtB;QACA;QACAD,aAAa,CAACE,IAAI,CAAC,CAAC;QACpB,KAAK,MAAMC,YAAY,IAAIH,aAAa,EAAE;UACtCC,WAAW,CAACG,IAAI,CAAC,IAAI,CAAClB,UAAU,CAACiB,YAAY,CAAC,CAAC;QACnD;QACA,OAAOF,WAAW;MACtB,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,MAAMA,CAACC,IAAI,EAAE;IACT,MAAMC,UAAU,GAAG,IAAIjD,OAAO,CAACkD,UAAU,CAAC,IAAI,CAACzC,UAAU,CAAC;IAC1D,OAAOwC,UAAU,CACZF,MAAM,CAAC,IAAI,EAAEC,IAAI,CAAC,CAClBG,MAAM,CAAC,CAAC,CACRzB,IAAI,CAAC,CAAC,CAAC0B,WAAW,CAAC,KAAKA,WAAW,CAAC;EAC7C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,MAAMA,CAACC,YAAY,EAAE;IACjB,MAAML,UAAU,GAAG,IAAIjD,OAAO,CAACkD,UAAU,CAAC,IAAI,CAACzC,UAAU,CAAC;IAC1D,OAAOwC,UAAU,CACZI,MAAM,CAAC,IAAI,EAAEC,YAAY,CAAC,CAC1BH,MAAM,CAAC,CAAC,CACRzB,IAAI,CAAC,CAAC,CAAC0B,WAAW,CAAC,KAAKA,WAAW,CAAC;EAC7C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,GAAGA,CAACP,IAAI,EAAEQ,OAAO,EAAE;IACf,IAAIP,UAAU,GAAG,IAAIjD,OAAO,CAACkD,UAAU,CAAC,IAAI,CAACzC,UAAU,CAAC;IACxD,IAAI+C,OAAO,EAAE;MACTP,UAAU,GAAGA,UAAU,CAACM,GAAG,CAAC,IAAI,EAAEP,IAAI,EAAEQ,OAAO,CAAC;IACpD,CAAC,MACI;MACDP,UAAU,GAAGA,UAAU,CAACM,GAAG,CAAC,IAAI,EAAEP,IAAI,CAAC;IAC3C;IACA,OAAOC,UAAU,CAACE,MAAM,CAAC,CAAC,CAACzB,IAAI,CAAC,CAAC,CAAC0B,WAAW,CAAC,KAAKA,WAAW,CAAC;EACnE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIK,MAAMA,CAACC,WAAW,EAAE,GAAGC,oBAAoB,EAAE;IACzC;IACA,CAAC,CAAC,EAAErD,UAAU,CAACsD,4BAA4B,EAAE,0BAA0B,EAAEC,SAAS,EAAE,CAAC,CAAC;IACtF,MAAMZ,UAAU,GAAG,IAAIjD,OAAO,CAACkD,UAAU,CAAC,IAAI,CAACzC,UAAU,CAAC;IAC1D,OAAOwC,UAAU,CACZQ,MAAM,CAAC,IAAI,EAAEC,WAAW,EAAE,GAAGC,oBAAoB,CAAC,CAClDR,MAAM,CAAC,CAAC,CACRzB,IAAI,CAAC,CAAC,CAAC0B,WAAW,CAAC,KAAKA,WAAW,CAAC;EAC7C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIU,UAAUA,CAACC,MAAM,EAAEC,OAAO,EAAE;IACxB,CAAC,CAAC,EAAE1D,UAAU,CAAC2D,gBAAgB,EAAE,QAAQ,EAAEF,MAAM,CAAC;IAClD,CAAC,CAAC,EAAEzD,UAAU,CAAC2D,gBAAgB,EAAE,SAAS,EAAED,OAAO,EAAE;MAAEE,QAAQ,EAAE;IAAK,CAAC,CAAC;IACxE,MAAMC,KAAK,GAAG,KAAKlE,OAAO,CAAC,UAAU,CAAC,CAACmE,aAAa,EAAE,IAAI,CAACrD,SAAS,EAAE,IAAI,CAAC;IAC3E,OAAOoD,KAAK,CAACL,UAAU,CAAC,CAACO,QAAQ,EAAEC,IAAI,EAAEC,IAAI,KAAK;MAC9C,KAAK,MAAMC,QAAQ,IAAID,IAAI,CAAC,CAAC,EAAE;QAC3B,IAAIC,QAAQ,CAACC,GAAG,CAACvD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;UACjC6C,MAAM,CAACS,QAAQ,CAAC;UAChB;QACJ;MACJ;MACA;MACA,MAAMC,GAAG,GAAG,IAAI1E,iBAAiB,CAAC,IAAI,CAACU,UAAU,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACC,UAAU,CAAC;MAC/E,MAAM6D,QAAQ,GAAG,IAAIjE,UAAU,CAACmE,uBAAuB,CAACD,GAAG,CAAC;MAC5DD,QAAQ,CAACH,QAAQ,GAAGA,QAAQ;MAC5BN,MAAM,CAACS,QAAQ,CAACG,KAAK,CAAC,CAAC,CAAC;IAC5B,CAAC,EAAEX,OAAO,IAAIY,OAAO,CAACC,KAAK,CAAC;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,OAAOA,CAACC,KAAK,EAAE;IACX,OAAQ,IAAI,KAAKA,KAAK,IACjBA,KAAK,YAAYhF,iBAAiB,IAC/B,IAAI,CAACU,UAAU,KAAKsE,KAAK,CAACtE,UAAU,IACpC,IAAI,CAACC,KAAK,CAACoE,OAAO,CAACC,KAAK,CAACrE,KAAK,CAAC,IAC/B,IAAI,CAACC,UAAU,KAAKoE,KAAK,CAACpE,UAAW;EACjD;EACA;AACJ;AACA;AACA;AACA;AACA;EACIqE,OAAOA,CAAA,EAAG;IACN,OAAO;MAAEC,cAAc,EAAE,IAAI,CAACpE;IAAc,CAAC;EACjD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIqE,aAAaA,CAACC,SAAS,EAAE;IACrB,OAAO,IAAIpF,iBAAiB,CAAC,IAAI,CAACgB,SAAS,EAAE,IAAI,CAACL,KAAK,EAAEyE,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG,CAAC,CAAC,EAAEhF,OAAO,CAACS,gBAAgB,EAAE,CAAC,CAAC;EACtJ;AACJ;AACAf,OAAO,CAACE,iBAAiB,GAAGA,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}