{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryUtil = void 0;\nconst stream_1 = require(\"stream\");\nconst timestamp_1 = require(\"../timestamp\");\nconst document_1 = require(\"../document\");\nconst util_1 = require(\"../util\");\nconst document_change_1 = require(\"../document-change\");\nconst query_profile_1 = require(\"../query-profile\");\nconst logger_1 = require(\"../logger\");\nconst types_1 = require(\"./types\");\nconst constants_1 = require(\"./constants\");\nclass QueryUtil {\n  constructor( /** @private */\n  _firestore, /** @private */\n  _queryOptions, /** @private */\n  _serializer) {\n    this._firestore = _firestore;\n    this._queryOptions = _queryOptions;\n    this._serializer = _serializer;\n  }\n  _getResponse(query, transactionOrReadTime, retryWithCursor = true, explainOptions) {\n    // Capture the error stack to preserve stack tracing across async calls.\n    const stack = Error().stack;\n    return new Promise((resolve, reject) => {\n      const docs = [];\n      const output = {};\n      this._stream(query, transactionOrReadTime, retryWithCursor, explainOptions).on('error', err => {\n        reject((0, util_1.wrapError)(err, stack));\n      }).on('data', data => {\n        if (data.transaction) {\n          output.transaction = data.transaction;\n        }\n        if (data.readTime) {\n          output.readTime = data.readTime;\n        }\n        if (data.explainMetrics) {\n          output.explainMetrics = data.explainMetrics;\n        }\n        if (data.document) {\n          docs.push(data.document);\n        }\n      }).on('end', () => {\n        if (this._queryOptions.limitType === types_1.LimitType.Last) {\n          // The results for limitToLast queries need to be flipped since\n          // we reversed the ordering constraints before sending the query\n          // to the backend.\n          docs.reverse();\n        }\n        // Only return a snapshot when we have a readTime\n        // explain queries with analyze !== true will return no documents and no read time\n        const result = output.readTime ? query._createSnapshot(output.readTime, docs.length, () => docs, () => {\n          const changes = [];\n          for (let i = 0; i < docs.length; ++i) {\n            changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n          }\n          return changes;\n        }) : undefined;\n        resolve({\n          transaction: output.transaction,\n          explainMetrics: output.explainMetrics,\n          result\n        });\n      });\n    });\n  }\n  // This method exists solely to enable unit tests to mock it.\n  _isPermanentRpcError(err, methodName) {\n    return (0, util_1.isPermanentRpcError)(err, methodName);\n  }\n  _hasRetryTimedOut(methodName, startTime) {\n    const totalTimeout = (0, util_1.getTotalTimeout)(methodName);\n    if (totalTimeout === 0) {\n      return false;\n    }\n    return Date.now() - startTime >= totalTimeout;\n  }\n  stream(query) {\n    if (this._queryOptions.limitType === types_1.LimitType.Last) {\n      throw new Error('Query results for queries that include limitToLast() ' + 'constraints cannot be streamed. Use Query.get() instead.');\n    }\n    const responseStream = this._stream(query);\n    const transform = new stream_1.Transform({\n      objectMode: true,\n      transform(chunk, encoding, callback) {\n        callback(undefined, chunk.document);\n      }\n    });\n    responseStream.pipe(transform);\n    responseStream.on('error', e => transform.destroy(e));\n    return transform;\n  }\n  _stream(query, transactionOrReadTime, retryWithCursor = true, explainOptions) {\n    const tag = (0, util_1.requestTag)();\n    const startTime = Date.now();\n    const isExplain = explainOptions !== undefined;\n    let lastReceivedDocument = null;\n    let backendStream;\n    const stream = new stream_1.Transform({\n      objectMode: true,\n      transform: (proto, enc, callback) => {\n        var _a;\n        if (proto === constants_1.NOOP_MESSAGE) {\n          callback(undefined);\n          return;\n        }\n        const output = {};\n        // Proto comes with zero-length buffer by default\n        if ((_a = proto.transaction) === null || _a === void 0 ? void 0 : _a.length) {\n          output.transaction = proto.transaction;\n        }\n        if (proto.readTime) {\n          output.readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n        }\n        if (proto.document) {\n          const document = this._firestore.snapshot_(proto.document, proto.readTime);\n          const finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(this._queryOptions.converter));\n          // Recreate the QueryDocumentSnapshot with the DocumentReference\n          // containing the original converter.\n          finalDoc.fieldsProto = document._fieldsProto;\n          finalDoc.readTime = document.readTime;\n          finalDoc.createTime = document.createTime;\n          finalDoc.updateTime = document.updateTime;\n          lastReceivedDocument = finalDoc.build();\n          output.document = lastReceivedDocument;\n        }\n        if (proto.explainMetrics) {\n          output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, this._serializer);\n        }\n        callback(undefined, output);\n        if (proto.done) {\n          (0, logger_1.logger)('QueryUtil._stream', tag, 'Trigger Logical Termination.');\n          backendStream.unpipe(stream);\n          backendStream.resume();\n          backendStream.end();\n          stream.end();\n        }\n      }\n    });\n    this._firestore.initializeIfNeeded(tag).then(async () => {\n      // `toProto()` might throw an exception. We rely on the behavior of an\n      // async function to convert this exception into the rejected Promise we\n      // catch below.\n      let request = query.toProto(transactionOrReadTime, explainOptions);\n      let streamActive;\n      do {\n        streamActive = new util_1.Deferred();\n        const methodName = 'runQuery';\n        backendStream = await this._firestore.requestStream(methodName, /* bidirectional= */false, request, tag);\n        backendStream.on('error', err => {\n          backendStream.unpipe(stream);\n          // If a non-transactional query failed, attempt to restart.\n          // Transactional queries are retried via the transaction runner.\n          // Explain queries are not retried with a cursor. That would produce\n          // incorrect/partial profiling results.\n          if (!isExplain && !transactionOrReadTime && !this._isPermanentRpcError(err, 'runQuery')) {\n            (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with retryable stream error:', err);\n            // Enqueue a \"no-op\" write into the stream and wait for it to be\n            // read by the downstream consumer. This ensures that all enqueued\n            // results in the stream are consumed, which will give us an accurate\n            // value for `lastReceivedDocument`.\n            stream.write(constants_1.NOOP_MESSAGE, () => {\n              if (this._hasRetryTimedOut(methodName, startTime)) {\n                (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with retryable stream error but the total retry timeout has exceeded.');\n                stream.destroy(err);\n                streamActive.resolve( /* active= */false);\n              } else if (lastReceivedDocument && retryWithCursor) {\n                (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error and progress was made receiving ' + 'documents, so the stream is being retried.');\n                // Restart the query but use the last document we received as\n                // the query cursor. Note that we do not use backoff here. The\n                // call to `requestStream()` will backoff should the restart\n                // fail before delivering any results.\n                if (this._queryOptions.requireConsistency) {\n                  request = query.startAfter(lastReceivedDocument).toProto(lastReceivedDocument.readTime);\n                } else {\n                  request = query.startAfter(lastReceivedDocument).toProto();\n                }\n                // Set lastReceivedDocument to null before each retry attempt to ensure the retry makes progress\n                lastReceivedDocument = null;\n                streamActive.resolve( /* active= */true);\n              } else {\n                (0, logger_1.logger)('QueryUtil._stream', tag, `Query failed with retryable stream error however either retryWithCursor=\"${retryWithCursor}\", or ` + 'no progress was made receiving documents, so the stream is being closed.');\n                stream.destroy(err);\n                streamActive.resolve( /* active= */false);\n              }\n            });\n          } else {\n            (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with stream error:', err);\n            stream.destroy(err);\n            streamActive.resolve( /* active= */false);\n          }\n        });\n        backendStream.on('end', () => {\n          streamActive.resolve( /* active= */false);\n        });\n        backendStream.resume();\n        backendStream.pipe(stream);\n      } while (await streamActive.promise);\n    }).catch(e => stream.destroy(e));\n    return stream;\n  }\n}\nexports.QueryUtil = QueryUtil;","map":{"version":3,"names":["Object","defineProperty","exports","value","QueryUtil","stream_1","require","timestamp_1","document_1","util_1","document_change_1","query_profile_1","logger_1","types_1","constants_1","constructor","_firestore","_queryOptions","_serializer","_getResponse","query","transactionOrReadTime","retryWithCursor","explainOptions","stack","Error","Promise","resolve","reject","docs","output","_stream","on","err","wrapError","data","transaction","readTime","explainMetrics","document","push","limitType","LimitType","Last","reverse","result","_createSnapshot","length","changes","i","DocumentChange","undefined","_isPermanentRpcError","methodName","isPermanentRpcError","_hasRetryTimedOut","startTime","totalTimeout","getTotalTimeout","Date","now","stream","responseStream","transform","Transform","objectMode","chunk","encoding","callback","pipe","e","destroy","tag","requestTag","isExplain","lastReceivedDocument","backendStream","proto","enc","_a","NOOP_MESSAGE","Timestamp","fromProto","snapshot_","finalDoc","DocumentSnapshotBuilder","ref","withConverter","converter","fieldsProto","_fieldsProto","createTime","updateTime","build","ExplainMetrics","_fromProto","done","logger","unpipe","resume","end","initializeIfNeeded","then","request","toProto","streamActive","Deferred","requestStream","write","requireConsistency","startAfter","promise","catch"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@google-cloud/firestore/build/src/reference/query-util.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueryUtil = void 0;\nconst stream_1 = require(\"stream\");\nconst timestamp_1 = require(\"../timestamp\");\nconst document_1 = require(\"../document\");\nconst util_1 = require(\"../util\");\nconst document_change_1 = require(\"../document-change\");\nconst query_profile_1 = require(\"../query-profile\");\nconst logger_1 = require(\"../logger\");\nconst types_1 = require(\"./types\");\nconst constants_1 = require(\"./constants\");\nclass QueryUtil {\n    constructor(\n    /** @private */\n    _firestore, \n    /** @private */\n    _queryOptions, \n    /** @private */\n    _serializer) {\n        this._firestore = _firestore;\n        this._queryOptions = _queryOptions;\n        this._serializer = _serializer;\n    }\n    _getResponse(query, transactionOrReadTime, retryWithCursor = true, explainOptions) {\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        return new Promise((resolve, reject) => {\n            const docs = [];\n            const output = {};\n            this._stream(query, transactionOrReadTime, retryWithCursor, explainOptions)\n                .on('error', err => {\n                reject((0, util_1.wrapError)(err, stack));\n            })\n                .on('data', (data) => {\n                if (data.transaction) {\n                    output.transaction = data.transaction;\n                }\n                if (data.readTime) {\n                    output.readTime = data.readTime;\n                }\n                if (data.explainMetrics) {\n                    output.explainMetrics = data.explainMetrics;\n                }\n                if (data.document) {\n                    docs.push(data.document);\n                }\n            })\n                .on('end', () => {\n                if (this._queryOptions.limitType === types_1.LimitType.Last) {\n                    // The results for limitToLast queries need to be flipped since\n                    // we reversed the ordering constraints before sending the query\n                    // to the backend.\n                    docs.reverse();\n                }\n                // Only return a snapshot when we have a readTime\n                // explain queries with analyze !== true will return no documents and no read time\n                const result = output.readTime\n                    ? query._createSnapshot(output.readTime, docs.length, () => docs, () => {\n                        const changes = [];\n                        for (let i = 0; i < docs.length; ++i) {\n                            changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n                        }\n                        return changes;\n                    })\n                    : undefined;\n                resolve({\n                    transaction: output.transaction,\n                    explainMetrics: output.explainMetrics,\n                    result,\n                });\n            });\n        });\n    }\n    // This method exists solely to enable unit tests to mock it.\n    _isPermanentRpcError(err, methodName) {\n        return (0, util_1.isPermanentRpcError)(err, methodName);\n    }\n    _hasRetryTimedOut(methodName, startTime) {\n        const totalTimeout = (0, util_1.getTotalTimeout)(methodName);\n        if (totalTimeout === 0) {\n            return false;\n        }\n        return Date.now() - startTime >= totalTimeout;\n    }\n    stream(query) {\n        if (this._queryOptions.limitType === types_1.LimitType.Last) {\n            throw new Error('Query results for queries that include limitToLast() ' +\n                'constraints cannot be streamed. Use Query.get() instead.');\n        }\n        const responseStream = this._stream(query);\n        const transform = new stream_1.Transform({\n            objectMode: true,\n            transform(chunk, encoding, callback) {\n                callback(undefined, chunk.document);\n            },\n        });\n        responseStream.pipe(transform);\n        responseStream.on('error', e => transform.destroy(e));\n        return transform;\n    }\n    _stream(query, transactionOrReadTime, retryWithCursor = true, explainOptions) {\n        const tag = (0, util_1.requestTag)();\n        const startTime = Date.now();\n        const isExplain = explainOptions !== undefined;\n        let lastReceivedDocument = null;\n        let backendStream;\n        const stream = new stream_1.Transform({\n            objectMode: true,\n            transform: (proto, enc, callback) => {\n                var _a;\n                if (proto === constants_1.NOOP_MESSAGE) {\n                    callback(undefined);\n                    return;\n                }\n                const output = {};\n                // Proto comes with zero-length buffer by default\n                if ((_a = proto.transaction) === null || _a === void 0 ? void 0 : _a.length) {\n                    output.transaction = proto.transaction;\n                }\n                if (proto.readTime) {\n                    output.readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n                }\n                if (proto.document) {\n                    const document = this._firestore.snapshot_(proto.document, proto.readTime);\n                    const finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(this._queryOptions.converter));\n                    // Recreate the QueryDocumentSnapshot with the DocumentReference\n                    // containing the original converter.\n                    finalDoc.fieldsProto = document._fieldsProto;\n                    finalDoc.readTime = document.readTime;\n                    finalDoc.createTime = document.createTime;\n                    finalDoc.updateTime = document.updateTime;\n                    lastReceivedDocument = finalDoc.build();\n                    output.document = lastReceivedDocument;\n                }\n                if (proto.explainMetrics) {\n                    output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, this._serializer);\n                }\n                callback(undefined, output);\n                if (proto.done) {\n                    (0, logger_1.logger)('QueryUtil._stream', tag, 'Trigger Logical Termination.');\n                    backendStream.unpipe(stream);\n                    backendStream.resume();\n                    backendStream.end();\n                    stream.end();\n                }\n            },\n        });\n        this._firestore\n            .initializeIfNeeded(tag)\n            .then(async () => {\n            // `toProto()` might throw an exception. We rely on the behavior of an\n            // async function to convert this exception into the rejected Promise we\n            // catch below.\n            let request = query.toProto(transactionOrReadTime, explainOptions);\n            let streamActive;\n            do {\n                streamActive = new util_1.Deferred();\n                const methodName = 'runQuery';\n                backendStream = await this._firestore.requestStream(methodName, \n                /* bidirectional= */ false, request, tag);\n                backendStream.on('error', err => {\n                    backendStream.unpipe(stream);\n                    // If a non-transactional query failed, attempt to restart.\n                    // Transactional queries are retried via the transaction runner.\n                    // Explain queries are not retried with a cursor. That would produce\n                    // incorrect/partial profiling results.\n                    if (!isExplain &&\n                        !transactionOrReadTime &&\n                        !this._isPermanentRpcError(err, 'runQuery')) {\n                        (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with retryable stream error:', err);\n                        // Enqueue a \"no-op\" write into the stream and wait for it to be\n                        // read by the downstream consumer. This ensures that all enqueued\n                        // results in the stream are consumed, which will give us an accurate\n                        // value for `lastReceivedDocument`.\n                        stream.write(constants_1.NOOP_MESSAGE, () => {\n                            if (this._hasRetryTimedOut(methodName, startTime)) {\n                                (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with retryable stream error but the total retry timeout has exceeded.');\n                                stream.destroy(err);\n                                streamActive.resolve(/* active= */ false);\n                            }\n                            else if (lastReceivedDocument && retryWithCursor) {\n                                (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error and progress was made receiving ' +\n                                    'documents, so the stream is being retried.');\n                                // Restart the query but use the last document we received as\n                                // the query cursor. Note that we do not use backoff here. The\n                                // call to `requestStream()` will backoff should the restart\n                                // fail before delivering any results.\n                                if (this._queryOptions.requireConsistency) {\n                                    request = query\n                                        .startAfter(lastReceivedDocument)\n                                        .toProto(lastReceivedDocument.readTime);\n                                }\n                                else {\n                                    request = query.startAfter(lastReceivedDocument).toProto();\n                                }\n                                // Set lastReceivedDocument to null before each retry attempt to ensure the retry makes progress\n                                lastReceivedDocument = null;\n                                streamActive.resolve(/* active= */ true);\n                            }\n                            else {\n                                (0, logger_1.logger)('QueryUtil._stream', tag, `Query failed with retryable stream error however either retryWithCursor=\"${retryWithCursor}\", or ` +\n                                    'no progress was made receiving documents, so the stream is being closed.');\n                                stream.destroy(err);\n                                streamActive.resolve(/* active= */ false);\n                            }\n                        });\n                    }\n                    else {\n                        (0, logger_1.logger)('QueryUtil._stream', tag, 'Query failed with stream error:', err);\n                        stream.destroy(err);\n                        streamActive.resolve(/* active= */ false);\n                    }\n                });\n                backendStream.on('end', () => {\n                    streamActive.resolve(/* active= */ false);\n                });\n                backendStream.resume();\n                backendStream.pipe(stream);\n            } while (await streamActive.promise);\n        })\n            .catch(e => stream.destroy(e));\n        return stream;\n    }\n}\nexports.QueryUtil = QueryUtil;\n//# sourceMappingURL=query-util.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}