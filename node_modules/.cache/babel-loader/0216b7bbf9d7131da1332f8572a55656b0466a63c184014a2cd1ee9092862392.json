{"ast":null,"code":"\"use strict\";\n\nmodule.exports = decoder;\nvar Enum = require(\"./enum\"),\n  types = require(\"./types\"),\n  util = require(\"./util\");\nfunction missing(field) {\n  return \"missing required '\" + field.name + \"'\";\n}\n\n/**\r\n * Generates a decoder specific to the specified message type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\nfunction decoder(mtype) {\n  /* eslint-disable no-unexpected-multiline */\n  var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")(\"if(!(r instanceof Reader))\")(\"r=Reader.create(r)\")(\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function (field) {\n    return field.map;\n  }).length ? \",k,value\" : \"\"))(\"while(r.pos<c){\")(\"var t=r.uint32()\");\n  if (mtype.group) gen(\"if((t&7)===4)\")(\"break\");\n  gen(\"switch(t>>>3){\");\n  var i = 0;\n  for (; i < /* initializes */mtype.fieldsArray.length; ++i) {\n    var field = mtype._fieldsArray[i].resolve(),\n      type = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n      ref = \"m\" + util.safeProp(field.name);\n    gen(\"case %i: {\", field.id);\n\n    // Map fields\n    if (field.map) {\n      gen(\"if(%s===util.emptyObject)\", ref)(\"%s={}\", ref)(\"var c2 = r.uint32()+r.pos\");\n      if (types.defaults[field.keyType] !== undefined) gen(\"k=%j\", types.defaults[field.keyType]);else gen(\"k=null\");\n      if (types.defaults[type] !== undefined) gen(\"value=%j\", types.defaults[type]);else gen(\"value=null\");\n      gen(\"while(r.pos<c2){\")(\"var tag2=r.uint32()\")(\"switch(tag2>>>3){\")(\"case 1: k=r.%s(); break\", field.keyType)(\"case 2:\");\n      if (types.basic[type] === undefined) gen(\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n      else gen(\"value=r.%s()\", type);\n      gen(\"break\")(\"default:\")(\"r.skipType(tag2&7)\")(\"break\")(\"}\")(\"}\");\n      if (types.long[field.keyType] !== undefined) gen(\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=value\", ref);else gen(\"%s[k]=value\", ref);\n\n      // Repeated fields\n    } else if (field.repeated) {\n      gen(\"if(!(%s&&%s.length))\", ref, ref)(\"%s=[]\", ref);\n\n      // Packable (always check for forward and backward compatiblity)\n      if (types.packed[type] !== undefined) gen(\"if((t&7)===2){\")(\"var c2=r.uint32()+r.pos\")(\"while(r.pos<c2)\")(\"%s.push(r.%s())\", ref, type)(\"}else\");\n\n      // Non-packed\n      if (types.basic[type] === undefined) gen(field.resolvedType.group ? \"%s.push(types[%i].decode(r))\" : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);else gen(\"%s.push(r.%s())\", ref, type);\n\n      // Non-repeated\n    } else if (types.basic[type] === undefined) gen(field.resolvedType.group ? \"%s=types[%i].decode(r)\" : \"%s=types[%i].decode(r,r.uint32())\", ref, i);else gen(\"%s=r.%s()\", ref, type);\n    gen(\"break\")(\"}\");\n    // Unknown fields\n  }\n  gen(\"default:\")(\"r.skipType(t&7)\")(\"break\")(\"}\")(\"}\");\n\n  // Field presence\n  for (i = 0; i < mtype._fieldsArray.length; ++i) {\n    var rfield = mtype._fieldsArray[i];\n    if (rfield.required) gen(\"if(!m.hasOwnProperty(%j))\", rfield.name)(\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n  }\n  return gen(\"return m\");\n  /* eslint-enable no-unexpected-multiline */\n}","map":{"version":3,"names":["module","exports","decoder","Enum","require","types","util","missing","field","name","mtype","gen","codegen","fieldsArray","filter","map","length","group","i","_fieldsArray","resolve","type","resolvedType","ref","safeProp","id","defaults","keyType","undefined","basic","long","repeated","packed","rfield","required"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/protobufjs/src/decoder.js"],"sourcesContent":["\"use strict\";\r\nmodule.exports = decoder;\r\n\r\nvar Enum    = require(\"./enum\"),\r\n    types   = require(\"./types\"),\r\n    util    = require(\"./util\");\r\n\r\nfunction missing(field) {\r\n    return \"missing required '\" + field.name + \"'\";\r\n}\r\n\r\n/**\r\n * Generates a decoder specific to the specified message type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\r\nfunction decoder(mtype) {\r\n    /* eslint-disable no-unexpected-multiline */\r\n    var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")\r\n    (\"if(!(r instanceof Reader))\")\r\n        (\"r=Reader.create(r)\")\r\n    (\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? \",k,value\" : \"\"))\r\n    (\"while(r.pos<c){\")\r\n        (\"var t=r.uint32()\");\r\n    if (mtype.group) gen\r\n        (\"if((t&7)===4)\")\r\n            (\"break\");\r\n    gen\r\n        (\"switch(t>>>3){\");\r\n\r\n    var i = 0;\r\n    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {\r\n        var field = mtype._fieldsArray[i].resolve(),\r\n            type  = field.resolvedType instanceof Enum ? \"int32\" : field.type,\r\n            ref   = \"m\" + util.safeProp(field.name); gen\r\n            (\"case %i: {\", field.id);\r\n\r\n        // Map fields\r\n        if (field.map) { gen\r\n                (\"if(%s===util.emptyObject)\", ref)\r\n                    (\"%s={}\", ref)\r\n                (\"var c2 = r.uint32()+r.pos\");\r\n\r\n            if (types.defaults[field.keyType] !== undefined) gen\r\n                (\"k=%j\", types.defaults[field.keyType]);\r\n            else gen\r\n                (\"k=null\");\r\n\r\n            if (types.defaults[type] !== undefined) gen\r\n                (\"value=%j\", types.defaults[type]);\r\n            else gen\r\n                (\"value=null\");\r\n\r\n            gen\r\n                (\"while(r.pos<c2){\")\r\n                    (\"var tag2=r.uint32()\")\r\n                    (\"switch(tag2>>>3){\")\r\n                        (\"case 1: k=r.%s(); break\", field.keyType)\r\n                        (\"case 2:\");\r\n\r\n            if (types.basic[type] === undefined) gen\r\n                            (\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\r\n            else gen\r\n                            (\"value=r.%s()\", type);\r\n\r\n            gen\r\n                            (\"break\")\r\n                        (\"default:\")\r\n                            (\"r.skipType(tag2&7)\")\r\n                            (\"break\")\r\n                    (\"}\")\r\n                (\"}\");\r\n\r\n            if (types.long[field.keyType] !== undefined) gen\r\n                (\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=value\", ref);\r\n            else gen\r\n                (\"%s[k]=value\", ref);\r\n\r\n        // Repeated fields\r\n        } else if (field.repeated) { gen\r\n\r\n                (\"if(!(%s&&%s.length))\", ref, ref)\r\n                    (\"%s=[]\", ref);\r\n\r\n            // Packable (always check for forward and backward compatiblity)\r\n            if (types.packed[type] !== undefined) gen\r\n                (\"if((t&7)===2){\")\r\n                    (\"var c2=r.uint32()+r.pos\")\r\n                    (\"while(r.pos<c2)\")\r\n                        (\"%s.push(r.%s())\", ref, type)\r\n                (\"}else\");\r\n\r\n            // Non-packed\r\n            if (types.basic[type] === undefined) gen(field.resolvedType.group\r\n                    ? \"%s.push(types[%i].decode(r))\"\r\n                    : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\r\n            else gen\r\n                    (\"%s.push(r.%s())\", ref, type);\r\n\r\n        // Non-repeated\r\n        } else if (types.basic[type] === undefined) gen(field.resolvedType.group\r\n                ? \"%s=types[%i].decode(r)\"\r\n                : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\r\n        else gen\r\n                (\"%s=r.%s()\", ref, type);\r\n        gen\r\n                (\"break\")\r\n            (\"}\");\r\n        // Unknown fields\r\n    } gen\r\n            (\"default:\")\r\n                (\"r.skipType(t&7)\")\r\n                (\"break\")\r\n\r\n        (\"}\")\r\n    (\"}\");\r\n\r\n    // Field presence\r\n    for (i = 0; i < mtype._fieldsArray.length; ++i) {\r\n        var rfield = mtype._fieldsArray[i];\r\n        if (rfield.required) gen\r\n    (\"if(!m.hasOwnProperty(%j))\", rfield.name)\r\n        (\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\r\n    }\r\n\r\n    return gen\r\n    (\"return m\");\r\n    /* eslint-enable no-unexpected-multiline */\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}