{"ast":null,"code":"/*! firebase-admin v12.2.0 */\n\"use strict\";\n\n/*!\n * @license\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getApplicationDefault = exports.isApplicationDefault = exports.ImpersonatedServiceAccountCredential = exports.RefreshTokenCredential = exports.ComputeEngineCredential = exports.ServiceAccountCredential = void 0;\nconst fs = require(\"fs\");\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst error_1 = require(\"../utils/error\");\nconst api_request_1 = require(\"../utils/api-request\");\nconst util = require(\"../utils/validator\");\nconst GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';\nconst GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';\nconst GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token';\n// NOTE: the Google Metadata Service uses HTTP over a vlan\nconst GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';\nconst GOOGLE_METADATA_SERVICE_TOKEN_PATH = '/computeMetadata/v1/instance/service-accounts/default/token';\nconst GOOGLE_METADATA_SERVICE_IDENTITY_PATH = '/computeMetadata/v1/instance/service-accounts/default/identity';\nconst GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH = '/computeMetadata/v1/project/project-id';\nconst GOOGLE_METADATA_SERVICE_ACCOUNT_ID_PATH = '/computeMetadata/v1/instance/service-accounts/default/email';\nconst configDir = (() => {\n  // Windows has a dedicated low-rights location for apps at ~/Application Data\n  const sys = os.platform();\n  if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') {\n    return process.env.APPDATA;\n  }\n  // On *nix the gcloud cli creates a . dir.\n  return process.env.HOME && path.resolve(process.env.HOME, '.config');\n})();\nconst GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';\nconst GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);\nconst REFRESH_TOKEN_HOST = 'www.googleapis.com';\nconst REFRESH_TOKEN_PATH = '/oauth2/v4/token';\nconst ONE_HOUR_IN_SECONDS = 60 * 60;\nconst JWT_ALGORITHM = 'RS256';\n/**\n * Implementation of Credential that uses a service account.\n */\nclass ServiceAccountCredential {\n  /**\n   * Creates a new ServiceAccountCredential from the given parameters.\n   *\n   * @param serviceAccountPathOrObject - Service account json object or path to a service account json file.\n   * @param httpAgent - Optional http.Agent to use when calling the remote token server.\n   * @param implicit - An optinal boolean indicating whether this credential was implicitly discovered from the\n   *   environment, as opposed to being explicitly specified by the developer.\n   *\n   * @constructor\n   */\n  constructor(serviceAccountPathOrObject, httpAgent, implicit = false) {\n    this.httpAgent = httpAgent;\n    this.implicit = implicit;\n    const serviceAccount = typeof serviceAccountPathOrObject === 'string' ? ServiceAccount.fromPath(serviceAccountPathOrObject) : new ServiceAccount(serviceAccountPathOrObject);\n    this.projectId = serviceAccount.projectId;\n    this.privateKey = serviceAccount.privateKey;\n    this.clientEmail = serviceAccount.clientEmail;\n    this.httpClient = new api_request_1.HttpClient();\n  }\n  getAccessToken() {\n    const token = this.createAuthJwt_();\n    const postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' + 'grant-type%3Ajwt-bearer&assertion=' + token;\n    const request = {\n      method: 'POST',\n      url: `https://${GOOGLE_AUTH_TOKEN_HOST}${GOOGLE_AUTH_TOKEN_PATH}`,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  createAuthJwt_() {\n    const claims = {\n      scope: ['https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/firebase.database', 'https://www.googleapis.com/auth/firebase.messaging', 'https://www.googleapis.com/auth/identitytoolkit', 'https://www.googleapis.com/auth/userinfo.email'].join(' ')\n    };\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const jwt = require('jsonwebtoken');\n    // This method is actually synchronous so we can capture and return the buffer.\n    return jwt.sign(claims, this.privateKey, {\n      audience: GOOGLE_TOKEN_AUDIENCE,\n      expiresIn: ONE_HOUR_IN_SECONDS,\n      issuer: this.clientEmail,\n      algorithm: JWT_ALGORITHM\n    });\n  }\n}\nexports.ServiceAccountCredential = ServiceAccountCredential;\n/**\n * A struct containing the properties necessary to use service account JSON credentials.\n */\nclass ServiceAccount {\n  static fromPath(filePath) {\n    try {\n      return new ServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse service account json file: ' + error);\n    }\n  }\n  constructor(json) {\n    if (!util.isNonNullObject(json)) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');\n    }\n    copyAttr(this, json, 'projectId', 'project_id');\n    copyAttr(this, json, 'privateKey', 'private_key');\n    copyAttr(this, json, 'clientEmail', 'client_email');\n    let errorMessage;\n    if (!util.isNonEmptyString(this.projectId)) {\n      errorMessage = 'Service account object must contain a string \"project_id\" property.';\n    } else if (!util.isNonEmptyString(this.privateKey)) {\n      errorMessage = 'Service account object must contain a string \"private_key\" property.';\n    } else if (!util.isNonEmptyString(this.clientEmail)) {\n      errorMessage = 'Service account object must contain a string \"client_email\" property.';\n    }\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const forge = require('node-forge');\n    try {\n      forge.pki.privateKeyFromPem(this.privateKey);\n    } catch (error) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\n    }\n  }\n}\n/**\n * Implementation of Credential that gets access tokens from the metadata service available\n * in the Google Cloud Platform. This authenticates the process as the default service account\n * of an App Engine instance or Google Compute Engine machine.\n */\nclass ComputeEngineCredential {\n  constructor(httpAgent) {\n    this.httpClient = new api_request_1.HttpClient();\n    this.httpAgent = httpAgent;\n  }\n  getAccessToken() {\n    const request = this.buildRequest(GOOGLE_METADATA_SERVICE_TOKEN_PATH);\n    return requestAccessToken(this.httpClient, request);\n  }\n  /**\n   * getIDToken returns a OIDC token from the compute metadata service\n   * that can be used to make authenticated calls to audience\n   * @param audience the URL the returned ID token will be used to call.\n  */\n  getIDToken(audience) {\n    const request = this.buildRequest(`${GOOGLE_METADATA_SERVICE_IDENTITY_PATH}?audience=${audience}`);\n    return requestIDToken(this.httpClient, request);\n  }\n  getProjectId() {\n    if (this.projectId) {\n      return Promise.resolve(this.projectId);\n    }\n    const request = this.buildRequest(GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH);\n    return this.httpClient.send(request).then(resp => {\n      this.projectId = resp.text;\n      return this.projectId;\n    }).catch(err => {\n      const detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Failed to determine project ID: ${detail}`);\n    });\n  }\n  getServiceAccountEmail() {\n    if (this.accountId) {\n      return Promise.resolve(this.accountId);\n    }\n    const request = this.buildRequest(GOOGLE_METADATA_SERVICE_ACCOUNT_ID_PATH);\n    return this.httpClient.send(request).then(resp => {\n      this.accountId = resp.text;\n      return this.accountId;\n    }).catch(err => {\n      const detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Failed to determine service account email: ${detail}`);\n    });\n  }\n  buildRequest(urlPath) {\n    return {\n      method: 'GET',\n      url: `http://${GOOGLE_METADATA_SERVICE_HOST}${urlPath}`,\n      headers: {\n        'Metadata-Flavor': 'Google'\n      },\n      httpAgent: this.httpAgent\n    };\n  }\n}\nexports.ComputeEngineCredential = ComputeEngineCredential;\n/**\n * Implementation of Credential that gets access tokens from refresh tokens.\n */\nclass RefreshTokenCredential {\n  /**\n   * Creates a new RefreshTokenCredential from the given parameters.\n   *\n   * @param refreshTokenPathOrObject - Refresh token json object or path to a refresh token\n   *   (user credentials) json file.\n   * @param httpAgent - Optional http.Agent to use when calling the remote token server.\n   * @param implicit - An optinal boolean indicating whether this credential was implicitly\n   *   discovered from the environment, as opposed to being explicitly specified by the developer.\n   *\n   * @constructor\n   */\n  constructor(refreshTokenPathOrObject, httpAgent, implicit = false) {\n    this.httpAgent = httpAgent;\n    this.implicit = implicit;\n    this.refreshToken = typeof refreshTokenPathOrObject === 'string' ? RefreshToken.fromPath(refreshTokenPathOrObject) : new RefreshToken(refreshTokenPathOrObject);\n    this.httpClient = new api_request_1.HttpClient();\n  }\n  getAccessToken() {\n    const postData = 'client_id=' + this.refreshToken.clientId + '&' + 'client_secret=' + this.refreshToken.clientSecret + '&' + 'refresh_token=' + this.refreshToken.refreshToken + '&' + 'grant_type=refresh_token';\n    const request = {\n      method: 'POST',\n      url: `https://${REFRESH_TOKEN_HOST}${REFRESH_TOKEN_PATH}`,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  }\n}\nexports.RefreshTokenCredential = RefreshTokenCredential;\nclass RefreshToken {\n  /*\n   * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the\n   * data at the path is invalid.\n   */\n  static fromPath(filePath) {\n    try {\n      return new RefreshToken(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\n    }\n  }\n  constructor(json) {\n    copyAttr(this, json, 'clientId', 'client_id');\n    copyAttr(this, json, 'clientSecret', 'client_secret');\n    copyAttr(this, json, 'refreshToken', 'refresh_token');\n    copyAttr(this, json, 'type', 'type');\n    let errorMessage;\n    if (!util.isNonEmptyString(this.clientId)) {\n      errorMessage = 'Refresh token must contain a \"client_id\" property.';\n    } else if (!util.isNonEmptyString(this.clientSecret)) {\n      errorMessage = 'Refresh token must contain a \"client_secret\" property.';\n    } else if (!util.isNonEmptyString(this.refreshToken)) {\n      errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\n    } else if (!util.isNonEmptyString(this.type)) {\n      errorMessage = 'Refresh token must contain a \"type\" property.';\n    }\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n  }\n}\n/**\n * Implementation of Credential that uses impersonated service account.\n */\nclass ImpersonatedServiceAccountCredential {\n  /**\n   * Creates a new ImpersonatedServiceAccountCredential from the given parameters.\n   *\n   * @param impersonatedServiceAccountPathOrObject - Impersonated Service account json object or\n   * path to a service account json file.\n   * @param httpAgent - Optional http.Agent to use when calling the remote token server.\n   * @param implicit - An optional boolean indicating whether this credential was implicitly\n   *   discovered from the environment, as opposed to being explicitly specified by the developer.\n   *\n   * @constructor\n   */\n  constructor(impersonatedServiceAccountPathOrObject, httpAgent, implicit = false) {\n    this.httpAgent = httpAgent;\n    this.implicit = implicit;\n    this.impersonatedServiceAccount = typeof impersonatedServiceAccountPathOrObject === 'string' ? ImpersonatedServiceAccount.fromPath(impersonatedServiceAccountPathOrObject) : new ImpersonatedServiceAccount(impersonatedServiceAccountPathOrObject);\n    this.httpClient = new api_request_1.HttpClient();\n  }\n  getAccessToken() {\n    const postData = 'client_id=' + this.impersonatedServiceAccount.clientId + '&' + 'client_secret=' + this.impersonatedServiceAccount.clientSecret + '&' + 'refresh_token=' + this.impersonatedServiceAccount.refreshToken + '&' + 'grant_type=refresh_token';\n    const request = {\n      method: 'POST',\n      url: `https://${REFRESH_TOKEN_HOST}${REFRESH_TOKEN_PATH}`,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  }\n}\nexports.ImpersonatedServiceAccountCredential = ImpersonatedServiceAccountCredential;\n/**\n * A struct containing the properties necessary to use impersonated service account JSON credentials.\n */\nclass ImpersonatedServiceAccount {\n  /*\n   * Tries to load a ImpersonatedServiceAccount from a path. Throws if the path doesn't exist or the\n   * data at the path is invalid.\n   */\n  static fromPath(filePath) {\n    try {\n      return new ImpersonatedServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse impersonated service account file: ' + error);\n    }\n  }\n  constructor(json) {\n    const sourceCredentials = json['source_credentials'];\n    if (sourceCredentials) {\n      copyAttr(this, sourceCredentials, 'clientId', 'client_id');\n      copyAttr(this, sourceCredentials, 'clientSecret', 'client_secret');\n      copyAttr(this, sourceCredentials, 'refreshToken', 'refresh_token');\n      copyAttr(this, sourceCredentials, 'type', 'type');\n    }\n    let errorMessage;\n    if (!util.isNonEmptyString(this.clientId)) {\n      errorMessage = 'Impersonated Service Account must contain a \"source_credentials.client_id\" property.';\n    } else if (!util.isNonEmptyString(this.clientSecret)) {\n      errorMessage = 'Impersonated Service Account must contain a \"source_credentials.client_secret\" property.';\n    } else if (!util.isNonEmptyString(this.refreshToken)) {\n      errorMessage = 'Impersonated Service Account must contain a \"source_credentials.refresh_token\" property.';\n    } else if (!util.isNonEmptyString(this.type)) {\n      errorMessage = 'Impersonated Service Account must contain a \"source_credentials.type\" property.';\n    }\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n  }\n}\n/**\n * Checks if the given credential was loaded via the application default credentials mechanism. This\n * includes all ComputeEngineCredential instances, and the ServiceAccountCredential and RefreshTokenCredential\n * instances that were loaded from well-known files or environment variables, rather than being explicitly\n * instantiated.\n *\n * @param credential - The credential instance to check.\n */\nfunction isApplicationDefault(credential) {\n  return credential instanceof ComputeEngineCredential || credential instanceof ServiceAccountCredential && credential.implicit || credential instanceof RefreshTokenCredential && credential.implicit || credential instanceof ImpersonatedServiceAccountCredential && credential.implicit;\n}\nexports.isApplicationDefault = isApplicationDefault;\nfunction getApplicationDefault(httpAgent) {\n  if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\n    return credentialFromFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, httpAgent, false);\n  }\n  // It is OK to not have this file. If it is present, it must be valid.\n  if (GCLOUD_CREDENTIAL_PATH) {\n    const credential = credentialFromFile(GCLOUD_CREDENTIAL_PATH, httpAgent, true);\n    if (credential) return credential;\n  }\n  return new ComputeEngineCredential(httpAgent);\n}\nexports.getApplicationDefault = getApplicationDefault;\n/**\n * Copies the specified property from one object to another.\n *\n * If no property exists by the given \"key\", looks for a property identified by \"alt\", and copies it instead.\n * This can be used to implement behaviors such as \"copy property myKey or my_key\".\n *\n * @param to - Target object to copy the property into.\n * @param from - Source object to copy the property from.\n * @param key - Name of the property to copy.\n * @param alt - Alternative name of the property to copy.\n */\nfunction copyAttr(to, from, key, alt) {\n  const tmp = from[key] || from[alt];\n  if (typeof tmp !== 'undefined') {\n    to[key] = tmp;\n  }\n}\n/**\n * Obtain a new OAuth2 token by making a remote service call.\n */\nfunction requestAccessToken(client, request) {\n  return client.send(request).then(resp => {\n    const json = resp.data;\n    if (!json.access_token || !json.expires_in) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Unexpected response while fetching access token: ${JSON.stringify(json)}`);\n    }\n    return json;\n  }).catch(err => {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));\n  });\n}\n/**\n * Obtain a new OIDC token by making a remote service call.\n */\nfunction requestIDToken(client, request) {\n  return client.send(request).then(resp => {\n    if (!resp.text) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Unexpected response while fetching id token: response.text is undefined');\n    }\n    return resp.text;\n  }).catch(err => {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));\n  });\n}\n/**\n * Constructs a human-readable error message from the given Error.\n */\nfunction getErrorMessage(err) {\n  const detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;\n  return `Error fetching access token: ${detail}`;\n}\n/**\n * Extracts details from the given HTTP error response, and returns a human-readable description. If\n * the response is JSON-formatted, looks up the error and error_description fields sent by the\n * Google Auth servers. Otherwise returns the entire response payload as the error detail.\n */\nfunction getDetailFromResponse(response) {\n  if (response.isJson() && response.data.error) {\n    const json = response.data;\n    let detail = json.error;\n    if (json.error_description) {\n      detail += ' (' + json.error_description + ')';\n    }\n    return detail;\n  }\n  return response.text || 'Missing error payload';\n}\nfunction credentialFromFile(filePath, httpAgent, ignoreMissing) {\n  const credentialsFile = readCredentialFile(filePath, ignoreMissing);\n  if (typeof credentialsFile !== 'object' || credentialsFile === null) {\n    if (ignoreMissing) {\n      return null;\n    }\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object');\n  }\n  if (credentialsFile.type === 'service_account') {\n    return new ServiceAccountCredential(credentialsFile, httpAgent, true);\n  }\n  if (credentialsFile.type === 'authorized_user') {\n    return new RefreshTokenCredential(credentialsFile, httpAgent, true);\n  }\n  if (credentialsFile.type === 'impersonated_service_account') {\n    return new ImpersonatedServiceAccountCredential(credentialsFile, httpAgent, true);\n  }\n  throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Invalid contents in the credentials file');\n}\nfunction readCredentialFile(filePath, ignoreMissing) {\n  let fileText;\n  try {\n    fileText = fs.readFileSync(filePath, 'utf8');\n  } catch (error) {\n    if (ignoreMissing) {\n      return null;\n    }\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Failed to read credentials from file ${filePath}: ` + error);\n  }\n  try {\n    return JSON.parse(fileText);\n  } catch (error) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object: ' + error);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getApplicationDefault","isApplicationDefault","ImpersonatedServiceAccountCredential","RefreshTokenCredential","ComputeEngineCredential","ServiceAccountCredential","fs","require","os","path","error_1","api_request_1","util","GOOGLE_TOKEN_AUDIENCE","GOOGLE_AUTH_TOKEN_HOST","GOOGLE_AUTH_TOKEN_PATH","GOOGLE_METADATA_SERVICE_HOST","GOOGLE_METADATA_SERVICE_TOKEN_PATH","GOOGLE_METADATA_SERVICE_IDENTITY_PATH","GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH","GOOGLE_METADATA_SERVICE_ACCOUNT_ID_PATH","configDir","sys","platform","length","substring","toLowerCase","process","env","APPDATA","HOME","resolve","GCLOUD_CREDENTIAL_SUFFIX","GCLOUD_CREDENTIAL_PATH","REFRESH_TOKEN_HOST","REFRESH_TOKEN_PATH","ONE_HOUR_IN_SECONDS","JWT_ALGORITHM","constructor","serviceAccountPathOrObject","httpAgent","implicit","serviceAccount","ServiceAccount","fromPath","projectId","privateKey","clientEmail","httpClient","HttpClient","getAccessToken","token","createAuthJwt_","postData","request","method","url","headers","data","requestAccessToken","claims","scope","join","jwt","sign","audience","expiresIn","issuer","algorithm","filePath","JSON","parse","readFileSync","error","FirebaseAppError","AppErrorCodes","INVALID_CREDENTIAL","json","isNonNullObject","copyAttr","errorMessage","isNonEmptyString","forge","pki","privateKeyFromPem","buildRequest","getIDToken","requestIDToken","getProjectId","Promise","send","then","resp","text","catch","err","detail","HttpError","getDetailFromResponse","response","message","getServiceAccountEmail","accountId","urlPath","refreshTokenPathOrObject","refreshToken","RefreshToken","clientId","clientSecret","type","impersonatedServiceAccountPathOrObject","impersonatedServiceAccount","ImpersonatedServiceAccount","sourceCredentials","credential","GOOGLE_APPLICATION_CREDENTIALS","credentialFromFile","to","from","key","alt","tmp","client","access_token","expires_in","stringify","getErrorMessage","isJson","error_description","ignoreMissing","credentialsFile","readCredentialFile","fileText"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/firebase-admin/lib/app/credential-internal.js"],"sourcesContent":["/*! firebase-admin v12.2.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getApplicationDefault = exports.isApplicationDefault = exports.ImpersonatedServiceAccountCredential = exports.RefreshTokenCredential = exports.ComputeEngineCredential = exports.ServiceAccountCredential = void 0;\nconst fs = require(\"fs\");\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst error_1 = require(\"../utils/error\");\nconst api_request_1 = require(\"../utils/api-request\");\nconst util = require(\"../utils/validator\");\nconst GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';\nconst GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';\nconst GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token';\n// NOTE: the Google Metadata Service uses HTTP over a vlan\nconst GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';\nconst GOOGLE_METADATA_SERVICE_TOKEN_PATH = '/computeMetadata/v1/instance/service-accounts/default/token';\nconst GOOGLE_METADATA_SERVICE_IDENTITY_PATH = '/computeMetadata/v1/instance/service-accounts/default/identity';\nconst GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH = '/computeMetadata/v1/project/project-id';\nconst GOOGLE_METADATA_SERVICE_ACCOUNT_ID_PATH = '/computeMetadata/v1/instance/service-accounts/default/email';\nconst configDir = (() => {\n    // Windows has a dedicated low-rights location for apps at ~/Application Data\n    const sys = os.platform();\n    if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') {\n        return process.env.APPDATA;\n    }\n    // On *nix the gcloud cli creates a . dir.\n    return process.env.HOME && path.resolve(process.env.HOME, '.config');\n})();\nconst GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';\nconst GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);\nconst REFRESH_TOKEN_HOST = 'www.googleapis.com';\nconst REFRESH_TOKEN_PATH = '/oauth2/v4/token';\nconst ONE_HOUR_IN_SECONDS = 60 * 60;\nconst JWT_ALGORITHM = 'RS256';\n/**\n * Implementation of Credential that uses a service account.\n */\nclass ServiceAccountCredential {\n    /**\n     * Creates a new ServiceAccountCredential from the given parameters.\n     *\n     * @param serviceAccountPathOrObject - Service account json object or path to a service account json file.\n     * @param httpAgent - Optional http.Agent to use when calling the remote token server.\n     * @param implicit - An optinal boolean indicating whether this credential was implicitly discovered from the\n     *   environment, as opposed to being explicitly specified by the developer.\n     *\n     * @constructor\n     */\n    constructor(serviceAccountPathOrObject, httpAgent, implicit = false) {\n        this.httpAgent = httpAgent;\n        this.implicit = implicit;\n        const serviceAccount = (typeof serviceAccountPathOrObject === 'string') ?\n            ServiceAccount.fromPath(serviceAccountPathOrObject)\n            : new ServiceAccount(serviceAccountPathOrObject);\n        this.projectId = serviceAccount.projectId;\n        this.privateKey = serviceAccount.privateKey;\n        this.clientEmail = serviceAccount.clientEmail;\n        this.httpClient = new api_request_1.HttpClient();\n    }\n    getAccessToken() {\n        const token = this.createAuthJwt_();\n        const postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' +\n            'grant-type%3Ajwt-bearer&assertion=' + token;\n        const request = {\n            method: 'POST',\n            url: `https://${GOOGLE_AUTH_TOKEN_HOST}${GOOGLE_AUTH_TOKEN_PATH}`,\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            data: postData,\n            httpAgent: this.httpAgent,\n        };\n        return requestAccessToken(this.httpClient, request);\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    createAuthJwt_() {\n        const claims = {\n            scope: [\n                'https://www.googleapis.com/auth/cloud-platform',\n                'https://www.googleapis.com/auth/firebase.database',\n                'https://www.googleapis.com/auth/firebase.messaging',\n                'https://www.googleapis.com/auth/identitytoolkit',\n                'https://www.googleapis.com/auth/userinfo.email',\n            ].join(' '),\n        };\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const jwt = require('jsonwebtoken');\n        // This method is actually synchronous so we can capture and return the buffer.\n        return jwt.sign(claims, this.privateKey, {\n            audience: GOOGLE_TOKEN_AUDIENCE,\n            expiresIn: ONE_HOUR_IN_SECONDS,\n            issuer: this.clientEmail,\n            algorithm: JWT_ALGORITHM,\n        });\n    }\n}\nexports.ServiceAccountCredential = ServiceAccountCredential;\n/**\n * A struct containing the properties necessary to use service account JSON credentials.\n */\nclass ServiceAccount {\n    static fromPath(filePath) {\n        try {\n            return new ServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n        }\n        catch (error) {\n            // Throw a nicely formed error message if the file contents cannot be parsed\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse service account json file: ' + error);\n        }\n    }\n    constructor(json) {\n        if (!util.isNonNullObject(json)) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');\n        }\n        copyAttr(this, json, 'projectId', 'project_id');\n        copyAttr(this, json, 'privateKey', 'private_key');\n        copyAttr(this, json, 'clientEmail', 'client_email');\n        let errorMessage;\n        if (!util.isNonEmptyString(this.projectId)) {\n            errorMessage = 'Service account object must contain a string \"project_id\" property.';\n        }\n        else if (!util.isNonEmptyString(this.privateKey)) {\n            errorMessage = 'Service account object must contain a string \"private_key\" property.';\n        }\n        else if (!util.isNonEmptyString(this.clientEmail)) {\n            errorMessage = 'Service account object must contain a string \"client_email\" property.';\n        }\n        if (typeof errorMessage !== 'undefined') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const forge = require('node-forge');\n        try {\n            forge.pki.privateKeyFromPem(this.privateKey);\n        }\n        catch (error) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\n        }\n    }\n}\n/**\n * Implementation of Credential that gets access tokens from the metadata service available\n * in the Google Cloud Platform. This authenticates the process as the default service account\n * of an App Engine instance or Google Compute Engine machine.\n */\nclass ComputeEngineCredential {\n    constructor(httpAgent) {\n        this.httpClient = new api_request_1.HttpClient();\n        this.httpAgent = httpAgent;\n    }\n    getAccessToken() {\n        const request = this.buildRequest(GOOGLE_METADATA_SERVICE_TOKEN_PATH);\n        return requestAccessToken(this.httpClient, request);\n    }\n    /**\n     * getIDToken returns a OIDC token from the compute metadata service\n     * that can be used to make authenticated calls to audience\n     * @param audience the URL the returned ID token will be used to call.\n    */\n    getIDToken(audience) {\n        const request = this.buildRequest(`${GOOGLE_METADATA_SERVICE_IDENTITY_PATH}?audience=${audience}`);\n        return requestIDToken(this.httpClient, request);\n    }\n    getProjectId() {\n        if (this.projectId) {\n            return Promise.resolve(this.projectId);\n        }\n        const request = this.buildRequest(GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH);\n        return this.httpClient.send(request)\n            .then((resp) => {\n            this.projectId = resp.text;\n            return this.projectId;\n        })\n            .catch((err) => {\n            const detail = (err instanceof api_request_1.HttpError) ? getDetailFromResponse(err.response) : err.message;\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Failed to determine project ID: ${detail}`);\n        });\n    }\n    getServiceAccountEmail() {\n        if (this.accountId) {\n            return Promise.resolve(this.accountId);\n        }\n        const request = this.buildRequest(GOOGLE_METADATA_SERVICE_ACCOUNT_ID_PATH);\n        return this.httpClient.send(request)\n            .then((resp) => {\n            this.accountId = resp.text;\n            return this.accountId;\n        })\n            .catch((err) => {\n            const detail = (err instanceof api_request_1.HttpError) ? getDetailFromResponse(err.response) : err.message;\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Failed to determine service account email: ${detail}`);\n        });\n    }\n    buildRequest(urlPath) {\n        return {\n            method: 'GET',\n            url: `http://${GOOGLE_METADATA_SERVICE_HOST}${urlPath}`,\n            headers: {\n                'Metadata-Flavor': 'Google',\n            },\n            httpAgent: this.httpAgent,\n        };\n    }\n}\nexports.ComputeEngineCredential = ComputeEngineCredential;\n/**\n * Implementation of Credential that gets access tokens from refresh tokens.\n */\nclass RefreshTokenCredential {\n    /**\n     * Creates a new RefreshTokenCredential from the given parameters.\n     *\n     * @param refreshTokenPathOrObject - Refresh token json object or path to a refresh token\n     *   (user credentials) json file.\n     * @param httpAgent - Optional http.Agent to use when calling the remote token server.\n     * @param implicit - An optinal boolean indicating whether this credential was implicitly\n     *   discovered from the environment, as opposed to being explicitly specified by the developer.\n     *\n     * @constructor\n     */\n    constructor(refreshTokenPathOrObject, httpAgent, implicit = false) {\n        this.httpAgent = httpAgent;\n        this.implicit = implicit;\n        this.refreshToken = (typeof refreshTokenPathOrObject === 'string') ?\n            RefreshToken.fromPath(refreshTokenPathOrObject)\n            : new RefreshToken(refreshTokenPathOrObject);\n        this.httpClient = new api_request_1.HttpClient();\n    }\n    getAccessToken() {\n        const postData = 'client_id=' + this.refreshToken.clientId + '&' +\n            'client_secret=' + this.refreshToken.clientSecret + '&' +\n            'refresh_token=' + this.refreshToken.refreshToken + '&' +\n            'grant_type=refresh_token';\n        const request = {\n            method: 'POST',\n            url: `https://${REFRESH_TOKEN_HOST}${REFRESH_TOKEN_PATH}`,\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            data: postData,\n            httpAgent: this.httpAgent,\n        };\n        return requestAccessToken(this.httpClient, request);\n    }\n}\nexports.RefreshTokenCredential = RefreshTokenCredential;\nclass RefreshToken {\n    /*\n     * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the\n     * data at the path is invalid.\n     */\n    static fromPath(filePath) {\n        try {\n            return new RefreshToken(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n        }\n        catch (error) {\n            // Throw a nicely formed error message if the file contents cannot be parsed\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\n        }\n    }\n    constructor(json) {\n        copyAttr(this, json, 'clientId', 'client_id');\n        copyAttr(this, json, 'clientSecret', 'client_secret');\n        copyAttr(this, json, 'refreshToken', 'refresh_token');\n        copyAttr(this, json, 'type', 'type');\n        let errorMessage;\n        if (!util.isNonEmptyString(this.clientId)) {\n            errorMessage = 'Refresh token must contain a \"client_id\" property.';\n        }\n        else if (!util.isNonEmptyString(this.clientSecret)) {\n            errorMessage = 'Refresh token must contain a \"client_secret\" property.';\n        }\n        else if (!util.isNonEmptyString(this.refreshToken)) {\n            errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\n        }\n        else if (!util.isNonEmptyString(this.type)) {\n            errorMessage = 'Refresh token must contain a \"type\" property.';\n        }\n        if (typeof errorMessage !== 'undefined') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n        }\n    }\n}\n/**\n * Implementation of Credential that uses impersonated service account.\n */\nclass ImpersonatedServiceAccountCredential {\n    /**\n     * Creates a new ImpersonatedServiceAccountCredential from the given parameters.\n     *\n     * @param impersonatedServiceAccountPathOrObject - Impersonated Service account json object or\n     * path to a service account json file.\n     * @param httpAgent - Optional http.Agent to use when calling the remote token server.\n     * @param implicit - An optional boolean indicating whether this credential was implicitly\n     *   discovered from the environment, as opposed to being explicitly specified by the developer.\n     *\n     * @constructor\n     */\n    constructor(impersonatedServiceAccountPathOrObject, httpAgent, implicit = false) {\n        this.httpAgent = httpAgent;\n        this.implicit = implicit;\n        this.impersonatedServiceAccount = (typeof impersonatedServiceAccountPathOrObject === 'string') ?\n            ImpersonatedServiceAccount.fromPath(impersonatedServiceAccountPathOrObject)\n            : new ImpersonatedServiceAccount(impersonatedServiceAccountPathOrObject);\n        this.httpClient = new api_request_1.HttpClient();\n    }\n    getAccessToken() {\n        const postData = 'client_id=' + this.impersonatedServiceAccount.clientId + '&' +\n            'client_secret=' + this.impersonatedServiceAccount.clientSecret + '&' +\n            'refresh_token=' + this.impersonatedServiceAccount.refreshToken + '&' +\n            'grant_type=refresh_token';\n        const request = {\n            method: 'POST',\n            url: `https://${REFRESH_TOKEN_HOST}${REFRESH_TOKEN_PATH}`,\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            data: postData,\n            httpAgent: this.httpAgent,\n        };\n        return requestAccessToken(this.httpClient, request);\n    }\n}\nexports.ImpersonatedServiceAccountCredential = ImpersonatedServiceAccountCredential;\n/**\n * A struct containing the properties necessary to use impersonated service account JSON credentials.\n */\nclass ImpersonatedServiceAccount {\n    /*\n     * Tries to load a ImpersonatedServiceAccount from a path. Throws if the path doesn't exist or the\n     * data at the path is invalid.\n     */\n    static fromPath(filePath) {\n        try {\n            return new ImpersonatedServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n        }\n        catch (error) {\n            // Throw a nicely formed error message if the file contents cannot be parsed\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse impersonated service account file: ' + error);\n        }\n    }\n    constructor(json) {\n        const sourceCredentials = json['source_credentials'];\n        if (sourceCredentials) {\n            copyAttr(this, sourceCredentials, 'clientId', 'client_id');\n            copyAttr(this, sourceCredentials, 'clientSecret', 'client_secret');\n            copyAttr(this, sourceCredentials, 'refreshToken', 'refresh_token');\n            copyAttr(this, sourceCredentials, 'type', 'type');\n        }\n        let errorMessage;\n        if (!util.isNonEmptyString(this.clientId)) {\n            errorMessage = 'Impersonated Service Account must contain a \"source_credentials.client_id\" property.';\n        }\n        else if (!util.isNonEmptyString(this.clientSecret)) {\n            errorMessage = 'Impersonated Service Account must contain a \"source_credentials.client_secret\" property.';\n        }\n        else if (!util.isNonEmptyString(this.refreshToken)) {\n            errorMessage = 'Impersonated Service Account must contain a \"source_credentials.refresh_token\" property.';\n        }\n        else if (!util.isNonEmptyString(this.type)) {\n            errorMessage = 'Impersonated Service Account must contain a \"source_credentials.type\" property.';\n        }\n        if (typeof errorMessage !== 'undefined') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n        }\n    }\n}\n/**\n * Checks if the given credential was loaded via the application default credentials mechanism. This\n * includes all ComputeEngineCredential instances, and the ServiceAccountCredential and RefreshTokenCredential\n * instances that were loaded from well-known files or environment variables, rather than being explicitly\n * instantiated.\n *\n * @param credential - The credential instance to check.\n */\nfunction isApplicationDefault(credential) {\n    return credential instanceof ComputeEngineCredential ||\n        (credential instanceof ServiceAccountCredential && credential.implicit) ||\n        (credential instanceof RefreshTokenCredential && credential.implicit) ||\n        (credential instanceof ImpersonatedServiceAccountCredential && credential.implicit);\n}\nexports.isApplicationDefault = isApplicationDefault;\nfunction getApplicationDefault(httpAgent) {\n    if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\n        return credentialFromFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, httpAgent, false);\n    }\n    // It is OK to not have this file. If it is present, it must be valid.\n    if (GCLOUD_CREDENTIAL_PATH) {\n        const credential = credentialFromFile(GCLOUD_CREDENTIAL_PATH, httpAgent, true);\n        if (credential)\n            return credential;\n    }\n    return new ComputeEngineCredential(httpAgent);\n}\nexports.getApplicationDefault = getApplicationDefault;\n/**\n * Copies the specified property from one object to another.\n *\n * If no property exists by the given \"key\", looks for a property identified by \"alt\", and copies it instead.\n * This can be used to implement behaviors such as \"copy property myKey or my_key\".\n *\n * @param to - Target object to copy the property into.\n * @param from - Source object to copy the property from.\n * @param key - Name of the property to copy.\n * @param alt - Alternative name of the property to copy.\n */\nfunction copyAttr(to, from, key, alt) {\n    const tmp = from[key] || from[alt];\n    if (typeof tmp !== 'undefined') {\n        to[key] = tmp;\n    }\n}\n/**\n * Obtain a new OAuth2 token by making a remote service call.\n */\nfunction requestAccessToken(client, request) {\n    return client.send(request).then((resp) => {\n        const json = resp.data;\n        if (!json.access_token || !json.expires_in) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Unexpected response while fetching access token: ${JSON.stringify(json)}`);\n        }\n        return json;\n    }).catch((err) => {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));\n    });\n}\n/**\n * Obtain a new OIDC token by making a remote service call.\n */\nfunction requestIDToken(client, request) {\n    return client.send(request).then((resp) => {\n        if (!resp.text) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Unexpected response while fetching id token: response.text is undefined');\n        }\n        return resp.text;\n    }).catch((err) => {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));\n    });\n}\n/**\n * Constructs a human-readable error message from the given Error.\n */\nfunction getErrorMessage(err) {\n    const detail = (err instanceof api_request_1.HttpError) ? getDetailFromResponse(err.response) : err.message;\n    return `Error fetching access token: ${detail}`;\n}\n/**\n * Extracts details from the given HTTP error response, and returns a human-readable description. If\n * the response is JSON-formatted, looks up the error and error_description fields sent by the\n * Google Auth servers. Otherwise returns the entire response payload as the error detail.\n */\nfunction getDetailFromResponse(response) {\n    if (response.isJson() && response.data.error) {\n        const json = response.data;\n        let detail = json.error;\n        if (json.error_description) {\n            detail += ' (' + json.error_description + ')';\n        }\n        return detail;\n    }\n    return response.text || 'Missing error payload';\n}\nfunction credentialFromFile(filePath, httpAgent, ignoreMissing) {\n    const credentialsFile = readCredentialFile(filePath, ignoreMissing);\n    if (typeof credentialsFile !== 'object' || credentialsFile === null) {\n        if (ignoreMissing) {\n            return null;\n        }\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object');\n    }\n    if (credentialsFile.type === 'service_account') {\n        return new ServiceAccountCredential(credentialsFile, httpAgent, true);\n    }\n    if (credentialsFile.type === 'authorized_user') {\n        return new RefreshTokenCredential(credentialsFile, httpAgent, true);\n    }\n    if (credentialsFile.type === 'impersonated_service_account') {\n        return new ImpersonatedServiceAccountCredential(credentialsFile, httpAgent, true);\n    }\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Invalid contents in the credentials file');\n}\nfunction readCredentialFile(filePath, ignoreMissing) {\n    let fileText;\n    try {\n        fileText = fs.readFileSync(filePath, 'utf8');\n    }\n    catch (error) {\n        if (ignoreMissing) {\n            return null;\n        }\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Failed to read credentials from file ${filePath}: ` + error);\n    }\n    try {\n        return JSON.parse(fileText);\n    }\n    catch (error) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object: ' + error);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}