{"ast":null,"code":"'use strict';\n\n// TODO:\n//  * support 1 nested multipart level\n//    (see second multipart example here:\n//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)\n//  * support limits.fieldNameSize\n//     -- this will require modifications to utils.parseParams\nconst {\n  Readable\n} = require('node:stream');\nconst {\n  inherits\n} = require('node:util');\nconst Dicer = require('../../deps/dicer/lib/Dicer');\nconst parseParams = require('../utils/parseParams');\nconst decodeText = require('../utils/decodeText');\nconst basename = require('../utils/basename');\nconst getLimit = require('../utils/getLimit');\nconst RE_BOUNDARY = /^boundary$/i;\nconst RE_FIELD = /^form-data$/i;\nconst RE_CHARSET = /^charset$/i;\nconst RE_FILENAME = /^filename$/i;\nconst RE_NAME = /^name$/i;\nMultipart.detect = /^multipart\\/form-data/i;\nfunction Multipart(boy, cfg) {\n  let i;\n  let len;\n  const self = this;\n  let boundary;\n  const limits = cfg.limits;\n  const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === 'application/octet-stream' || fileName !== undefined);\n  const parsedConType = cfg.parsedConType || [];\n  const defCharset = cfg.defCharset || 'utf8';\n  const preservePath = cfg.preservePath;\n  const fileOpts = {\n    highWaterMark: cfg.fileHwm\n  };\n  for (i = 0, len = parsedConType.length; i < len; ++i) {\n    if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {\n      boundary = parsedConType[i][1];\n      break;\n    }\n  }\n  function checkFinished() {\n    if (nends === 0 && finished && !boy._done) {\n      finished = false;\n      self.end();\n    }\n  }\n  if (typeof boundary !== 'string') {\n    throw new Error('Multipart: Boundary not found');\n  }\n  const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024);\n  const fileSizeLimit = getLimit(limits, 'fileSize', Infinity);\n  const filesLimit = getLimit(limits, 'files', Infinity);\n  const fieldsLimit = getLimit(limits, 'fields', Infinity);\n  const partsLimit = getLimit(limits, 'parts', Infinity);\n  const headerPairsLimit = getLimit(limits, 'headerPairs', 2000);\n  const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024);\n  let nfiles = 0;\n  let nfields = 0;\n  let nends = 0;\n  let curFile;\n  let curField;\n  let finished = false;\n  this._needDrain = false;\n  this._pause = false;\n  this._cb = undefined;\n  this._nparts = 0;\n  this._boy = boy;\n  const parserCfg = {\n    boundary,\n    maxHeaderPairs: headerPairsLimit,\n    maxHeaderSize: headerSizeLimit,\n    partHwm: fileOpts.highWaterMark,\n    highWaterMark: cfg.highWaterMark\n  };\n  this.parser = new Dicer(parserCfg);\n  this.parser.on('drain', function () {\n    self._needDrain = false;\n    if (self._cb && !self._pause) {\n      const cb = self._cb;\n      self._cb = undefined;\n      cb();\n    }\n  }).on('part', function onPart(part) {\n    if (++self._nparts > partsLimit) {\n      self.parser.removeListener('part', onPart);\n      self.parser.on('part', skipPart);\n      boy.hitPartsLimit = true;\n      boy.emit('partsLimit');\n      return skipPart(part);\n    }\n\n    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let\n    // us emit 'end' early since we know the part has ended if we are already\n    // seeing the next part\n    if (curField) {\n      const field = curField;\n      field.emit('end');\n      field.removeAllListeners('end');\n    }\n    part.on('header', function (header) {\n      let contype;\n      let fieldname;\n      let parsed;\n      let charset;\n      let encoding;\n      let filename;\n      let nsize = 0;\n      if (header['content-type']) {\n        parsed = parseParams(header['content-type'][0]);\n        if (parsed[0]) {\n          contype = parsed[0].toLowerCase();\n          for (i = 0, len = parsed.length; i < len; ++i) {\n            if (RE_CHARSET.test(parsed[i][0])) {\n              charset = parsed[i][1].toLowerCase();\n              break;\n            }\n          }\n        }\n      }\n      if (contype === undefined) {\n        contype = 'text/plain';\n      }\n      if (charset === undefined) {\n        charset = defCharset;\n      }\n      if (header['content-disposition']) {\n        parsed = parseParams(header['content-disposition'][0]);\n        if (!RE_FIELD.test(parsed[0])) {\n          return skipPart(part);\n        }\n        for (i = 0, len = parsed.length; i < len; ++i) {\n          if (RE_NAME.test(parsed[i][0])) {\n            fieldname = parsed[i][1];\n          } else if (RE_FILENAME.test(parsed[i][0])) {\n            filename = parsed[i][1];\n            if (!preservePath) {\n              filename = basename(filename);\n            }\n          }\n        }\n      } else {\n        return skipPart(part);\n      }\n      if (header['content-transfer-encoding']) {\n        encoding = header['content-transfer-encoding'][0].toLowerCase();\n      } else {\n        encoding = '7bit';\n      }\n      let onData, onEnd;\n      if (isPartAFile(fieldname, contype, filename)) {\n        // file/binary field\n        if (nfiles === filesLimit) {\n          if (!boy.hitFilesLimit) {\n            boy.hitFilesLimit = true;\n            boy.emit('filesLimit');\n          }\n          return skipPart(part);\n        }\n        ++nfiles;\n        if (boy.listenerCount('file') === 0) {\n          self.parser._ignore();\n          return;\n        }\n        ++nends;\n        const file = new FileStream(fileOpts);\n        curFile = file;\n        file.on('end', function () {\n          --nends;\n          self._pause = false;\n          checkFinished();\n          if (self._cb && !self._needDrain) {\n            const cb = self._cb;\n            self._cb = undefined;\n            cb();\n          }\n        });\n        file._read = function (n) {\n          if (!self._pause) {\n            return;\n          }\n          self._pause = false;\n          if (self._cb && !self._needDrain) {\n            const cb = self._cb;\n            self._cb = undefined;\n            cb();\n          }\n        };\n        boy.emit('file', fieldname, file, filename, encoding, contype);\n        onData = function (data) {\n          if ((nsize += data.length) > fileSizeLimit) {\n            const extralen = fileSizeLimit - nsize + data.length;\n            if (extralen > 0) {\n              file.push(data.slice(0, extralen));\n            }\n            file.truncated = true;\n            file.bytesRead = fileSizeLimit;\n            part.removeAllListeners('data');\n            file.emit('limit');\n            return;\n          } else if (!file.push(data)) {\n            self._pause = true;\n          }\n          file.bytesRead = nsize;\n        };\n        onEnd = function () {\n          curFile = undefined;\n          file.push(null);\n        };\n      } else {\n        // non-file field\n        if (nfields === fieldsLimit) {\n          if (!boy.hitFieldsLimit) {\n            boy.hitFieldsLimit = true;\n            boy.emit('fieldsLimit');\n          }\n          return skipPart(part);\n        }\n        ++nfields;\n        ++nends;\n        let buffer = '';\n        let truncated = false;\n        curField = part;\n        onData = function (data) {\n          if ((nsize += data.length) > fieldSizeLimit) {\n            const extralen = fieldSizeLimit - (nsize - data.length);\n            buffer += data.toString('binary', 0, extralen);\n            truncated = true;\n            part.removeAllListeners('data');\n          } else {\n            buffer += data.toString('binary');\n          }\n        };\n        onEnd = function () {\n          curField = undefined;\n          if (buffer.length) {\n            buffer = decodeText(buffer, 'binary', charset);\n          }\n          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);\n          --nends;\n          checkFinished();\n        };\n      }\n\n      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become\n         broken. Streams2/streams3 is a huge black box of confusion, but\n         somehow overriding the sync state seems to fix things again (and still\n         seems to work for previous node versions).\n      */\n      part._readableState.sync = false;\n      part.on('data', onData);\n      part.on('end', onEnd);\n    }).on('error', function (err) {\n      if (curFile) {\n        curFile.emit('error', err);\n      }\n    });\n  }).on('error', function (err) {\n    boy.emit('error', err);\n  }).on('finish', function () {\n    finished = true;\n    checkFinished();\n  });\n}\nMultipart.prototype.write = function (chunk, cb) {\n  const r = this.parser.write(chunk);\n  if (r && !this._pause) {\n    cb();\n  } else {\n    this._needDrain = !r;\n    this._cb = cb;\n  }\n};\nMultipart.prototype.end = function () {\n  const self = this;\n  if (self.parser.writable) {\n    self.parser.end();\n  } else if (!self._boy._done) {\n    process.nextTick(function () {\n      self._boy._done = true;\n      self._boy.emit('finish');\n    });\n  }\n};\nfunction skipPart(part) {\n  part.resume();\n}\nfunction FileStream(opts) {\n  Readable.call(this, opts);\n  this.bytesRead = 0;\n  this.truncated = false;\n}\ninherits(FileStream, Readable);\nFileStream.prototype._read = function (n) {};\nmodule.exports = Multipart;","map":{"version":3,"names":["Readable","require","inherits","Dicer","parseParams","decodeText","basename","getLimit","RE_BOUNDARY","RE_FIELD","RE_CHARSET","RE_FILENAME","RE_NAME","Multipart","detect","boy","cfg","i","len","self","boundary","limits","isPartAFile","fieldName","contentType","fileName","undefined","parsedConType","defCharset","preservePath","fileOpts","highWaterMark","fileHwm","length","Array","isArray","test","checkFinished","nends","finished","_done","end","Error","fieldSizeLimit","fileSizeLimit","Infinity","filesLimit","fieldsLimit","partsLimit","headerPairsLimit","headerSizeLimit","nfiles","nfields","curFile","curField","_needDrain","_pause","_cb","_nparts","_boy","parserCfg","maxHeaderPairs","maxHeaderSize","partHwm","parser","on","cb","onPart","part","removeListener","skipPart","hitPartsLimit","emit","field","removeAllListeners","header","contype","fieldname","parsed","charset","encoding","filename","nsize","toLowerCase","onData","onEnd","hitFilesLimit","listenerCount","_ignore","file","FileStream","_read","n","data","extralen","push","slice","truncated","bytesRead","hitFieldsLimit","buffer","toString","_readableState","sync","err","prototype","write","chunk","r","writable","process","nextTick","resume","opts","call","module","exports"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@fastify/busboy/lib/types/multipart.js"],"sourcesContent":["'use strict'\n\n// TODO:\n//  * support 1 nested multipart level\n//    (see second multipart example here:\n//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)\n//  * support limits.fieldNameSize\n//     -- this will require modifications to utils.parseParams\n\nconst { Readable } = require('node:stream')\nconst { inherits } = require('node:util')\n\nconst Dicer = require('../../deps/dicer/lib/Dicer')\n\nconst parseParams = require('../utils/parseParams')\nconst decodeText = require('../utils/decodeText')\nconst basename = require('../utils/basename')\nconst getLimit = require('../utils/getLimit')\n\nconst RE_BOUNDARY = /^boundary$/i\nconst RE_FIELD = /^form-data$/i\nconst RE_CHARSET = /^charset$/i\nconst RE_FILENAME = /^filename$/i\nconst RE_NAME = /^name$/i\n\nMultipart.detect = /^multipart\\/form-data/i\nfunction Multipart (boy, cfg) {\n  let i\n  let len\n  const self = this\n  let boundary\n  const limits = cfg.limits\n  const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => (contentType === 'application/octet-stream' || fileName !== undefined))\n  const parsedConType = cfg.parsedConType || []\n  const defCharset = cfg.defCharset || 'utf8'\n  const preservePath = cfg.preservePath\n  const fileOpts = { highWaterMark: cfg.fileHwm }\n\n  for (i = 0, len = parsedConType.length; i < len; ++i) {\n    if (Array.isArray(parsedConType[i]) &&\n      RE_BOUNDARY.test(parsedConType[i][0])) {\n      boundary = parsedConType[i][1]\n      break\n    }\n  }\n\n  function checkFinished () {\n    if (nends === 0 && finished && !boy._done) {\n      finished = false\n      self.end()\n    }\n  }\n\n  if (typeof boundary !== 'string') { throw new Error('Multipart: Boundary not found') }\n\n  const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024)\n  const fileSizeLimit = getLimit(limits, 'fileSize', Infinity)\n  const filesLimit = getLimit(limits, 'files', Infinity)\n  const fieldsLimit = getLimit(limits, 'fields', Infinity)\n  const partsLimit = getLimit(limits, 'parts', Infinity)\n  const headerPairsLimit = getLimit(limits, 'headerPairs', 2000)\n  const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024)\n\n  let nfiles = 0\n  let nfields = 0\n  let nends = 0\n  let curFile\n  let curField\n  let finished = false\n\n  this._needDrain = false\n  this._pause = false\n  this._cb = undefined\n  this._nparts = 0\n  this._boy = boy\n\n  const parserCfg = {\n    boundary,\n    maxHeaderPairs: headerPairsLimit,\n    maxHeaderSize: headerSizeLimit,\n    partHwm: fileOpts.highWaterMark,\n    highWaterMark: cfg.highWaterMark\n  }\n\n  this.parser = new Dicer(parserCfg)\n  this.parser.on('drain', function () {\n    self._needDrain = false\n    if (self._cb && !self._pause) {\n      const cb = self._cb\n      self._cb = undefined\n      cb()\n    }\n  }).on('part', function onPart (part) {\n    if (++self._nparts > partsLimit) {\n      self.parser.removeListener('part', onPart)\n      self.parser.on('part', skipPart)\n      boy.hitPartsLimit = true\n      boy.emit('partsLimit')\n      return skipPart(part)\n    }\n\n    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let\n    // us emit 'end' early since we know the part has ended if we are already\n    // seeing the next part\n    if (curField) {\n      const field = curField\n      field.emit('end')\n      field.removeAllListeners('end')\n    }\n\n    part.on('header', function (header) {\n      let contype\n      let fieldname\n      let parsed\n      let charset\n      let encoding\n      let filename\n      let nsize = 0\n\n      if (header['content-type']) {\n        parsed = parseParams(header['content-type'][0])\n        if (parsed[0]) {\n          contype = parsed[0].toLowerCase()\n          for (i = 0, len = parsed.length; i < len; ++i) {\n            if (RE_CHARSET.test(parsed[i][0])) {\n              charset = parsed[i][1].toLowerCase()\n              break\n            }\n          }\n        }\n      }\n\n      if (contype === undefined) { contype = 'text/plain' }\n      if (charset === undefined) { charset = defCharset }\n\n      if (header['content-disposition']) {\n        parsed = parseParams(header['content-disposition'][0])\n        if (!RE_FIELD.test(parsed[0])) { return skipPart(part) }\n        for (i = 0, len = parsed.length; i < len; ++i) {\n          if (RE_NAME.test(parsed[i][0])) {\n            fieldname = parsed[i][1]\n          } else if (RE_FILENAME.test(parsed[i][0])) {\n            filename = parsed[i][1]\n            if (!preservePath) { filename = basename(filename) }\n          }\n        }\n      } else { return skipPart(part) }\n\n      if (header['content-transfer-encoding']) { encoding = header['content-transfer-encoding'][0].toLowerCase() } else { encoding = '7bit' }\n\n      let onData,\n        onEnd\n\n      if (isPartAFile(fieldname, contype, filename)) {\n        // file/binary field\n        if (nfiles === filesLimit) {\n          if (!boy.hitFilesLimit) {\n            boy.hitFilesLimit = true\n            boy.emit('filesLimit')\n          }\n          return skipPart(part)\n        }\n\n        ++nfiles\n\n        if (boy.listenerCount('file') === 0) {\n          self.parser._ignore()\n          return\n        }\n\n        ++nends\n        const file = new FileStream(fileOpts)\n        curFile = file\n        file.on('end', function () {\n          --nends\n          self._pause = false\n          checkFinished()\n          if (self._cb && !self._needDrain) {\n            const cb = self._cb\n            self._cb = undefined\n            cb()\n          }\n        })\n        file._read = function (n) {\n          if (!self._pause) { return }\n          self._pause = false\n          if (self._cb && !self._needDrain) {\n            const cb = self._cb\n            self._cb = undefined\n            cb()\n          }\n        }\n        boy.emit('file', fieldname, file, filename, encoding, contype)\n\n        onData = function (data) {\n          if ((nsize += data.length) > fileSizeLimit) {\n            const extralen = fileSizeLimit - nsize + data.length\n            if (extralen > 0) { file.push(data.slice(0, extralen)) }\n            file.truncated = true\n            file.bytesRead = fileSizeLimit\n            part.removeAllListeners('data')\n            file.emit('limit')\n            return\n          } else if (!file.push(data)) { self._pause = true }\n\n          file.bytesRead = nsize\n        }\n\n        onEnd = function () {\n          curFile = undefined\n          file.push(null)\n        }\n      } else {\n        // non-file field\n        if (nfields === fieldsLimit) {\n          if (!boy.hitFieldsLimit) {\n            boy.hitFieldsLimit = true\n            boy.emit('fieldsLimit')\n          }\n          return skipPart(part)\n        }\n\n        ++nfields\n        ++nends\n        let buffer = ''\n        let truncated = false\n        curField = part\n\n        onData = function (data) {\n          if ((nsize += data.length) > fieldSizeLimit) {\n            const extralen = (fieldSizeLimit - (nsize - data.length))\n            buffer += data.toString('binary', 0, extralen)\n            truncated = true\n            part.removeAllListeners('data')\n          } else { buffer += data.toString('binary') }\n        }\n\n        onEnd = function () {\n          curField = undefined\n          if (buffer.length) { buffer = decodeText(buffer, 'binary', charset) }\n          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype)\n          --nends\n          checkFinished()\n        }\n      }\n\n      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become\n         broken. Streams2/streams3 is a huge black box of confusion, but\n         somehow overriding the sync state seems to fix things again (and still\n         seems to work for previous node versions).\n      */\n      part._readableState.sync = false\n\n      part.on('data', onData)\n      part.on('end', onEnd)\n    }).on('error', function (err) {\n      if (curFile) { curFile.emit('error', err) }\n    })\n  }).on('error', function (err) {\n    boy.emit('error', err)\n  }).on('finish', function () {\n    finished = true\n    checkFinished()\n  })\n}\n\nMultipart.prototype.write = function (chunk, cb) {\n  const r = this.parser.write(chunk)\n  if (r && !this._pause) {\n    cb()\n  } else {\n    this._needDrain = !r\n    this._cb = cb\n  }\n}\n\nMultipart.prototype.end = function () {\n  const self = this\n\n  if (self.parser.writable) {\n    self.parser.end()\n  } else if (!self._boy._done) {\n    process.nextTick(function () {\n      self._boy._done = true\n      self._boy.emit('finish')\n    })\n  }\n}\n\nfunction skipPart (part) {\n  part.resume()\n}\n\nfunction FileStream (opts) {\n  Readable.call(this, opts)\n\n  this.bytesRead = 0\n\n  this.truncated = false\n}\n\ninherits(FileStream, Readable)\n\nFileStream.prototype._read = function (n) {}\n\nmodule.exports = Multipart\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}