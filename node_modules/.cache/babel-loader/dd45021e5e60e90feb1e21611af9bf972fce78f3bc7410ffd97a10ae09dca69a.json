{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2023 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregateField = exports.Aggregate = void 0;\nconst path_1 = require(\"./path\");\nconst assert = require(\"assert\");\n/**\n * Concrete implementation of the Aggregate type.\n */\nclass Aggregate {\n  constructor(alias, aggregateType, fieldPath) {\n    this.alias = alias;\n    this.aggregateType = aggregateType;\n    this.fieldPath = fieldPath;\n  }\n  /**\n   * Converts this object to the proto representation of an Aggregate.\n   * @internal\n   */\n  toProto() {\n    const proto = {};\n    if (this.aggregateType === 'count') {\n      proto.count = {};\n    } else if (this.aggregateType === 'sum') {\n      assert(this.fieldPath !== undefined, 'Missing field path for sum aggregation.');\n      proto.sum = {\n        field: {\n          fieldPath: path_1.FieldPath.fromArgument(this.fieldPath).formattedName\n        }\n      };\n    } else if (this.aggregateType === 'avg') {\n      assert(this.fieldPath !== undefined, 'Missing field path for average aggregation.');\n      proto.avg = {\n        field: {\n          fieldPath: path_1.FieldPath.fromArgument(this.fieldPath).formattedName\n        }\n      };\n    } else {\n      throw new Error(`Aggregate type ${this.aggregateType} unimplemented.`);\n    }\n    proto.alias = this.alias;\n    return proto;\n  }\n}\nexports.Aggregate = Aggregate;\n/**\n * Represents an aggregation that can be performed by Firestore.\n */\nclass AggregateField {\n  /**\n   * Create a new AggregateField<T>\n   * @param aggregateType Specifies the type of aggregation operation to perform.\n   * @param field Optionally specifies the field that is aggregated.\n   * @internal\n   */\n  constructor(aggregateType, field) {\n    this.aggregateType = aggregateType;\n    /** A type string to uniquely identify instances of this class. */\n    this.type = 'AggregateField';\n    this._field = field;\n  }\n  /**\n   * Compares this object with the given object for equality.\n   *\n   * This object is considered \"equal\" to the other object if and only if\n   * `other` performs the same kind of aggregation on the same field (if any).\n   *\n   * @param other The object to compare to this object for equality.\n   * @return `true` if this object is \"equal\" to the given object, as\n   * defined above, or `false` otherwise.\n   */\n  isEqual(other) {\n    return other instanceof AggregateField && this.aggregateType === other.aggregateType && (this._field === undefined && other._field === undefined || this._field !== undefined && other._field !== undefined && path_1.FieldPath.fromArgument(this._field).isEqual(path_1.FieldPath.fromArgument(other._field)));\n  }\n  /**\n   * Create an AggregateField object that can be used to compute the count of\n   * documents in the result set of a query.\n   */\n  static count() {\n    return new AggregateField('count');\n  }\n  /**\n   * Create an AggregateField object that can be used to compute the average of\n   * a specified field over a range of documents in the result set of a query.\n   * @param field Specifies the field to average across the result set.\n   */\n  static average(field) {\n    return new AggregateField('avg', field);\n  }\n  /**\n   * Create an AggregateField object that can be used to compute the sum of\n   * a specified field over a range of documents in the result set of a query.\n   * @param field Specifies the field to sum across the result set.\n   */\n  static sum(field) {\n    return new AggregateField('sum', field);\n  }\n}\nexports.AggregateField = AggregateField;","map":{"version":3,"names":["Object","defineProperty","exports","value","AggregateField","Aggregate","path_1","require","assert","constructor","alias","aggregateType","fieldPath","toProto","proto","count","undefined","sum","field","FieldPath","fromArgument","formattedName","avg","Error","type","_field","isEqual","other","average"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@google-cloud/firestore/build/src/aggregate.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2023 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AggregateField = exports.Aggregate = void 0;\nconst path_1 = require(\"./path\");\nconst assert = require(\"assert\");\n/**\n * Concrete implementation of the Aggregate type.\n */\nclass Aggregate {\n    constructor(alias, aggregateType, fieldPath) {\n        this.alias = alias;\n        this.aggregateType = aggregateType;\n        this.fieldPath = fieldPath;\n    }\n    /**\n     * Converts this object to the proto representation of an Aggregate.\n     * @internal\n     */\n    toProto() {\n        const proto = {};\n        if (this.aggregateType === 'count') {\n            proto.count = {};\n        }\n        else if (this.aggregateType === 'sum') {\n            assert(this.fieldPath !== undefined, 'Missing field path for sum aggregation.');\n            proto.sum = {\n                field: {\n                    fieldPath: path_1.FieldPath.fromArgument(this.fieldPath).formattedName,\n                },\n            };\n        }\n        else if (this.aggregateType === 'avg') {\n            assert(this.fieldPath !== undefined, 'Missing field path for average aggregation.');\n            proto.avg = {\n                field: {\n                    fieldPath: path_1.FieldPath.fromArgument(this.fieldPath).formattedName,\n                },\n            };\n        }\n        else {\n            throw new Error(`Aggregate type ${this.aggregateType} unimplemented.`);\n        }\n        proto.alias = this.alias;\n        return proto;\n    }\n}\nexports.Aggregate = Aggregate;\n/**\n * Represents an aggregation that can be performed by Firestore.\n */\nclass AggregateField {\n    /**\n     * Create a new AggregateField<T>\n     * @param aggregateType Specifies the type of aggregation operation to perform.\n     * @param field Optionally specifies the field that is aggregated.\n     * @internal\n     */\n    constructor(aggregateType, field) {\n        this.aggregateType = aggregateType;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'AggregateField';\n        this._field = field;\n    }\n    /**\n     * Compares this object with the given object for equality.\n     *\n     * This object is considered \"equal\" to the other object if and only if\n     * `other` performs the same kind of aggregation on the same field (if any).\n     *\n     * @param other The object to compare to this object for equality.\n     * @return `true` if this object is \"equal\" to the given object, as\n     * defined above, or `false` otherwise.\n     */\n    isEqual(other) {\n        return (other instanceof AggregateField &&\n            this.aggregateType === other.aggregateType &&\n            ((this._field === undefined && other._field === undefined) ||\n                (this._field !== undefined &&\n                    other._field !== undefined &&\n                    path_1.FieldPath.fromArgument(this._field).isEqual(path_1.FieldPath.fromArgument(other._field)))));\n    }\n    /**\n     * Create an AggregateField object that can be used to compute the count of\n     * documents in the result set of a query.\n     */\n    static count() {\n        return new AggregateField('count');\n    }\n    /**\n     * Create an AggregateField object that can be used to compute the average of\n     * a specified field over a range of documents in the result set of a query.\n     * @param field Specifies the field to average across the result set.\n     */\n    static average(field) {\n        return new AggregateField('avg', field);\n    }\n    /**\n     * Create an AggregateField object that can be used to compute the sum of\n     * a specified field over a range of documents in the result set of a query.\n     * @param field Specifies the field to sum across the result set.\n     */\n    static sum(field) {\n        return new AggregateField('sum', field);\n    }\n}\nexports.AggregateField = AggregateField;\n//# sourceMappingURL=aggregate.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}