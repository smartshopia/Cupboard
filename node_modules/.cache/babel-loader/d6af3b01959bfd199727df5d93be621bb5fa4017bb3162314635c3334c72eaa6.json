{"ast":null,"code":"\"use strict\";\n\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BundleBuilder = void 0;\nconst document_1 = require(\"./document\");\nconst query_snapshot_1 = require(\"./reference/query-snapshot\");\nconst timestamp_1 = require(\"./timestamp\");\nconst validate_1 = require(\"./validate\");\nconst BUNDLE_VERSION = 1;\n/**\n * Builds a Firestore data bundle with results from the given document and query snapshots.\n */\nclass BundleBuilder {\n  constructor(bundleId) {\n    this.bundleId = bundleId;\n    // Resulting documents for the bundle, keyed by full document path.\n    this.documents = new Map();\n    // Named queries saved in the bundle, keyed by query name.\n    this.namedQueries = new Map();\n    // The latest read time among all bundled documents and queries.\n    this.latestReadTime = new timestamp_1.Timestamp(0, 0);\n  }\n  /**\n   * Adds a Firestore document snapshot or query snapshot to the bundle.\n   * Both the documents data and the query read time will be included in the bundle.\n   *\n   * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.\n   * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.\n   * @returns {BundleBuilder} This instance.\n   *\n   * @example\n   * ```\n   * const bundle = firestore.bundle('data-bundle');\n   * const docSnapshot = await firestore.doc('abc/123').get();\n   * const querySnapshot = await firestore.collection('coll').get();\n   *\n   * const bundleBuffer = bundle.add(docSnapshot) // Add a document\n   *                            .add('coll-query', querySnapshot) // Add a named query.\n   *                            .build()\n   * // Save `bundleBuffer` to CDN or stream it to clients.\n   * ```\n   */\n  add(documentOrName, querySnapshot) {\n    // eslint-disable-next-line prefer-rest-params\n    (0, validate_1.validateMinNumberOfArguments)('BundleBuilder.add', arguments, 1);\n    // eslint-disable-next-line prefer-rest-params\n    (0, validate_1.validateMaxNumberOfArguments)('BundleBuilder.add', arguments, 2);\n    if (arguments.length === 1) {\n      validateDocumentSnapshot('documentOrName', documentOrName);\n      this.addBundledDocument(documentOrName);\n    } else {\n      (0, validate_1.validateString)('documentOrName', documentOrName);\n      validateQuerySnapshot('querySnapshot', querySnapshot);\n      this.addNamedQuery(documentOrName, querySnapshot);\n    }\n    return this;\n  }\n  addBundledDocument(snap, queryName) {\n    const originalDocument = this.documents.get(snap.ref.path);\n    const originalQueries = originalDocument === null || originalDocument === void 0 ? void 0 : originalDocument.metadata.queries;\n    // Update with document built from `snap` because it is newer.\n    if (!originalDocument || timestamp_1.Timestamp.fromProto(originalDocument.metadata.readTime) < snap.readTime) {\n      const docProto = snap.toDocumentProto();\n      this.documents.set(snap.ref.path, {\n        document: snap.exists ? docProto : undefined,\n        metadata: {\n          name: docProto.name,\n          readTime: snap.readTime.toProto().timestampValue,\n          exists: snap.exists\n        }\n      });\n    }\n    // Update `queries` to include both original and `queryName`.\n    const newDocument = this.documents.get(snap.ref.path);\n    newDocument.metadata.queries = originalQueries || [];\n    if (queryName) {\n      newDocument.metadata.queries.push(queryName);\n    }\n    if (snap.readTime > this.latestReadTime) {\n      this.latestReadTime = snap.readTime;\n    }\n  }\n  addNamedQuery(name, querySnap) {\n    if (this.namedQueries.has(name)) {\n      throw new Error(`Query name conflict: ${name} has already been added.`);\n    }\n    this.namedQueries.set(name, {\n      name,\n      bundledQuery: querySnap.query._toBundledQuery(),\n      readTime: querySnap.readTime.toProto().timestampValue\n    });\n    for (const snap of querySnap.docs) {\n      this.addBundledDocument(snap, name);\n    }\n    if (querySnap.readTime > this.latestReadTime) {\n      this.latestReadTime = querySnap.readTime;\n    }\n  }\n  /**\n   * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\n   * of the element.\n   * @private\n   * @internal\n   */\n  elementToLengthPrefixedBuffer(bundleElement) {\n    // Convert to a valid proto message object then take its JSON representation.\n    // This take cares of stuff like converting internal byte array fields\n    // to Base64 encodings.\n    // We lazy-load the Proto file to reduce cold-start times.\n    const message = require('../protos/firestore_v1_proto_api').firestore.BundleElement.fromObject(bundleElement).toJSON();\n    const buffer = Buffer.from(JSON.stringify(message), 'utf-8');\n    const lengthBuffer = Buffer.from(buffer.length.toString());\n    return Buffer.concat([lengthBuffer, buffer]);\n  }\n  build() {\n    let bundleBuffer = Buffer.alloc(0);\n    for (const namedQuery of this.namedQueries.values()) {\n      bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n        namedQuery\n      })]);\n    }\n    for (const bundledDocument of this.documents.values()) {\n      const documentMetadata = bundledDocument.metadata;\n      bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n        documentMetadata\n      })]);\n      // Write to the bundle if document exists.\n      const document = bundledDocument.document;\n      if (document) {\n        bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n          document\n        })]);\n      }\n    }\n    const metadata = {\n      id: this.bundleId,\n      createTime: this.latestReadTime.toProto().timestampValue,\n      version: BUNDLE_VERSION,\n      totalDocuments: this.documents.size,\n      totalBytes: bundleBuffer.length\n    };\n    // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\n    bundleBuffer = Buffer.concat([this.elementToLengthPrefixedBuffer({\n      metadata\n    }), bundleBuffer]);\n    return bundleBuffer;\n  }\n}\nexports.BundleBuilder = BundleBuilder;\n/**\n * Convenient class to hold both the metadata and the actual content of a document to be bundled.\n * @private\n * @internal\n */\nclass BundledDocument {\n  constructor(metadata, document) {\n    this.metadata = metadata;\n    this.document = document;\n  }\n}\n/**\n * Validates that 'value' is DocumentSnapshot.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\nfunction validateDocumentSnapshot(arg, value) {\n  if (!(value instanceof document_1.DocumentSnapshot)) {\n    throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'DocumentSnapshot'));\n  }\n}\n/**\n * Validates that 'value' is QuerySnapshot.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\nfunction validateQuerySnapshot(arg, value) {\n  if (!(value instanceof query_snapshot_1.QuerySnapshot)) {\n    throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'QuerySnapshot'));\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","BundleBuilder","document_1","require","query_snapshot_1","timestamp_1","validate_1","BUNDLE_VERSION","constructor","bundleId","documents","Map","namedQueries","latestReadTime","Timestamp","add","documentOrName","querySnapshot","validateMinNumberOfArguments","arguments","validateMaxNumberOfArguments","length","validateDocumentSnapshot","addBundledDocument","validateString","validateQuerySnapshot","addNamedQuery","snap","queryName","originalDocument","get","ref","path","originalQueries","metadata","queries","fromProto","readTime","docProto","toDocumentProto","set","document","exists","undefined","name","toProto","timestampValue","newDocument","push","querySnap","has","Error","bundledQuery","query","_toBundledQuery","docs","elementToLengthPrefixedBuffer","bundleElement","message","firestore","BundleElement","fromObject","toJSON","buffer","Buffer","from","JSON","stringify","lengthBuffer","toString","concat","build","bundleBuffer","alloc","namedQuery","values","bundledDocument","documentMetadata","id","createTime","version","totalDocuments","size","totalBytes","BundledDocument","arg","DocumentSnapshot","invalidArgumentMessage","QuerySnapshot"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@google-cloud/firestore/build/src/bundle.js"],"sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BundleBuilder = void 0;\nconst document_1 = require(\"./document\");\nconst query_snapshot_1 = require(\"./reference/query-snapshot\");\nconst timestamp_1 = require(\"./timestamp\");\nconst validate_1 = require(\"./validate\");\nconst BUNDLE_VERSION = 1;\n/**\n * Builds a Firestore data bundle with results from the given document and query snapshots.\n */\nclass BundleBuilder {\n    constructor(bundleId) {\n        this.bundleId = bundleId;\n        // Resulting documents for the bundle, keyed by full document path.\n        this.documents = new Map();\n        // Named queries saved in the bundle, keyed by query name.\n        this.namedQueries = new Map();\n        // The latest read time among all bundled documents and queries.\n        this.latestReadTime = new timestamp_1.Timestamp(0, 0);\n    }\n    /**\n     * Adds a Firestore document snapshot or query snapshot to the bundle.\n     * Both the documents data and the query read time will be included in the bundle.\n     *\n     * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.\n     * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.\n     * @returns {BundleBuilder} This instance.\n     *\n     * @example\n     * ```\n     * const bundle = firestore.bundle('data-bundle');\n     * const docSnapshot = await firestore.doc('abc/123').get();\n     * const querySnapshot = await firestore.collection('coll').get();\n     *\n     * const bundleBuffer = bundle.add(docSnapshot) // Add a document\n     *                            .add('coll-query', querySnapshot) // Add a named query.\n     *                            .build()\n     * // Save `bundleBuffer` to CDN or stream it to clients.\n     * ```\n     */\n    add(documentOrName, querySnapshot) {\n        // eslint-disable-next-line prefer-rest-params\n        (0, validate_1.validateMinNumberOfArguments)('BundleBuilder.add', arguments, 1);\n        // eslint-disable-next-line prefer-rest-params\n        (0, validate_1.validateMaxNumberOfArguments)('BundleBuilder.add', arguments, 2);\n        if (arguments.length === 1) {\n            validateDocumentSnapshot('documentOrName', documentOrName);\n            this.addBundledDocument(documentOrName);\n        }\n        else {\n            (0, validate_1.validateString)('documentOrName', documentOrName);\n            validateQuerySnapshot('querySnapshot', querySnapshot);\n            this.addNamedQuery(documentOrName, querySnapshot);\n        }\n        return this;\n    }\n    addBundledDocument(snap, queryName) {\n        const originalDocument = this.documents.get(snap.ref.path);\n        const originalQueries = originalDocument === null || originalDocument === void 0 ? void 0 : originalDocument.metadata.queries;\n        // Update with document built from `snap` because it is newer.\n        if (!originalDocument ||\n            timestamp_1.Timestamp.fromProto(originalDocument.metadata.readTime) < snap.readTime) {\n            const docProto = snap.toDocumentProto();\n            this.documents.set(snap.ref.path, {\n                document: snap.exists ? docProto : undefined,\n                metadata: {\n                    name: docProto.name,\n                    readTime: snap.readTime.toProto().timestampValue,\n                    exists: snap.exists,\n                },\n            });\n        }\n        // Update `queries` to include both original and `queryName`.\n        const newDocument = this.documents.get(snap.ref.path);\n        newDocument.metadata.queries = originalQueries || [];\n        if (queryName) {\n            newDocument.metadata.queries.push(queryName);\n        }\n        if (snap.readTime > this.latestReadTime) {\n            this.latestReadTime = snap.readTime;\n        }\n    }\n    addNamedQuery(name, querySnap) {\n        if (this.namedQueries.has(name)) {\n            throw new Error(`Query name conflict: ${name} has already been added.`);\n        }\n        this.namedQueries.set(name, {\n            name,\n            bundledQuery: querySnap.query._toBundledQuery(),\n            readTime: querySnap.readTime.toProto().timestampValue,\n        });\n        for (const snap of querySnap.docs) {\n            this.addBundledDocument(snap, name);\n        }\n        if (querySnap.readTime > this.latestReadTime) {\n            this.latestReadTime = querySnap.readTime;\n        }\n    }\n    /**\n     * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\n     * of the element.\n     * @private\n     * @internal\n     */\n    elementToLengthPrefixedBuffer(bundleElement) {\n        // Convert to a valid proto message object then take its JSON representation.\n        // This take cares of stuff like converting internal byte array fields\n        // to Base64 encodings.\n        // We lazy-load the Proto file to reduce cold-start times.\n        const message = require('../protos/firestore_v1_proto_api')\n            .firestore.BundleElement.fromObject(bundleElement)\n            .toJSON();\n        const buffer = Buffer.from(JSON.stringify(message), 'utf-8');\n        const lengthBuffer = Buffer.from(buffer.length.toString());\n        return Buffer.concat([lengthBuffer, buffer]);\n    }\n    build() {\n        let bundleBuffer = Buffer.alloc(0);\n        for (const namedQuery of this.namedQueries.values()) {\n            bundleBuffer = Buffer.concat([\n                bundleBuffer,\n                this.elementToLengthPrefixedBuffer({ namedQuery }),\n            ]);\n        }\n        for (const bundledDocument of this.documents.values()) {\n            const documentMetadata = bundledDocument.metadata;\n            bundleBuffer = Buffer.concat([\n                bundleBuffer,\n                this.elementToLengthPrefixedBuffer({ documentMetadata }),\n            ]);\n            // Write to the bundle if document exists.\n            const document = bundledDocument.document;\n            if (document) {\n                bundleBuffer = Buffer.concat([\n                    bundleBuffer,\n                    this.elementToLengthPrefixedBuffer({ document }),\n                ]);\n            }\n        }\n        const metadata = {\n            id: this.bundleId,\n            createTime: this.latestReadTime.toProto().timestampValue,\n            version: BUNDLE_VERSION,\n            totalDocuments: this.documents.size,\n            totalBytes: bundleBuffer.length,\n        };\n        // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\n        bundleBuffer = Buffer.concat([\n            this.elementToLengthPrefixedBuffer({ metadata }),\n            bundleBuffer,\n        ]);\n        return bundleBuffer;\n    }\n}\nexports.BundleBuilder = BundleBuilder;\n/**\n * Convenient class to hold both the metadata and the actual content of a document to be bundled.\n * @private\n * @internal\n */\nclass BundledDocument {\n    constructor(metadata, document) {\n        this.metadata = metadata;\n        this.document = document;\n    }\n}\n/**\n * Validates that 'value' is DocumentSnapshot.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\nfunction validateDocumentSnapshot(arg, value) {\n    if (!(value instanceof document_1.DocumentSnapshot)) {\n        throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'DocumentSnapshot'));\n    }\n}\n/**\n * Validates that 'value' is QuerySnapshot.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\nfunction validateQuerySnapshot(arg, value) {\n    if (!(value instanceof query_snapshot_1.QuerySnapshot)) {\n        throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'QuerySnapshot'));\n    }\n}\n//# sourceMappingURL=bundle.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}