{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Precondition = exports.DocumentTransform = exports.DocumentMask = exports.QueryDocumentSnapshot = exports.DocumentSnapshot = exports.DocumentSnapshotBuilder = void 0;\nconst deepEqual = require(\"fast-deep-equal\");\nconst assert = require(\"assert\");\nconst field_value_1 = require(\"./field-value\");\nconst path_1 = require(\"./path\");\nconst document_reference_1 = require(\"./reference/document-reference\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\n/**\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\n * Invoke `.build()' to assemble the final snapshot.\n *\n * @private\n * @internal\n */\nclass DocumentSnapshotBuilder {\n  // We include the DocumentReference in the constructor in order to allow the\n  // DocumentSnapshotBuilder to be typed with <AppModelType, DbModelType> when\n  // it is constructed.\n  constructor(ref) {\n    this.ref = ref;\n  }\n  /**\n   * Builds the DocumentSnapshot.\n   *\n   * @private\n   * @internal\n   * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\n   * provided) or a DocumentSnapshot.\n   */\n  build() {\n    assert(this.fieldsProto !== undefined === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n    assert(this.fieldsProto !== undefined === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n    return this.fieldsProto ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime) : new DocumentSnapshot(this.ref, undefined, this.readTime);\n  }\n}\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\n * A DocumentSnapshot is an immutable representation for a document in a\n * Firestore database. The data can be extracted with\n * [data()]{@link DocumentSnapshot#data} or\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\n * specific field.\n *\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\n * access will return 'undefined'. You can use the\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\n * document's existence.\n *\n * @class DocumentSnapshot\n */\nclass DocumentSnapshot {\n  /**\n   * @private\n   * @internal\n   *\n   * @param ref The reference to the document.\n   * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing\n   * this document (or undefined if the document does not exist).\n   * @param readTime The time when this snapshot was read  (or undefined if\n   * the document exists only locally).\n   * @param createTime The time when the document was created (or undefined if\n   * the document does not exist).\n   * @param updateTime The time when the document was last updated (or undefined\n   * if the document does not exist).\n   */\n  constructor(ref,\n  /**\n   * @internal\n   * @private\n   **/\n  _fieldsProto, readTime, createTime, updateTime) {\n    this._fieldsProto = _fieldsProto;\n    this._ref = ref;\n    this._serializer = ref.firestore._serializer;\n    this._readTime = readTime;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n  }\n  /**\n   * Creates a DocumentSnapshot from an object.\n   *\n   * @private\n   * @internal\n   * @param ref The reference to the document.\n   * @param obj The object to store in the DocumentSnapshot.\n   * @return The created DocumentSnapshot.\n   */\n  static fromObject(ref, obj) {\n    const serializer = ref.firestore._serializer;\n    return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n  }\n  /**\n   * Creates a DocumentSnapshot from an UpdateMap.\n   *\n   * This methods expands the top-level field paths in a JavaScript map and\n   * turns { foo.bar : foobar } into { foo { bar : foobar }}\n   *\n   * @private\n   * @internal\n   * @param ref The reference to the document.\n   * @param data The field/value map to expand.\n   * @return The created DocumentSnapshot.\n   */\n  static fromUpdateMap(ref, data) {\n    const serializer = ref.firestore._serializer;\n    /**\n     * Merges 'value' at the field path specified by the path array into\n     * 'target'.\n     */\n    function merge(target, value, path, pos) {\n      const key = path[pos];\n      const isLast = pos === path.length - 1;\n      if (target[key] === undefined) {\n        if (isLast) {\n          if (value instanceof field_value_1.FieldTransform) {\n            // If there is already data at this path, we need to retain it.\n            // Otherwise, we don't include it in the DocumentSnapshot.\n            return !(0, util_1.isEmpty)(target) ? target : null;\n          }\n          // The merge is done.\n          const leafNode = serializer.encodeValue(value);\n          if (leafNode) {\n            target[key] = leafNode;\n          }\n          return target;\n        } else {\n          // We need to expand the target object.\n          const childNode = {\n            mapValue: {\n              fields: {}\n            }\n          };\n          const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n          if (nestedValue) {\n            childNode.mapValue.fields = nestedValue;\n            target[key] = childNode;\n            return target;\n          } else {\n            return !(0, util_1.isEmpty)(target) ? target : null;\n          }\n        }\n      } else {\n        assert(!isLast, \"Can't merge current value into a nested object\");\n        target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n        return target;\n      }\n    }\n    const res = {};\n    for (const [key, value] of data) {\n      const path = key.toArray();\n      merge(res, value, path, 0);\n    }\n    return new DocumentSnapshot(ref, res);\n  }\n  /**\n   * True if the document exists.\n   *\n   * @type {boolean}\n   * @name DocumentSnapshot#exists\n   * @readonly\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then((documentSnapshot) => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\n   *   }\n   * });\n   * ```\n   */\n  get exists() {\n    return this._fieldsProto !== undefined;\n  }\n  /**\n   * A [DocumentReference]{@link DocumentReference} for the document\n   * stored in this snapshot.\n   *\n   * @type {DocumentReference}\n   * @name DocumentSnapshot#ref\n   * @readonly\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then((documentSnapshot) => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\n   *   }\n   * });\n   * ```\n   */\n  get ref() {\n    return this._ref;\n  }\n  /**\n   * The ID of the document for which this DocumentSnapshot contains data.\n   *\n   * @type {string}\n   * @name DocumentSnapshot#id\n   * @readonly\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then((documentSnapshot) => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(`Document found with name '${documentSnapshot.id}'`);\n   *   }\n   * });\n   * ```\n   */\n  get id() {\n    return this._ref.id;\n  }\n  /**\n   * The time the document was created. Undefined for documents that don't\n   * exist.\n   *\n   * @type {Timestamp|undefined}\n   * @name DocumentSnapshot#createTime\n   * @readonly\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     let createTime = documentSnapshot.createTime;\n   *     console.log(`Document created at '${createTime.toDate()}'`);\n   *   }\n   * });\n   * ```\n   */\n  get createTime() {\n    return this._createTime;\n  }\n  /**\n   * The time the document was last updated (at the time the snapshot was\n   * generated). Undefined for documents that don't exist.\n   *\n   * @type {Timestamp|undefined}\n   * @name DocumentSnapshot#updateTime\n   * @readonly\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     let updateTime = documentSnapshot.updateTime;\n   *     console.log(`Document updated at '${updateTime.toDate()}'`);\n   *   }\n   * });\n   * ```\n   */\n  get updateTime() {\n    return this._updateTime;\n  }\n  /**\n   * The time this snapshot was read.\n   *\n   * @type {Timestamp}\n   * @name DocumentSnapshot#readTime\n   * @readonly\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   let readTime = documentSnapshot.readTime;\n   *   console.log(`Document read at '${readTime.toDate()}'`);\n   * });\n   * ```\n   */\n  get readTime() {\n    if (this._readTime === undefined) {\n      throw new Error(\"Called 'readTime' on a local document\");\n    }\n    return this._readTime;\n  }\n  /**\n   * Retrieves all fields in the document as an object. Returns 'undefined' if\n   * the document doesn't exist.\n   *\n   * @returns {T|undefined} An object containing all fields in the document or\n   * 'undefined' if the document doesn't exist.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   let data = documentSnapshot.data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   * ```\n   */\n  data() {\n    const fields = this._fieldsProto;\n    if (fields === undefined) {\n      return undefined;\n    }\n    // We only want to use the converter and create a new QueryDocumentSnapshot\n    // if a converter has been provided.\n    if (this.ref._converter !== (0, types_1.defaultConverter)()) {\n      const untypedReference = new document_reference_1.DocumentReference(this.ref.firestore, this.ref._path);\n      return this.ref._converter.fromFirestore(new QueryDocumentSnapshot(untypedReference, this._fieldsProto, this.readTime, this.createTime, this.updateTime));\n    } else {\n      const obj = {};\n      for (const prop of Object.keys(fields)) {\n        obj[prop] = this._serializer.decodeValue(fields[prop]);\n      }\n      return obj;\n    }\n  }\n  /**\n   * Retrieves the field specified by `field`.\n   *\n   * @param {string|FieldPath} field The field path\n   * (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns {*} The data at the specified field location or undefined if no\n   * such field exists.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({ a: { b: 'c' }}).then(() => {\n   *   return documentRef.get();\n   * }).then(documentSnapshot => {\n   *   let field = documentSnapshot.get('a.b');\n   *   console.log(`Retrieved field value: ${field}`);\n   * });\n   * ```\n   */\n  // We deliberately use `any` in the external API to not impose type-checking\n  // on end users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(field) {\n    (0, path_1.validateFieldPath)('field', field);\n    const protoField = this.protoField(field);\n    if (protoField === undefined) {\n      return undefined;\n    }\n    return this._serializer.decodeValue(protoField);\n  }\n  /**\n   * Retrieves the field specified by 'fieldPath' in its Protobuf JS\n   * representation.\n   *\n   * @private\n   * @internal\n   * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns The Protobuf-encoded data at the specified field location or\n   * undefined if no such field exists.\n   */\n  protoField(field) {\n    let fields = this._fieldsProto;\n    if (fields === undefined) {\n      return undefined;\n    }\n    const components = path_1.FieldPath.fromArgument(field).toArray();\n    while (components.length > 1) {\n      fields = fields[components.shift()];\n      if (!fields || !fields.mapValue) {\n        return undefined;\n      }\n      fields = fields.mapValue.fields;\n    }\n    return fields[components[0]];\n  }\n  /**\n   * Convert a document snapshot to the Firestore 'Write' proto.\n   *\n   * @private\n   * @internal\n   */\n  toWriteProto() {\n    return {\n      update: {\n        name: this._ref.formattedName,\n        fields: this._fieldsProto\n      }\n    };\n  }\n  /**\n   * Convert a document snapshot to the Firestore 'Document' proto.\n   *\n   * @private\n   * @internal\n   */\n  toDocumentProto() {\n    var _a, _b;\n    return {\n      name: this._ref.formattedName,\n      createTime: (_a = this.createTime) === null || _a === void 0 ? void 0 : _a.toProto().timestampValue,\n      updateTime: (_b = this.updateTime) === null || _b === void 0 ? void 0 : _b.toProto().timestampValue,\n      fields: this._fieldsProto\n    };\n  }\n  /**\n   * Returns true if the document's data and path in this `DocumentSnapshot` is\n   * equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\n   * value.\n   */\n  isEqual(other) {\n    // Since the read time is different on every document read, we explicitly\n    // ignore all document metadata in this comparison.\n    return this === other || other instanceof DocumentSnapshot && this._ref.isEqual(other._ref) && deepEqual(this._fieldsProto, other._fieldsProto);\n  }\n}\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\n * A QueryDocumentSnapshot contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\n *\n * A QueryDocumentSnapshot offers the same API surface as a\n * {@link DocumentSnapshot}. Since query results contain only existing\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\n * return 'undefined'.\n *\n * @class QueryDocumentSnapshot\n * @extends DocumentSnapshot\n */\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n  /**\n   * The time the document was created.\n   *\n   * @type {Timestamp}\n   * @name QueryDocumentSnapshot#createTime\n   * @readonly\n   * @override\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(snapshot => {\n   *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\n   * });\n   * ```\n   */\n  get createTime() {\n    return super.createTime;\n  }\n  /**\n   * The time the document was last updated (at the time the snapshot was\n   * generated).\n   *\n   * @type {Timestamp}\n   * @name QueryDocumentSnapshot#updateTime\n   * @readonly\n   * @override\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(snapshot => {\n   *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\n   * });\n   * ```\n   */\n  get updateTime() {\n    return super.updateTime;\n  }\n  /**\n   * Retrieves all fields in the document as an object.\n   *\n   * @override\n   *\n   * @returns {T} An object containing all fields in the document.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(documentSnapshot => {\n   *   let data = documentSnapshot.data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   * ```\n   */\n  data() {\n    const data = super.data();\n    if (!data) {\n      throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n    }\n    return data;\n  }\n}\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\n * A Firestore Document Mask contains the field paths affected by an update.\n *\n * @class\n * @private\n * @internal\n */\nclass DocumentMask {\n  /**\n   * @private\n   * @internal\n   * @private\n   *\n   * @param fieldPaths The field paths in this mask.\n   */\n  constructor(fieldPaths) {\n    this._sortedPaths = fieldPaths;\n    this._sortedPaths.sort((a, b) => a.compareTo(b));\n  }\n  /**\n   * Creates a document mask with the field paths of a document.\n   *\n   * @private\n   * @internal\n   * @param data A map with fields to modify. Only the keys are used to extract\n   * the document mask.\n   */\n  static fromUpdateMap(data) {\n    const fieldPaths = [];\n    data.forEach((value, key) => {\n      if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n        fieldPaths.push(path_1.FieldPath.fromArgument(key));\n      }\n    });\n    return new DocumentMask(fieldPaths);\n  }\n  /**\n   * Creates a document mask from an array of field paths.\n   *\n   * @private\n   * @internal\n   * @param fieldMask A list of field paths.\n   */\n  static fromFieldMask(fieldMask) {\n    const fieldPaths = [];\n    for (const fieldPath of fieldMask) {\n      fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n    }\n    return new DocumentMask(fieldPaths);\n  }\n  /**\n   * Creates a document mask with the field names of a document.\n   *\n   * @private\n   * @internal\n   * @param data An object with fields to modify. Only the keys are used to\n   * extract the document mask.\n   */\n  static fromObject(data) {\n    const fieldPaths = [];\n    function extractFieldPaths(currentData, currentPath) {\n      let isEmpty = true;\n      for (const key of Object.keys(currentData)) {\n        isEmpty = false;\n        // We don't split on dots since fromObject is called with\n        // DocumentData.\n        const childSegment = new path_1.FieldPath(key);\n        const childPath = currentPath ? currentPath.append(childSegment) : childSegment;\n        const value = currentData[key];\n        if (value instanceof field_value_1.FieldTransform) {\n          if (value.includeInDocumentMask) {\n            fieldPaths.push(childPath);\n          }\n        } else if ((0, util_1.isPlainObject)(value)) {\n          extractFieldPaths(value, childPath);\n        } else if (value !== undefined) {\n          // If the value is undefined it can never participate in the document\n          // mask. With `ignoreUndefinedProperties` set to false,\n          // `validateDocumentData` will reject an undefined value before even\n          // computing the document mask.\n          fieldPaths.push(childPath);\n        }\n      }\n      // Add a field path for an explicitly updated empty map.\n      if (currentPath && isEmpty) {\n        fieldPaths.push(currentPath);\n      }\n    }\n    extractFieldPaths(data);\n    return new DocumentMask(fieldPaths);\n  }\n  /**\n   * Returns true if this document mask contains no fields.\n   *\n   * @private\n   * @internal\n   * @return {boolean} Whether this document mask is empty.\n   */\n  get isEmpty() {\n    return this._sortedPaths.length === 0;\n  }\n  /**\n   * Removes the specified values from a sorted field path array.\n   *\n   * @private\n   * @internal\n   * @param input A sorted array of FieldPaths.\n   * @param values An array of FieldPaths to remove.\n   */\n  static removeFromSortedArray(input, values) {\n    for (let i = 0; i < input.length;) {\n      let removed = false;\n      for (const fieldPath of values) {\n        if (input[i].isEqual(fieldPath)) {\n          input.splice(i, 1);\n          removed = true;\n          break;\n        }\n      }\n      if (!removed) {\n        ++i;\n      }\n    }\n  }\n  /**\n   * Removes the field path specified in 'fieldPaths' from this document mask.\n   *\n   * @private\n   * @internal\n   * @param fieldPaths An array of FieldPaths.\n   */\n  removeFields(fieldPaths) {\n    DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n  }\n  /**\n   * Returns whether this document mask contains 'fieldPath'.\n   *\n   * @private\n   * @internal\n   * @param fieldPath The field path to test.\n   * @return Whether this document mask contains 'fieldPath'.\n   */\n  contains(fieldPath) {\n    for (const sortedPath of this._sortedPaths) {\n      const cmp = sortedPath.compareTo(fieldPath);\n      if (cmp === 0) {\n        return true;\n      } else if (cmp > 0) {\n        return false;\n      }\n    }\n    return false;\n  }\n  /**\n   * Removes all properties from 'data' that are not contained in this document\n   * mask.\n   *\n   * @private\n   * @internal\n   * @param data An object to filter.\n   * @return A shallow copy of the object filtered by this document mask.\n   */\n  applyTo(data) {\n    /*!\n     * Applies this DocumentMask to 'data' and computes the list of field paths\n     * that were specified in the mask but are not present in 'data'.\n     */\n    const applyDocumentMask = data => {\n      const remainingPaths = this._sortedPaths.slice(0);\n      const processObject = (currentData, currentPath) => {\n        let result = null;\n        Object.keys(currentData).forEach(key => {\n          const childPath = currentPath ? currentPath.append(key) : new path_1.FieldPath(key);\n          if (this.contains(childPath)) {\n            DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n            result = result || {};\n            result[key] = currentData[key];\n          } else if ((0, util_1.isObject)(currentData[key])) {\n            const childObject = processObject(currentData[key], childPath);\n            if (childObject) {\n              result = result || {};\n              result[key] = childObject;\n            }\n          }\n        });\n        return result;\n      };\n      // processObject() returns 'null' if the DocumentMask is empty.\n      const filteredData = processObject(data) || {};\n      return {\n        filteredData,\n        remainingPaths\n      };\n    };\n    const result = applyDocumentMask(data);\n    if (result.remainingPaths.length !== 0) {\n      throw new Error(`Input data is missing for field \"${result.remainingPaths[0]}\".`);\n    }\n    return result.filteredData;\n  }\n  /**\n   * Converts a document mask to the Firestore 'DocumentMask' Proto.\n   *\n   * @private\n   * @internal\n   * @returns A Firestore 'DocumentMask' Proto.\n   */\n  toProto() {\n    if (this.isEmpty) {\n      return {};\n    }\n    const encodedPaths = [];\n    for (const fieldPath of this._sortedPaths) {\n      encodedPaths.push(fieldPath.formattedName);\n    }\n    return {\n      fieldPaths: encodedPaths\n    };\n  }\n}\nexports.DocumentMask = DocumentMask;\n/**\n * A Firestore Document Transform.\n *\n * A DocumentTransform contains pending server-side transforms and their\n * corresponding field paths.\n *\n * @private\n * @internal\n * @class\n */\nclass DocumentTransform {\n  /**\n   * @private\n   * @internal\n   * @private\n   *\n   * @param ref The DocumentReference for this transform.\n   * @param transforms A Map of FieldPaths to FieldTransforms.\n   */\n  constructor(ref, transforms) {\n    this.ref = ref;\n    this.transforms = transforms;\n  }\n  /**\n   * Generates a DocumentTransform from a JavaScript object.\n   *\n   * @private\n   * @internal\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\n   * @param obj The object to extract the transformations from.\n   * @returns The Document Transform.\n   */\n  static fromObject(ref, obj) {\n    const updateMap = new Map();\n    for (const prop of Object.keys(obj)) {\n      updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n    }\n    return DocumentTransform.fromUpdateMap(ref, updateMap);\n  }\n  /**\n   * Generates a DocumentTransform from an Update Map.\n   *\n   * @private\n   * @internal\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\n   * @param data The update data to extract the transformations from.\n   * @returns The Document Transform.\n   */\n  static fromUpdateMap(ref, data) {\n    const transforms = new Map();\n    function encode_(val, path, allowTransforms) {\n      if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n        if (allowTransforms) {\n          transforms.set(path, val);\n        } else {\n          throw new Error(`${val.methodName}() is not supported inside of array values.`);\n        }\n      } else if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; ++i) {\n          // We need to verify that no array value contains a document transform\n          encode_(val[i], path.append(String(i)), false);\n        }\n      } else if ((0, util_1.isPlainObject)(val)) {\n        for (const prop of Object.keys(val)) {\n          encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n        }\n      }\n    }\n    data.forEach((value, key) => {\n      encode_(value, path_1.FieldPath.fromArgument(key), true);\n    });\n    return new DocumentTransform(ref, transforms);\n  }\n  /**\n   * Whether this DocumentTransform contains any actionable transformations.\n   *\n   * @private\n   * @internal\n   */\n  get isEmpty() {\n    return this.transforms.size === 0;\n  }\n  /**\n   * Returns the array of fields in this DocumentTransform.\n   *\n   * @private\n   * @internal\n   */\n  get fields() {\n    return Array.from(this.transforms.keys());\n  }\n  /**\n   * Validates the user provided field values in this document transform.\n   * @private\n   * @internal\n   */\n  validate() {\n    const allowUndefined = !!this.ref.firestore._settings.ignoreUndefinedProperties;\n    this.transforms.forEach(transform => transform.validate(allowUndefined));\n  }\n  /**\n   * Converts a document transform to the Firestore 'FieldTransform' Proto.\n   *\n   * @private\n   * @internal\n   * @param serializer The Firestore serializer\n   * @returns A list of Firestore 'FieldTransform' Protos\n   */\n  toProto(serializer) {\n    return Array.from(this.transforms, ([path, transform]) => transform.toProto(serializer, path));\n  }\n}\nexports.DocumentTransform = DocumentTransform;\n/**\n * A Firestore Precondition encapsulates options for database writes.\n *\n * @private\n * @internal\n * @class\n */\nclass Precondition {\n  /**\n   * @private\n   * @internal\n   * @private\n   *\n   * @param options.exists - Whether the referenced document should exist in\n   * Firestore,\n   * @param options.lastUpdateTime - The last update time of the referenced\n   * document in Firestore.\n   * @param options\n   */\n  constructor(options) {\n    if (options !== undefined) {\n      this._exists = options.exists;\n      this._lastUpdateTime = options.lastUpdateTime;\n    }\n  }\n  /**\n   * Generates the Protobuf `Preconditon` object for this precondition.\n   *\n   * @private\n   * @internal\n   * @returns The `Preconditon` Protobuf object or 'null' if there are no\n   * preconditions.\n   */\n  toProto() {\n    if (this.isEmpty) {\n      return null;\n    }\n    const proto = {};\n    if (this._lastUpdateTime !== undefined) {\n      proto.updateTime = this._lastUpdateTime.toProto().timestampValue;\n    } else {\n      proto.exists = this._exists;\n    }\n    return proto;\n  }\n  /**\n   * Whether this DocumentTransform contains any enforcement.\n   *\n   * @private\n   * @internal\n   */\n  get isEmpty() {\n    return this._exists === undefined && !this._lastUpdateTime;\n  }\n}\nexports.Precondition = Precondition;","map":{"version":3,"names":["Object","defineProperty","exports","value","Precondition","DocumentTransform","DocumentMask","QueryDocumentSnapshot","DocumentSnapshot","DocumentSnapshotBuilder","deepEqual","require","assert","field_value_1","path_1","document_reference_1","types_1","util_1","constructor","ref","build","fieldsProto","undefined","createTime","updateTime","readTime","_fieldsProto","_ref","_serializer","firestore","_readTime","_createTime","_updateTime","fromObject","obj","serializer","encodeFields","fromUpdateMap","data","merge","target","path","pos","key","isLast","length","FieldTransform","isEmpty","leafNode","encodeValue","childNode","mapValue","fields","nestedValue","res","toArray","exists","id","Error","_converter","defaultConverter","untypedReference","DocumentReference","_path","fromFirestore","prop","keys","decodeValue","get","field","validateFieldPath","protoField","components","FieldPath","fromArgument","shift","toWriteProto","update","name","formattedName","toDocumentProto","_a","_b","toProto","timestampValue","isEqual","other","fieldPaths","_sortedPaths","sort","a","b","compareTo","forEach","includeInDocumentMask","push","fromFieldMask","fieldMask","fieldPath","extractFieldPaths","currentData","currentPath","childSegment","childPath","append","isPlainObject","removeFromSortedArray","input","values","i","removed","splice","removeFields","contains","sortedPath","cmp","applyTo","applyDocumentMask","remainingPaths","slice","processObject","result","isObject","childObject","filteredData","encodedPaths","transforms","updateMap","Map","set","encode_","val","allowTransforms","includeInDocumentTransform","methodName","Array","isArray","String","size","from","validate","allowUndefined","_settings","ignoreUndefinedProperties","transform","options","_exists","_lastUpdateTime","lastUpdateTime","proto"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/@google-cloud/firestore/build/src/document.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Precondition = exports.DocumentTransform = exports.DocumentMask = exports.QueryDocumentSnapshot = exports.DocumentSnapshot = exports.DocumentSnapshotBuilder = void 0;\nconst deepEqual = require(\"fast-deep-equal\");\nconst assert = require(\"assert\");\nconst field_value_1 = require(\"./field-value\");\nconst path_1 = require(\"./path\");\nconst document_reference_1 = require(\"./reference/document-reference\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\n/**\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\n * Invoke `.build()' to assemble the final snapshot.\n *\n * @private\n * @internal\n */\nclass DocumentSnapshotBuilder {\n    // We include the DocumentReference in the constructor in order to allow the\n    // DocumentSnapshotBuilder to be typed with <AppModelType, DbModelType> when\n    // it is constructed.\n    constructor(ref) {\n        this.ref = ref;\n    }\n    /**\n     * Builds the DocumentSnapshot.\n     *\n     * @private\n     * @internal\n     * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\n     * provided) or a DocumentSnapshot.\n     */\n    build() {\n        assert((this.fieldsProto !== undefined) === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n        assert((this.fieldsProto !== undefined) === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n        return this.fieldsProto\n            ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime)\n            : new DocumentSnapshot(this.ref, undefined, this.readTime);\n    }\n}\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\n * A DocumentSnapshot is an immutable representation for a document in a\n * Firestore database. The data can be extracted with\n * [data()]{@link DocumentSnapshot#data} or\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\n * specific field.\n *\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\n * access will return 'undefined'. You can use the\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\n * document's existence.\n *\n * @class DocumentSnapshot\n */\nclass DocumentSnapshot {\n    /**\n     * @private\n     * @internal\n     *\n     * @param ref The reference to the document.\n     * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing\n     * this document (or undefined if the document does not exist).\n     * @param readTime The time when this snapshot was read  (or undefined if\n     * the document exists only locally).\n     * @param createTime The time when the document was created (or undefined if\n     * the document does not exist).\n     * @param updateTime The time when the document was last updated (or undefined\n     * if the document does not exist).\n     */\n    constructor(ref, \n    /**\n     * @internal\n     * @private\n     **/\n    _fieldsProto, readTime, createTime, updateTime) {\n        this._fieldsProto = _fieldsProto;\n        this._ref = ref;\n        this._serializer = ref.firestore._serializer;\n        this._readTime = readTime;\n        this._createTime = createTime;\n        this._updateTime = updateTime;\n    }\n    /**\n     * Creates a DocumentSnapshot from an object.\n     *\n     * @private\n     * @internal\n     * @param ref The reference to the document.\n     * @param obj The object to store in the DocumentSnapshot.\n     * @return The created DocumentSnapshot.\n     */\n    static fromObject(ref, obj) {\n        const serializer = ref.firestore._serializer;\n        return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n    }\n    /**\n     * Creates a DocumentSnapshot from an UpdateMap.\n     *\n     * This methods expands the top-level field paths in a JavaScript map and\n     * turns { foo.bar : foobar } into { foo { bar : foobar }}\n     *\n     * @private\n     * @internal\n     * @param ref The reference to the document.\n     * @param data The field/value map to expand.\n     * @return The created DocumentSnapshot.\n     */\n    static fromUpdateMap(ref, data) {\n        const serializer = ref\n            .firestore._serializer;\n        /**\n         * Merges 'value' at the field path specified by the path array into\n         * 'target'.\n         */\n        function merge(target, value, path, pos) {\n            const key = path[pos];\n            const isLast = pos === path.length - 1;\n            if (target[key] === undefined) {\n                if (isLast) {\n                    if (value instanceof field_value_1.FieldTransform) {\n                        // If there is already data at this path, we need to retain it.\n                        // Otherwise, we don't include it in the DocumentSnapshot.\n                        return !(0, util_1.isEmpty)(target) ? target : null;\n                    }\n                    // The merge is done.\n                    const leafNode = serializer.encodeValue(value);\n                    if (leafNode) {\n                        target[key] = leafNode;\n                    }\n                    return target;\n                }\n                else {\n                    // We need to expand the target object.\n                    const childNode = {\n                        mapValue: {\n                            fields: {},\n                        },\n                    };\n                    const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n                    if (nestedValue) {\n                        childNode.mapValue.fields = nestedValue;\n                        target[key] = childNode;\n                        return target;\n                    }\n                    else {\n                        return !(0, util_1.isEmpty)(target) ? target : null;\n                    }\n                }\n            }\n            else {\n                assert(!isLast, \"Can't merge current value into a nested object\");\n                target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n                return target;\n            }\n        }\n        const res = {};\n        for (const [key, value] of data) {\n            const path = key.toArray();\n            merge(res, value, path, 0);\n        }\n        return new DocumentSnapshot(ref, res);\n    }\n    /**\n     * True if the document exists.\n     *\n     * @type {boolean}\n     * @name DocumentSnapshot#exists\n     * @readonly\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\n     *   }\n     * });\n     * ```\n     */\n    get exists() {\n        return this._fieldsProto !== undefined;\n    }\n    /**\n     * A [DocumentReference]{@link DocumentReference} for the document\n     * stored in this snapshot.\n     *\n     * @type {DocumentReference}\n     * @name DocumentSnapshot#ref\n     * @readonly\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\n     *   }\n     * });\n     * ```\n     */\n    get ref() {\n        return this._ref;\n    }\n    /**\n     * The ID of the document for which this DocumentSnapshot contains data.\n     *\n     * @type {string}\n     * @name DocumentSnapshot#id\n     * @readonly\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Document found with name '${documentSnapshot.id}'`);\n     *   }\n     * });\n     * ```\n     */\n    get id() {\n        return this._ref.id;\n    }\n    /**\n     * The time the document was created. Undefined for documents that don't\n     * exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#createTime\n     * @readonly\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let createTime = documentSnapshot.createTime;\n     *     console.log(`Document created at '${createTime.toDate()}'`);\n     *   }\n     * });\n     * ```\n     */\n    get createTime() {\n        return this._createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated). Undefined for documents that don't exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#updateTime\n     * @readonly\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let updateTime = documentSnapshot.updateTime;\n     *     console.log(`Document updated at '${updateTime.toDate()}'`);\n     *   }\n     * });\n     * ```\n     */\n    get updateTime() {\n        return this._updateTime;\n    }\n    /**\n     * The time this snapshot was read.\n     *\n     * @type {Timestamp}\n     * @name DocumentSnapshot#readTime\n     * @readonly\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let readTime = documentSnapshot.readTime;\n     *   console.log(`Document read at '${readTime.toDate()}'`);\n     * });\n     * ```\n     */\n    get readTime() {\n        if (this._readTime === undefined) {\n            throw new Error(\"Called 'readTime' on a local document\");\n        }\n        return this._readTime;\n    }\n    /**\n     * Retrieves all fields in the document as an object. Returns 'undefined' if\n     * the document doesn't exist.\n     *\n     * @returns {T|undefined} An object containing all fields in the document or\n     * 'undefined' if the document doesn't exist.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     * ```\n     */\n    data() {\n        const fields = this._fieldsProto;\n        if (fields === undefined) {\n            return undefined;\n        }\n        // We only want to use the converter and create a new QueryDocumentSnapshot\n        // if a converter has been provided.\n        if (this.ref._converter !== (0, types_1.defaultConverter)()) {\n            const untypedReference = new document_reference_1.DocumentReference(this.ref.firestore, this.ref._path);\n            return this.ref._converter.fromFirestore(new QueryDocumentSnapshot(untypedReference, this._fieldsProto, this.readTime, this.createTime, this.updateTime));\n        }\n        else {\n            const obj = {};\n            for (const prop of Object.keys(fields)) {\n                obj[prop] = this._serializer.decodeValue(fields[prop]);\n            }\n            return obj;\n        }\n    }\n    /**\n     * Retrieves the field specified by `field`.\n     *\n     * @param {string|FieldPath} field The field path\n     * (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns {*} The data at the specified field location or undefined if no\n     * such field exists.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ a: { b: 'c' }}).then(() => {\n     *   return documentRef.get();\n     * }).then(documentSnapshot => {\n     *   let field = documentSnapshot.get('a.b');\n     *   console.log(`Retrieved field value: ${field}`);\n     * });\n     * ```\n     */\n    // We deliberately use `any` in the external API to not impose type-checking\n    // on end users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(field) {\n        (0, path_1.validateFieldPath)('field', field);\n        const protoField = this.protoField(field);\n        if (protoField === undefined) {\n            return undefined;\n        }\n        return this._serializer.decodeValue(protoField);\n    }\n    /**\n     * Retrieves the field specified by 'fieldPath' in its Protobuf JS\n     * representation.\n     *\n     * @private\n     * @internal\n     * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns The Protobuf-encoded data at the specified field location or\n     * undefined if no such field exists.\n     */\n    protoField(field) {\n        let fields = this._fieldsProto;\n        if (fields === undefined) {\n            return undefined;\n        }\n        const components = path_1.FieldPath.fromArgument(field).toArray();\n        while (components.length > 1) {\n            fields = fields[components.shift()];\n            if (!fields || !fields.mapValue) {\n                return undefined;\n            }\n            fields = fields.mapValue.fields;\n        }\n        return fields[components[0]];\n    }\n    /**\n     * Convert a document snapshot to the Firestore 'Write' proto.\n     *\n     * @private\n     * @internal\n     */\n    toWriteProto() {\n        return {\n            update: {\n                name: this._ref.formattedName,\n                fields: this._fieldsProto,\n            },\n        };\n    }\n    /**\n     * Convert a document snapshot to the Firestore 'Document' proto.\n     *\n     * @private\n     * @internal\n     */\n    toDocumentProto() {\n        var _a, _b;\n        return {\n            name: this._ref.formattedName,\n            createTime: (_a = this.createTime) === null || _a === void 0 ? void 0 : _a.toProto().timestampValue,\n            updateTime: (_b = this.updateTime) === null || _b === void 0 ? void 0 : _b.toProto().timestampValue,\n            fields: this._fieldsProto,\n        };\n    }\n    /**\n     * Returns true if the document's data and path in this `DocumentSnapshot` is\n     * equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        // Since the read time is different on every document read, we explicitly\n        // ignore all document metadata in this comparison.\n        return (this === other ||\n            (other instanceof DocumentSnapshot &&\n                this._ref.isEqual(other._ref) &&\n                deepEqual(this._fieldsProto, other._fieldsProto)));\n    }\n}\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\n * A QueryDocumentSnapshot contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\n *\n * A QueryDocumentSnapshot offers the same API surface as a\n * {@link DocumentSnapshot}. Since query results contain only existing\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\n * return 'undefined'.\n *\n * @class QueryDocumentSnapshot\n * @extends DocumentSnapshot\n */\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n    /**\n     * The time the document was created.\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#createTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\n     * });\n     * ```\n     */\n    get createTime() {\n        return super.createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated).\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#updateTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\n     * });\n     * ```\n     */\n    get updateTime() {\n        return super.updateTime;\n    }\n    /**\n     * Retrieves all fields in the document as an object.\n     *\n     * @override\n     *\n     * @returns {T} An object containing all fields in the document.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     * ```\n     */\n    data() {\n        const data = super.data();\n        if (!data) {\n            throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n        }\n        return data;\n    }\n}\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\n * A Firestore Document Mask contains the field paths affected by an update.\n *\n * @class\n * @private\n * @internal\n */\nclass DocumentMask {\n    /**\n     * @private\n     * @internal\n     * @private\n     *\n     * @param fieldPaths The field paths in this mask.\n     */\n    constructor(fieldPaths) {\n        this._sortedPaths = fieldPaths;\n        this._sortedPaths.sort((a, b) => a.compareTo(b));\n    }\n    /**\n     * Creates a document mask with the field paths of a document.\n     *\n     * @private\n     * @internal\n     * @param data A map with fields to modify. Only the keys are used to extract\n     * the document mask.\n     */\n    static fromUpdateMap(data) {\n        const fieldPaths = [];\n        data.forEach((value, key) => {\n            if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n                fieldPaths.push(path_1.FieldPath.fromArgument(key));\n            }\n        });\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask from an array of field paths.\n     *\n     * @private\n     * @internal\n     * @param fieldMask A list of field paths.\n     */\n    static fromFieldMask(fieldMask) {\n        const fieldPaths = [];\n        for (const fieldPath of fieldMask) {\n            fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n        }\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask with the field names of a document.\n     *\n     * @private\n     * @internal\n     * @param data An object with fields to modify. Only the keys are used to\n     * extract the document mask.\n     */\n    static fromObject(data) {\n        const fieldPaths = [];\n        function extractFieldPaths(currentData, currentPath) {\n            let isEmpty = true;\n            for (const key of Object.keys(currentData)) {\n                isEmpty = false;\n                // We don't split on dots since fromObject is called with\n                // DocumentData.\n                const childSegment = new path_1.FieldPath(key);\n                const childPath = currentPath\n                    ? currentPath.append(childSegment)\n                    : childSegment;\n                const value = currentData[key];\n                if (value instanceof field_value_1.FieldTransform) {\n                    if (value.includeInDocumentMask) {\n                        fieldPaths.push(childPath);\n                    }\n                }\n                else if ((0, util_1.isPlainObject)(value)) {\n                    extractFieldPaths(value, childPath);\n                }\n                else if (value !== undefined) {\n                    // If the value is undefined it can never participate in the document\n                    // mask. With `ignoreUndefinedProperties` set to false,\n                    // `validateDocumentData` will reject an undefined value before even\n                    // computing the document mask.\n                    fieldPaths.push(childPath);\n                }\n            }\n            // Add a field path for an explicitly updated empty map.\n            if (currentPath && isEmpty) {\n                fieldPaths.push(currentPath);\n            }\n        }\n        extractFieldPaths(data);\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Returns true if this document mask contains no fields.\n     *\n     * @private\n     * @internal\n     * @return {boolean} Whether this document mask is empty.\n     */\n    get isEmpty() {\n        return this._sortedPaths.length === 0;\n    }\n    /**\n     * Removes the specified values from a sorted field path array.\n     *\n     * @private\n     * @internal\n     * @param input A sorted array of FieldPaths.\n     * @param values An array of FieldPaths to remove.\n     */\n    static removeFromSortedArray(input, values) {\n        for (let i = 0; i < input.length;) {\n            let removed = false;\n            for (const fieldPath of values) {\n                if (input[i].isEqual(fieldPath)) {\n                    input.splice(i, 1);\n                    removed = true;\n                    break;\n                }\n            }\n            if (!removed) {\n                ++i;\n            }\n        }\n    }\n    /**\n     * Removes the field path specified in 'fieldPaths' from this document mask.\n     *\n     * @private\n     * @internal\n     * @param fieldPaths An array of FieldPaths.\n     */\n    removeFields(fieldPaths) {\n        DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n    }\n    /**\n     * Returns whether this document mask contains 'fieldPath'.\n     *\n     * @private\n     * @internal\n     * @param fieldPath The field path to test.\n     * @return Whether this document mask contains 'fieldPath'.\n     */\n    contains(fieldPath) {\n        for (const sortedPath of this._sortedPaths) {\n            const cmp = sortedPath.compareTo(fieldPath);\n            if (cmp === 0) {\n                return true;\n            }\n            else if (cmp > 0) {\n                return false;\n            }\n        }\n        return false;\n    }\n    /**\n     * Removes all properties from 'data' that are not contained in this document\n     * mask.\n     *\n     * @private\n     * @internal\n     * @param data An object to filter.\n     * @return A shallow copy of the object filtered by this document mask.\n     */\n    applyTo(data) {\n        /*!\n         * Applies this DocumentMask to 'data' and computes the list of field paths\n         * that were specified in the mask but are not present in 'data'.\n         */\n        const applyDocumentMask = data => {\n            const remainingPaths = this._sortedPaths.slice(0);\n            const processObject = (currentData, currentPath) => {\n                let result = null;\n                Object.keys(currentData).forEach(key => {\n                    const childPath = currentPath\n                        ? currentPath.append(key)\n                        : new path_1.FieldPath(key);\n                    if (this.contains(childPath)) {\n                        DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n                        result = result || {};\n                        result[key] = currentData[key];\n                    }\n                    else if ((0, util_1.isObject)(currentData[key])) {\n                        const childObject = processObject(currentData[key], childPath);\n                        if (childObject) {\n                            result = result || {};\n                            result[key] = childObject;\n                        }\n                    }\n                });\n                return result;\n            };\n            // processObject() returns 'null' if the DocumentMask is empty.\n            const filteredData = processObject(data) || {};\n            return {\n                filteredData,\n                remainingPaths,\n            };\n        };\n        const result = applyDocumentMask(data);\n        if (result.remainingPaths.length !== 0) {\n            throw new Error(`Input data is missing for field \"${result.remainingPaths[0]}\".`);\n        }\n        return result.filteredData;\n    }\n    /**\n     * Converts a document mask to the Firestore 'DocumentMask' Proto.\n     *\n     * @private\n     * @internal\n     * @returns A Firestore 'DocumentMask' Proto.\n     */\n    toProto() {\n        if (this.isEmpty) {\n            return {};\n        }\n        const encodedPaths = [];\n        for (const fieldPath of this._sortedPaths) {\n            encodedPaths.push(fieldPath.formattedName);\n        }\n        return {\n            fieldPaths: encodedPaths,\n        };\n    }\n}\nexports.DocumentMask = DocumentMask;\n/**\n * A Firestore Document Transform.\n *\n * A DocumentTransform contains pending server-side transforms and their\n * corresponding field paths.\n *\n * @private\n * @internal\n * @class\n */\nclass DocumentTransform {\n    /**\n     * @private\n     * @internal\n     * @private\n     *\n     * @param ref The DocumentReference for this transform.\n     * @param transforms A Map of FieldPaths to FieldTransforms.\n     */\n    constructor(ref, transforms) {\n        this.ref = ref;\n        this.transforms = transforms;\n    }\n    /**\n     * Generates a DocumentTransform from a JavaScript object.\n     *\n     * @private\n     * @internal\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param obj The object to extract the transformations from.\n     * @returns The Document Transform.\n     */\n    static fromObject(ref, obj) {\n        const updateMap = new Map();\n        for (const prop of Object.keys(obj)) {\n            updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n        }\n        return DocumentTransform.fromUpdateMap(ref, updateMap);\n    }\n    /**\n     * Generates a DocumentTransform from an Update Map.\n     *\n     * @private\n     * @internal\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param data The update data to extract the transformations from.\n     * @returns The Document Transform.\n     */\n    static fromUpdateMap(ref, data) {\n        const transforms = new Map();\n        function encode_(val, path, allowTransforms) {\n            if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n                if (allowTransforms) {\n                    transforms.set(path, val);\n                }\n                else {\n                    throw new Error(`${val.methodName}() is not supported inside of array values.`);\n                }\n            }\n            else if (Array.isArray(val)) {\n                for (let i = 0; i < val.length; ++i) {\n                    // We need to verify that no array value contains a document transform\n                    encode_(val[i], path.append(String(i)), false);\n                }\n            }\n            else if ((0, util_1.isPlainObject)(val)) {\n                for (const prop of Object.keys(val)) {\n                    encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n                }\n            }\n        }\n        data.forEach((value, key) => {\n            encode_(value, path_1.FieldPath.fromArgument(key), true);\n        });\n        return new DocumentTransform(ref, transforms);\n    }\n    /**\n     * Whether this DocumentTransform contains any actionable transformations.\n     *\n     * @private\n     * @internal\n     */\n    get isEmpty() {\n        return this.transforms.size === 0;\n    }\n    /**\n     * Returns the array of fields in this DocumentTransform.\n     *\n     * @private\n     * @internal\n     */\n    get fields() {\n        return Array.from(this.transforms.keys());\n    }\n    /**\n     * Validates the user provided field values in this document transform.\n     * @private\n     * @internal\n     */\n    validate() {\n        const allowUndefined = !!this.ref.firestore._settings.ignoreUndefinedProperties;\n        this.transforms.forEach(transform => transform.validate(allowUndefined));\n    }\n    /**\n     * Converts a document transform to the Firestore 'FieldTransform' Proto.\n     *\n     * @private\n     * @internal\n     * @param serializer The Firestore serializer\n     * @returns A list of Firestore 'FieldTransform' Protos\n     */\n    toProto(serializer) {\n        return Array.from(this.transforms, ([path, transform]) => transform.toProto(serializer, path));\n    }\n}\nexports.DocumentTransform = DocumentTransform;\n/**\n * A Firestore Precondition encapsulates options for database writes.\n *\n * @private\n * @internal\n * @class\n */\nclass Precondition {\n    /**\n     * @private\n     * @internal\n     * @private\n     *\n     * @param options.exists - Whether the referenced document should exist in\n     * Firestore,\n     * @param options.lastUpdateTime - The last update time of the referenced\n     * document in Firestore.\n     * @param options\n     */\n    constructor(options) {\n        if (options !== undefined) {\n            this._exists = options.exists;\n            this._lastUpdateTime = options.lastUpdateTime;\n        }\n    }\n    /**\n     * Generates the Protobuf `Preconditon` object for this precondition.\n     *\n     * @private\n     * @internal\n     * @returns The `Preconditon` Protobuf object or 'null' if there are no\n     * preconditions.\n     */\n    toProto() {\n        if (this.isEmpty) {\n            return null;\n        }\n        const proto = {};\n        if (this._lastUpdateTime !== undefined) {\n            proto.updateTime = this._lastUpdateTime.toProto().timestampValue;\n        }\n        else {\n            proto.exists = this._exists;\n        }\n        return proto;\n    }\n    /**\n     * Whether this DocumentTransform contains any enforcement.\n     *\n     * @private\n     * @internal\n     */\n    get isEmpty() {\n        return this._exists === undefined && !this._lastUpdateTime;\n    }\n}\nexports.Precondition = Precondition;\n//# sourceMappingURL=document.js.map"],"mappings":"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sC,IAAI,EAAE,CAAC,CAAC;IAC9B;IACA,OAAO,IAAIjC,gBAAgB,CAACW,GAAG,EAAEmC,GAAG,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIE,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC9B,YAAY,KAAKJ,SAAS;EAC1C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIH,GAAGA,CAAA,EAAG;IACN,OAAO,IAAI,CAACQ,IAAI;EACpB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI8B,EAAEA,CAAA,EAAG;IACL,OAAO,IAAI,CAAC9B,IAAI,CAAC8B,EAAE;EACvB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIlC,UAAUA,CAAA,EAAG;IACb,OAAO,IAAI,CAACQ,WAAW;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIP,UAAUA,CAAA,EAAG;IACb,OAAO,IAAI,CAACQ,WAAW;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIP,QAAQA,CAAA,EAAG;IACX,IAAI,IAAI,CAACK,SAAS,KAAKR,SAAS,EAAE;MAC9B,MAAM,IAAIoC,KAAK,CAAC,uCAAuC,CAAC;IAC5D;IACA,OAAO,IAAI,CAAC5B,SAAS;EACzB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIQ,IAAIA,CAAA,EAAG;IACH,MAAMc,MAAM,GAAG,IAAI,CAAC1B,YAAY;IAChC,IAAI0B,MAAM,KAAK9B,SAAS,EAAE;MACtB,OAAOA,SAAS;IACpB;IACA;IACA;IACA,IAAI,IAAI,CAACH,GAAG,CAACwC,UAAU,KAAK,CAAC,CAAC,EAAE3C,OAAO,CAAC4C,gBAAgB,EAAE,CAAC,EAAE;MACzD,MAAMC,gBAAgB,GAAG,IAAI9C,oBAAoB,CAAC+C,iBAAiB,CAAC,IAAI,CAAC3C,GAAG,CAACU,SAAS,EAAE,IAAI,CAACV,GAAG,CAAC4C,KAAK,CAAC;MACvG,OAAO,IAAI,CAAC5C,GAAG,CAACwC,UAAU,CAACK,aAAa,CAAC,IAAIzD,qBAAqB,CAACsD,gBAAgB,EAAE,IAAI,CAACnC,YAAY,EAAE,IAAI,CAACD,QAAQ,EAAE,IAAI,CAACF,UAAU,EAAE,IAAI,CAACC,UAAU,CAAC,CAAC;IAC7J,CAAC,MACI;MACD,MAAMU,GAAG,GAAG,CAAC,CAAC;MACd,KAAK,MAAM+B,IAAI,IAAIjE,MAAM,CAACkE,IAAI,CAACd,MAAM,CAAC,EAAE;QACpClB,GAAG,CAAC+B,IAAI,CAAC,GAAG,IAAI,CAACrC,WAAW,CAACuC,WAAW,CAACf,MAAM,CAACa,IAAI,CAAC,CAAC;MAC1D;MACA,OAAO/B,GAAG;IACd;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;EACA;EACA;EACAkC,GAAGA,CAACC,KAAK,EAAE;IACP,CAAC,CAAC,EAAEvD,MAAM,CAACwD,iBAAiB,EAAE,OAAO,EAAED,KAAK,CAAC;IAC7C,MAAME,UAAU,GAAG,IAAI,CAACA,UAAU,CAACF,KAAK,CAAC;IACzC,IAAIE,UAAU,KAAKjD,SAAS,EAAE;MAC1B,OAAOA,SAAS;IACpB;IACA,OAAO,IAAI,CAACM,WAAW,CAACuC,WAAW,CAACI,UAAU,CAAC;EACnD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIA,UAAUA,CAACF,KAAK,EAAE;IACd,IAAIjB,MAAM,GAAG,IAAI,CAAC1B,YAAY;IAC9B,IAAI0B,MAAM,KAAK9B,SAAS,EAAE;MACtB,OAAOA,SAAS;IACpB;IACA,MAAMkD,UAAU,GAAG1D,MAAM,CAAC2D,SAAS,CAACC,YAAY,CAACL,KAAK,CAAC,CAACd,OAAO,CAAC,CAAC;IACjE,OAAOiB,UAAU,CAAC3B,MAAM,GAAG,CAAC,EAAE;MAC1BO,MAAM,GAAGA,MAAM,CAACoB,UAAU,CAACG,KAAK,CAAC,CAAC,CAAC;MACnC,IAAI,CAACvB,MAAM,IAAI,CAACA,MAAM,CAACD,QAAQ,EAAE;QAC7B,OAAO7B,SAAS;MACpB;MACA8B,MAAM,GAAGA,MAAM,CAACD,QAAQ,CAACC,MAAM;IACnC;IACA,OAAOA,MAAM,CAACoB,UAAU,CAAC,CAAC,CAAC,CAAC;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;EACII,YAAYA,CAAA,EAAG;IACX,OAAO;MACHC,MAAM,EAAE;QACJC,IAAI,EAAE,IAAI,CAACnD,IAAI,CAACoD,aAAa;QAC7B3B,MAAM,EAAE,IAAI,CAAC1B;MACjB;IACJ,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;AACA;EACIsD,eAAeA,CAAA,EAAG;IACd,IAAIC,EAAE,EAAEC,EAAE;IACV,OAAO;MACHJ,IAAI,EAAE,IAAI,CAACnD,IAAI,CAACoD,aAAa;MAC7BxD,UAAU,EAAE,CAAC0D,EAAE,GAAG,IAAI,CAAC1D,UAAU,MAAM,IAAI,IAAI0D,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,OAAO,CAAC,CAAC,CAACC,cAAc;MACnG5D,UAAU,EAAE,CAAC0D,EAAE,GAAG,IAAI,CAAC1D,UAAU,MAAM,IAAI,IAAI0D,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACC,OAAO,CAAC,CAAC,CAACC,cAAc;MACnGhC,MAAM,EAAE,IAAI,CAAC1B;IACjB,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI2D,OAAOA,CAACC,KAAK,EAAE;IACX;IACA;IACA,OAAQ,IAAI,KAAKA,KAAK,IACjBA,KAAK,YAAY9E,gBAAgB,IAC9B,IAAI,CAACmB,IAAI,CAAC0D,OAAO,CAACC,KAAK,CAAC3D,IAAI,CAAC,IAC7BjB,SAAS,CAAC,IAAI,CAACgB,YAAY,EAAE4D,KAAK,CAAC5D,YAAY,CAAE;EAC7D;AACJ;AACAxB,OAAO,CAACM,gBAAgB,GAAGA,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,qBAAqB,SAASC,gBAAgB,CAAC;EACjD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIe,UAAUA,CAAA,EAAG;IACb,OAAO,KAAK,CAACA,UAAU;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,UAAUA,CAAA,EAAG;IACb,OAAO,KAAK,CAACA,UAAU;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIc,IAAIA,CAAA,EAAG;IACH,MAAMA,IAAI,GAAG,KAAK,CAACA,IAAI,CAAC,CAAC;IACzB,IAAI,CAACA,IAAI,EAAE;MACP,MAAM,IAAIoB,KAAK,CAAC,0DAA0D,CAAC;IAC/E;IACA,OAAOpB,IAAI;EACf;AACJ;AACApC,OAAO,CAACK,qBAAqB,GAAGA,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,YAAY,CAAC;EACf;AACJ;AACA;AACA;AACA;AACA;AACA;EACIY,WAAWA,CAACqE,UAAU,EAAE;IACpB,IAAI,CAACC,YAAY,GAAGD,UAAU;IAC9B,IAAI,CAACC,YAAY,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,SAAS,CAACD,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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}