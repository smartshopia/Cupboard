{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateServiceStub = generateServiceStub;\n/* global window */\n/* global AbortController */\nconst node_fetch_1 = require(\"node-fetch\");\nconst abort_controller_1 = require(\"abort-controller\");\nconst featureDetection_1 = require(\"./featureDetection\");\nconst streamArrayParser_1 = require(\"./streamArrayParser\");\nconst stream_1 = require(\"stream\");\nfunction generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder, numericEnums) {\n  const fetch = (0, featureDetection_1.hasWindowFetch)() ? window.fetch : node_fetch_1.default;\n  const serviceStub = {\n    // close method should close all cancel controllers. If this feature request in the future, we can have a cancelControllerFactory that tracks created cancel controllers, and abort them all in close method.\n    close: () => {\n      return {\n        cancel: () => {}\n      };\n    }\n  };\n  for (const [rpcName, rpc] of Object.entries(rpcs)) {\n    serviceStub[rpcName] = (request, options, _metadata, callback) => {\n      options !== null && options !== void 0 ? options : options = {};\n      // We cannot use async-await in this function because we need to return the canceller object as soon as possible.\n      // Using plain old promises instead.\n      let fetchParameters;\n      try {\n        fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request, numericEnums);\n      } catch (err) {\n        // we could not encode parameters; pass error to the callback\n        // and return a no-op canceler object.\n        if (callback) {\n          callback(err);\n        }\n        return {\n          cancel() {}\n        };\n      }\n      const cancelController = (0, featureDetection_1.hasAbortController)() ? new AbortController() : new abort_controller_1.AbortController();\n      const cancelSignal = cancelController.signal;\n      let cancelRequested = false;\n      const url = fetchParameters.url;\n      const headers = fetchParameters.headers;\n      for (const key of Object.keys(options)) {\n        headers[key] = options[key][0];\n      }\n      const streamArrayParser = new streamArrayParser_1.StreamArrayParser(rpc);\n      authClient.getRequestHeaders().then(authHeader => {\n        const fetchRequest = {\n          headers: {\n            ...authHeader,\n            ...headers\n          },\n          body: fetchParameters.body,\n          method: fetchParameters.method,\n          signal: cancelSignal\n        };\n        if (fetchParameters.method === 'GET' || fetchParameters.method === 'DELETE') {\n          delete fetchRequest['body'];\n        }\n        return fetch(url, fetchRequest);\n      }).then(response => {\n        if (response.ok && rpc.responseStream) {\n          (0, stream_1.pipeline)(response.body, streamArrayParser, err => {\n            if (err && (!cancelRequested || err instanceof Error && err.name !== 'AbortError')) {\n              if (callback) {\n                callback(err);\n              }\n              streamArrayParser.emit('error', err);\n            }\n          });\n          return;\n        } else {\n          return Promise.all([Promise.resolve(response.ok), response.arrayBuffer()]).then(([ok, buffer]) => {\n            const response = responseDecoder(rpc, ok, buffer);\n            callback(null, response);\n          }).catch(err => {\n            if (!cancelRequested || err.name !== 'AbortError') {\n              if (rpc.responseStream) {\n                if (callback) {\n                  callback(err);\n                }\n                streamArrayParser.emit('error', err);\n              } else if (callback) {\n                callback(err);\n              } else {\n                throw err;\n              }\n            }\n          });\n        }\n      }).catch(err => {\n        if (rpc.responseStream) {\n          if (callback) {\n            callback(err);\n          }\n          streamArrayParser.emit('error', err);\n        } else if (callback) {\n          callback(err);\n        } else {\n          throw err;\n        }\n      });\n      if (rpc.responseStream) {\n        return streamArrayParser;\n      }\n      return {\n        cancel: () => {\n          cancelRequested = true;\n          cancelController.abort();\n        }\n      };\n    };\n  }\n  return serviceStub;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","generateServiceStub","node_fetch_1","require","abort_controller_1","featureDetection_1","streamArrayParser_1","stream_1","rpcs","protocol","servicePath","servicePort","authClient","requestEncoder","responseDecoder","numericEnums","fetch","hasWindowFetch","window","default","serviceStub","close","cancel","rpcName","rpc","entries","request","options","_metadata","callback","fetchParameters","err","cancelController","hasAbortController","AbortController","cancelSignal","signal","cancelRequested","url","headers","key","keys","streamArrayParser","StreamArrayParser","getRequestHeaders","then","authHeader","fetchRequest","body","method","response","ok","responseStream","pipeline","Error","name","emit","Promise","all","resolve","arrayBuffer","buffer","catch","abort"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/google-gax/build/src/fallbackServiceStub.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateServiceStub = generateServiceStub;\n/* global window */\n/* global AbortController */\nconst node_fetch_1 = require(\"node-fetch\");\nconst abort_controller_1 = require(\"abort-controller\");\nconst featureDetection_1 = require(\"./featureDetection\");\nconst streamArrayParser_1 = require(\"./streamArrayParser\");\nconst stream_1 = require(\"stream\");\nfunction generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder, numericEnums) {\n    const fetch = (0, featureDetection_1.hasWindowFetch)()\n        ? window.fetch\n        : node_fetch_1.default;\n    const serviceStub = {\n        // close method should close all cancel controllers. If this feature request in the future, we can have a cancelControllerFactory that tracks created cancel controllers, and abort them all in close method.\n        close: () => {\n            return { cancel: () => { } };\n        },\n    };\n    for (const [rpcName, rpc] of Object.entries(rpcs)) {\n        serviceStub[rpcName] = (request, options, _metadata, callback) => {\n            options !== null && options !== void 0 ? options : (options = {});\n            // We cannot use async-await in this function because we need to return the canceller object as soon as possible.\n            // Using plain old promises instead.\n            let fetchParameters;\n            try {\n                fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request, numericEnums);\n            }\n            catch (err) {\n                // we could not encode parameters; pass error to the callback\n                // and return a no-op canceler object.\n                if (callback) {\n                    callback(err);\n                }\n                return {\n                    cancel() { },\n                };\n            }\n            const cancelController = (0, featureDetection_1.hasAbortController)()\n                ? new AbortController()\n                : new abort_controller_1.AbortController();\n            const cancelSignal = cancelController.signal;\n            let cancelRequested = false;\n            const url = fetchParameters.url;\n            const headers = fetchParameters.headers;\n            for (const key of Object.keys(options)) {\n                headers[key] = options[key][0];\n            }\n            const streamArrayParser = new streamArrayParser_1.StreamArrayParser(rpc);\n            authClient\n                .getRequestHeaders()\n                .then(authHeader => {\n                const fetchRequest = {\n                    headers: {\n                        ...authHeader,\n                        ...headers,\n                    },\n                    body: fetchParameters.body,\n                    method: fetchParameters.method,\n                    signal: cancelSignal,\n                };\n                if (fetchParameters.method === 'GET' ||\n                    fetchParameters.method === 'DELETE') {\n                    delete fetchRequest['body'];\n                }\n                return fetch(url, fetchRequest);\n            })\n                .then((response) => {\n                if (response.ok && rpc.responseStream) {\n                    (0, stream_1.pipeline)(response.body, streamArrayParser, (err) => {\n                        if (err &&\n                            (!cancelRequested ||\n                                (err instanceof Error && err.name !== 'AbortError'))) {\n                            if (callback) {\n                                callback(err);\n                            }\n                            streamArrayParser.emit('error', err);\n                        }\n                    });\n                    return;\n                }\n                else {\n                    return Promise.all([\n                        Promise.resolve(response.ok),\n                        response.arrayBuffer(),\n                    ])\n                        .then(([ok, buffer]) => {\n                        const response = responseDecoder(rpc, ok, buffer);\n                        callback(null, response);\n                    })\n                        .catch((err) => {\n                        if (!cancelRequested || err.name !== 'AbortError') {\n                            if (rpc.responseStream) {\n                                if (callback) {\n                                    callback(err);\n                                }\n                                streamArrayParser.emit('error', err);\n                            }\n                            else if (callback) {\n                                callback(err);\n                            }\n                            else {\n                                throw err;\n                            }\n                        }\n                    });\n                }\n            })\n                .catch((err) => {\n                if (rpc.responseStream) {\n                    if (callback) {\n                        callback(err);\n                    }\n                    streamArrayParser.emit('error', err);\n                }\n                else if (callback) {\n                    callback(err);\n                }\n                else {\n                    throw err;\n                }\n            });\n            if (rpc.responseStream) {\n                return streamArrayParser;\n            }\n            return {\n                cancel: () => {\n                    cancelRequested = true;\n                    cancelController.abort();\n                },\n            };\n        };\n    }\n    return serviceStub;\n}\n//# sourceMappingURL=fallbackServiceStub.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}