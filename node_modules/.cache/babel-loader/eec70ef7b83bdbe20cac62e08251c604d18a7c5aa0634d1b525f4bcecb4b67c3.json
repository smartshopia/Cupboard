{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PagedApiCaller = void 0;\nconst call_1 = require(\"../call\");\nconst googleError_1 = require(\"../googleError\");\nconst resourceCollector_1 = require(\"./resourceCollector\");\nclass PagedApiCaller {\n  /**\n   * Creates an API caller that returns a stream to performs page-streaming.\n   *\n   * @private\n   * @constructor\n   * @param {PageDescriptor} pageDescriptor - indicates the structure\n   *   of page streaming to be performed.\n   */\n  constructor(pageDescriptor) {\n    this.pageDescriptor = pageDescriptor;\n  }\n  /**\n   * This function translates between regular gRPC calls (that accepts a request and returns a response,\n   * and does not know anything about pages and page tokens) and the users' callback (that expects\n   * to see resources from one page, a request to get the next page, and the raw response from the server).\n   *\n   * It generates a function that can be passed as a callback function to a gRPC call, will understand\n   * pagination-specific fields in the response, and call the users' callback after having those fields\n   * parsed.\n   *\n   * @param request Request object. It needs to be passed to all subsequent next page requests\n   * (the main content of the request object stays unchanged, only the next page token changes)\n   * @param callback The user's callback that expects the page content, next page request, and raw response.\n   */\n  generateParseResponseCallback(request, callback) {\n    const resourceFieldName = this.pageDescriptor.resourceField;\n    const responsePageTokenFieldName = this.pageDescriptor.responsePageTokenField;\n    const requestPageTokenFieldName = this.pageDescriptor.requestPageTokenField;\n    return (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      if (!request) {\n        callback(new googleError_1.GoogleError('Undefined request in pagination method callback.'));\n        return;\n      }\n      if (!response) {\n        callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n        return;\n      }\n      const resources = response[resourceFieldName] || [];\n      const pageToken = response[responsePageTokenFieldName];\n      let nextPageRequest = null;\n      if (pageToken) {\n        nextPageRequest = Object.assign({}, request);\n        nextPageRequest[requestPageTokenFieldName] = pageToken;\n      }\n      callback(err, resources, nextPageRequest, response);\n    };\n  }\n  /**\n   * Adds a special ability to understand pagination-specific fields to the existing gRPC call.\n   * The original gRPC call just calls callback(err, result).\n   * The wrapped one will call callback(err, resources, nextPageRequest, rawResponse) instead.\n   *\n   * @param func gRPC call (normally, a service stub call). The gRPC call is expected to accept four parameters:\n   * request, metadata, call options, and callback.\n   */\n  wrap(func) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    return function wrappedCall(argument, metadata, options, callback) {\n      return func(argument, metadata, options, self.generateParseResponseCallback(argument, callback));\n    };\n  }\n  /**\n   * Makes it possible to use both callback-based and promise-based calls.\n   * Returns an OngoingCall or OngoingCallPromise object.\n   * Regardless of which one is returned, it always has a `.callback` to call.\n   *\n   * @param settings Call settings. Can only be used to replace Promise with another promise implementation.\n   * @param [callback] Callback to be called, if any.\n   */\n  init(callback) {\n    if (callback) {\n      return new call_1.OngoingCall(callback);\n    }\n    return new call_1.OngoingCallPromise();\n  }\n  /**\n   * Implements auto-pagination logic.\n   *\n   * @param apiCall A function that performs gRPC request and calls its callback with a response or an error.\n   * It's supposed to be a gRPC service stub function wrapped into several layers of wrappers that make it\n   * accept just two parameters: (request, callback).\n   * @param request A request object that came from the user.\n   * @param settings Call settings. We are interested in `maxResults` and `autoPaginate` (they are optional).\n   * @param ongoingCall An instance of OngoingCall or OngoingCallPromise that can be used for call cancellation,\n   * and is used to return results to the user.\n   */\n  call(apiCall, request, settings, ongoingCall) {\n    request = Object.assign({}, request);\n    if (!settings.autoPaginate) {\n      // they don't want auto-pagination this time - okay, just call once\n      ongoingCall.call(apiCall, request);\n      return;\n    }\n    const maxResults = settings.maxResults || -1;\n    const resourceCollector = new resourceCollector_1.ResourceCollector(apiCall, maxResults);\n    resourceCollector.processAllPages(request).then(resources => ongoingCall.callback(null, resources), err => ongoingCall.callback(err));\n  }\n  fail(ongoingCall, err) {\n    ongoingCall.callback(err);\n  }\n  result(ongoingCall) {\n    return ongoingCall.promise;\n  }\n}\nexports.PagedApiCaller = PagedApiCaller;","map":{"version":3,"names":["Object","defineProperty","exports","value","PagedApiCaller","call_1","require","googleError_1","resourceCollector_1","constructor","pageDescriptor","generateParseResponseCallback","request","callback","resourceFieldName","resourceField","responsePageTokenFieldName","responsePageTokenField","requestPageTokenFieldName","requestPageTokenField","err","response","GoogleError","resources","pageToken","nextPageRequest","assign","wrap","func","self","wrappedCall","argument","metadata","options","init","OngoingCall","OngoingCallPromise","call","apiCall","settings","ongoingCall","autoPaginate","maxResults","resourceCollector","ResourceCollector","processAllPages","then","fail","result","promise"],"sources":["C:/Users/ATTA UR REHMAN/Music/Fida/Cupboard/node_modules/google-gax/build/src/paginationCalls/pagedApiCaller.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PagedApiCaller = void 0;\nconst call_1 = require(\"../call\");\nconst googleError_1 = require(\"../googleError\");\nconst resourceCollector_1 = require(\"./resourceCollector\");\nclass PagedApiCaller {\n    /**\n     * Creates an API caller that returns a stream to performs page-streaming.\n     *\n     * @private\n     * @constructor\n     * @param {PageDescriptor} pageDescriptor - indicates the structure\n     *   of page streaming to be performed.\n     */\n    constructor(pageDescriptor) {\n        this.pageDescriptor = pageDescriptor;\n    }\n    /**\n     * This function translates between regular gRPC calls (that accepts a request and returns a response,\n     * and does not know anything about pages and page tokens) and the users' callback (that expects\n     * to see resources from one page, a request to get the next page, and the raw response from the server).\n     *\n     * It generates a function that can be passed as a callback function to a gRPC call, will understand\n     * pagination-specific fields in the response, and call the users' callback after having those fields\n     * parsed.\n     *\n     * @param request Request object. It needs to be passed to all subsequent next page requests\n     * (the main content of the request object stays unchanged, only the next page token changes)\n     * @param callback The user's callback that expects the page content, next page request, and raw response.\n     */\n    generateParseResponseCallback(request, callback) {\n        const resourceFieldName = this.pageDescriptor.resourceField;\n        const responsePageTokenFieldName = this.pageDescriptor.responsePageTokenField;\n        const requestPageTokenFieldName = this.pageDescriptor.requestPageTokenField;\n        return (err, response) => {\n            if (err) {\n                callback(err);\n                return;\n            }\n            if (!request) {\n                callback(new googleError_1.GoogleError('Undefined request in pagination method callback.'));\n                return;\n            }\n            if (!response) {\n                callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n                return;\n            }\n            const resources = response[resourceFieldName] || [];\n            const pageToken = response[responsePageTokenFieldName];\n            let nextPageRequest = null;\n            if (pageToken) {\n                nextPageRequest = Object.assign({}, request);\n                nextPageRequest[requestPageTokenFieldName] = pageToken;\n            }\n            callback(err, resources, nextPageRequest, response);\n        };\n    }\n    /**\n     * Adds a special ability to understand pagination-specific fields to the existing gRPC call.\n     * The original gRPC call just calls callback(err, result).\n     * The wrapped one will call callback(err, resources, nextPageRequest, rawResponse) instead.\n     *\n     * @param func gRPC call (normally, a service stub call). The gRPC call is expected to accept four parameters:\n     * request, metadata, call options, and callback.\n     */\n    wrap(func) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        return function wrappedCall(argument, metadata, options, callback) {\n            return func(argument, metadata, options, self.generateParseResponseCallback(argument, callback));\n        };\n    }\n    /**\n     * Makes it possible to use both callback-based and promise-based calls.\n     * Returns an OngoingCall or OngoingCallPromise object.\n     * Regardless of which one is returned, it always has a `.callback` to call.\n     *\n     * @param settings Call settings. Can only be used to replace Promise with another promise implementation.\n     * @param [callback] Callback to be called, if any.\n     */\n    init(callback) {\n        if (callback) {\n            return new call_1.OngoingCall(callback);\n        }\n        return new call_1.OngoingCallPromise();\n    }\n    /**\n     * Implements auto-pagination logic.\n     *\n     * @param apiCall A function that performs gRPC request and calls its callback with a response or an error.\n     * It's supposed to be a gRPC service stub function wrapped into several layers of wrappers that make it\n     * accept just two parameters: (request, callback).\n     * @param request A request object that came from the user.\n     * @param settings Call settings. We are interested in `maxResults` and `autoPaginate` (they are optional).\n     * @param ongoingCall An instance of OngoingCall or OngoingCallPromise that can be used for call cancellation,\n     * and is used to return results to the user.\n     */\n    call(apiCall, request, settings, ongoingCall) {\n        request = Object.assign({}, request);\n        if (!settings.autoPaginate) {\n            // they don't want auto-pagination this time - okay, just call once\n            ongoingCall.call(apiCall, request);\n            return;\n        }\n        const maxResults = settings.maxResults || -1;\n        const resourceCollector = new resourceCollector_1.ResourceCollector(apiCall, maxResults);\n        resourceCollector.processAllPages(request).then(resources => ongoingCall.callback(null, resources), err => ongoingCall.callback(err));\n    }\n    fail(ongoingCall, err) {\n        ongoingCall.callback(err);\n    }\n    result(ongoingCall) {\n        return ongoingCall.promise;\n    }\n}\nexports.PagedApiCaller = PagedApiCaller;\n//# sourceMappingURL=pagedApiCaller.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}